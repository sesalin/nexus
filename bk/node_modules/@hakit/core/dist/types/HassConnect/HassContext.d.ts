import { Connection, HassEntities, HassEntity, HassConfig, HassServices, Auth, UnsubscribeFunc } from 'home-assistant-js-websocket';
import { CSSInterpolation } from '@emotion/serialize';
import { ServiceData, SnakeOrCamelDomains, DomainService, Target, LocaleKeys, ServiceResponse } from '../types';
import { ConnectionStatus } from './handleSuspendResume';
import { AreaRegistryEntry, AuthUser, DeviceRegistryEntry, EntityRegistryDisplayEntry, FloorRegistryEntry, FrontendLocaleData } from '..';
import { DateFormatters } from './createDateFormatters';
import { CurrentUser } from '../utils/subscribe/user';
export interface CallServiceArgs<T extends SnakeOrCamelDomains, M extends DomainService<T>, R extends boolean> {
    domain: T;
    service: M;
    serviceData?: ServiceData<T, M>;
    target?: Target;
    returnResponse?: R;
}
export interface Route {
    hash: string;
    name: string;
    icon: string;
    active: boolean;
}
export interface SensorNumericDeviceClasses {
    numeric_device_classes: string[];
}
export type SupportedComponentOverrides = "buttonCard" | "modal" | "areaCard" | "calendarCard" | "climateCard" | "cameraCard" | "entitiesCard" | "fabCard" | "cardBase" | "garbageCollectionCard" | "mediaPlayerCard" | "pictureCard" | "sensorCard" | "timeCard" | "triggerCard" | "weatherCard" | "menu" | "personCard" | "familyCard" | "vacuumCard" | "alarmCard";
export interface InternalStore {
    sensorNumericDeviceClasses: string[];
    setSensorNumericDeviceClasses: (classes: string[]) => void;
    /** home assistant instance locale data */
    locale: FrontendLocaleData | null;
    setLocale: (locale: FrontendLocaleData | null) => void;
    /** the device registry from home assistant */
    devices: Record<string, DeviceRegistryEntry>;
    setDevices: (devices: Record<string, DeviceRegistryEntry>) => void;
    /** the entity registry display from home assistant */
    entitiesRegistryDisplay: Record<string, EntityRegistryDisplayEntry>;
    setEntitiesRegistryDisplay: (entities: Record<string, EntityRegistryDisplayEntry>) => void;
    /** the area registry from home assistant */
    areas: Record<string, AreaRegistryEntry>;
    setAreas: (areas: Record<string, AreaRegistryEntry>) => void;
    /** the floor registry from home assistant */
    floors: Record<string, FloorRegistryEntry>;
    setFloors: (floors: Record<string, FloorRegistryEntry>) => void;
    /** The entities in the home assistant instance */
    entities: HassEntities;
    setEntities: (entities: HassEntities) => void;
    /** the home assistant services data */
    services: HassServices;
    setServices: (services: HassServices) => void;
    /** the connection status of your home assistant instance */
    connectionStatus: ConnectionStatus;
    setConnectionStatus: (status: ConnectionStatus) => void;
    /** The connection object from home-assistant-js-websocket */
    connection: Connection | null;
    setConnection: (connection: Connection | null) => void;
    /** any errors caught during core authentication */
    error: null | string;
    setError: (error: string | null) => void;
    /** if there was an issue connecting to HA */
    cannotConnect: boolean;
    setCannotConnect: (cannotConnect: boolean) => void;
    /** This is an internal value, no need to use this */
    ready: boolean;
    setReady: (ready: boolean) => void;
    /** the current hash in the url */
    hash: string;
    /** set the current hash */
    setHash: (hash: string) => void;
    /** returns available routes */
    routes: Route[];
    setRoutes: (routes: Route[]) => void;
    /** the home assistant authentication object */
    auth: Auth | null;
    setAuth: (auth: Auth | null) => void;
    /** the current authenticated user */
    user: CurrentUser | null;
    setUser: (user: CurrentUser | null) => void;
    /** all users in the home assistant instance */
    users: AuthUser[];
    setUsers: (users: AuthUser[]) => void;
    /** the home assistant configuration */
    config: HassConfig | null;
    setConfig: (config: HassConfig | null) => void;
    /** the hassUrl provided to the HassConnect component */
    hassUrl: string | null;
    /** set the hassUrl */
    setHassUrl: (hassUrl: string | null) => void;
    /** a way to provide or overwrite default styles for any particular component */
    setGlobalComponentStyles: (styles: Partial<Record<SupportedComponentOverrides, CSSInterpolation>>) => void;
    globalComponentStyles: Partial<Record<SupportedComponentOverrides, CSSInterpolation>>;
    portalRoot?: HTMLElement;
    setPortalRoot: (portalRoot: HTMLElement) => void;
    locales: Record<LocaleKeys, string> | null;
    setLocales: (locales: Record<LocaleKeys, string>) => void;
    setWindowContext: (windowContext: Window) => void;
    windowContext: Window;
    /** internal - callbacks that will fire when the connection disconnects with home assistant */
    disconnectCallbacks: (() => void)[];
    /** use this to trigger certain functionality when the web socket connection disconnects */
    onDisconnect?: (cb: () => void) => void;
    /** internal function which will trigger when the connection disconnects */
    triggerOnDisconnect: () => void;
    /** convenience helpers to format specific entity attributes, values, dates etc */
    formatter: {
        /** will format the state value automatically based on the entity provided */
        stateValue: (entity: HassEntity) => string;
        /** will format the attribute value automatically based on the entity and attribute provided */
        attributeValue: (entity: HassEntity, attribute: string) => string;
    } & DateFormatters;
    helpers: {
        /** logout of HA */
        logout: () => void;
        /** function to call a service through web sockets */
        callService: {
            <ResponseType extends object, T extends SnakeOrCamelDomains, M extends DomainService<T>>(args: CallServiceArgs<T, M, true>): Promise<ServiceResponse<ResponseType>>;
            /** Overload for when `returnResponse` is false */
            <_ResponseType extends object, T extends SnakeOrCamelDomains, M extends DomainService<T>>(args: CallServiceArgs<T, M, false>): void;
            /** Overload for when `returnResponse` is omitted (defaults to false) */
            <_ResponseType extends object, T extends SnakeOrCamelDomains, M extends DomainService<T>>(args: Omit<CallServiceArgs<T, M, false>, "returnResponse">): void;
        };
        /** add a new route to the provider */
        addRoute: (route: Omit<Route, "active">) => void;
        /** retrieve a route by name */
        getRoute: (hash: string) => Route | null;
        /** will retrieve all HassEntities from the context */
        getAllEntities: () => HassEntities;
        /** join a path to the hassUrl */
        joinHassUrl: (path: string) => string;
        /** call the home assistant api */
        callApi: <T>(endpoint: string, options?: RequestInit) => Promise<{
            data: T;
            status: "success";
        } | {
            data: string;
            status: "error";
        }>;
        /** date time related helper functions */
        dateTime: {
            /** determine if the current locale/timezone should use am/pm time format */
            shouldUseAmPm: () => boolean;
            /** resolve the correct timezone to use based on locale and config */
            getTimeZone: () => string;
        };
    };
}
export interface HassProviderStore {
    /** whether we've successfully initiated an auth/connect attempt for current hassUrl */
    authenticated: boolean;
    /** set authenticated flag */
    setAuthenticated: (value: boolean) => void;
    /** active unsubscribe functions keyed by a descriptive name */
    subscriptions: Record<string, UnsubscribeFunc>;
    /** register (or replace) a subscription; will auto-unsubscribe previous key before storing */
    addSubscription: (key: string, fn: UnsubscribeFunc | null | undefined) => void;
    /** remove a subscription by key and call its unsubscribe */
    removeSubscription: (key: string) => void;
    /** unsubscribe every tracked subscription and clear map */
    unsubscribeAll: () => void;
    /** resets the information on the internal store */
    reset: () => void;
}
export declare const useInternalStore: import('zustand').UseBoundStore<import('zustand').StoreApi<InternalStore>>;
export declare const useHassProviderStore: import('zustand').UseBoundStore<import('zustand').StoreApi<HassProviderStore>>;
//# sourceMappingURL=HassContext.d.ts.map