import { EntityRegistryEntry, RegistryEntry } from '../entity_registry';
import { Connection } from 'home-assistant-js-websocket';
import { DeviceRegistryEntry } from './devices';
export interface AreaRegistryEntry extends RegistryEntry {
    /** the name of the area */
    name: string;
    /** the picture of the area */
    picture: string | null;
    /** alias names */
    aliases: string[];
    /** the id of the area */
    area_id: string;
    /** the id of the floor the area is on */
    floor_id: string | null;
    /** the id of the humidity sensor for the area */
    humidity_entity_id: string | null;
    /** the icon to use for the area */
    icon: string | null;
    /** labels for the area */
    labels: string[];
    /** the id of the temperature sensor for the area */
    temperature_entity_id: string | null;
}
/**
 * Create a managed collection for the area registry.
 * Automatically fetches initial data and subscribes to updates, invoking `onChange` whenever data changes.
 *
 * @param conn Active HA websocket connection.
 * @param onChange Callback invoked with the latest list of areas when data refreshes.
 * @returns Unsubscribe function for the underlying collection.
 */
export declare const subscribeAreaRegistry: (conn: Connection, onChange: (areas: AreaRegistryEntry[]) => void) => import('home-assistant-js-websocket').UnsubscribeFunc;
export type AreaEntityLookup = Record<string, EntityRegistryEntry[]>;
export type AreaDeviceLookup = Record<string, DeviceRegistryEntry[]>;
export interface AreaRegistryEntryMutableParams {
    aliases?: string[];
    floor_id?: string | null;
    humidity_entity_id?: string | null;
    icon?: string | null;
    labels?: string[];
    name: string;
    picture?: string | null;
    temperature_entity_id?: string | null;
}
/**
 * Create a new area registry entry.
 *
 * Issues `config/area_registry/create` with provided mutable parameters (name required).
 *
 * @param connection HA websocket connection.
 * @param values Area creation parameters (name mandatory, others optional).
 * @returns Promise resolving to the newly created AreaRegistryEntry.
 */
export declare const createAreaRegistryEntry: (connection: Connection, values: AreaRegistryEntryMutableParams) => Promise<AreaRegistryEntry>;
/**
 * Update an existing area registry entry.
 *
 * Issues `config/area_registry/update` with partial update fields.
 *
 * @param connection HA websocket connection.
 * @param areaId Target area's `area_id`.
 * @param updates Partial area fields to change.
 * @returns Promise resolving to the updated AreaRegistryEntry.
 */
export declare const updateAreaRegistryEntry: (connection: Connection, areaId: string, updates: Partial<AreaRegistryEntryMutableParams>) => Promise<AreaRegistryEntry>;
/**
 * Delete an area from the registry.
 *
 * Issues `config/area_registry/delete`.
 *
 * @param connection HA websocket connection.
 * @param areaId The `area_id` of the area to remove.
 * @returns Promise resolving when the deletion is acknowledged.
 */
export declare const deleteAreaRegistryEntry: (connection: Connection, areaId: string) => Promise<unknown>;
/**
 * Build a lookup mapping area_id -> list of entity registry entries directly assigned to that area.
 * Ignores entities without an explicit `area_id` (those may inherit via devices elsewhere).
 *
 * @param entities Full list of entity registry entries.
 * @returns Record area_id -> array of entity entries.
 */
export declare const getAreaEntityLookup: (entities: EntityRegistryEntry[]) => AreaEntityLookup;
/**
 * Build a lookup mapping area_id -> list of device registry entries assigned to that area.
 * Devices without an `area_id` are skipped.
 *
 * @param devices Array of device registry entries.
 * @returns Record area_id -> array of device entries.
 */
export declare const getAreaDeviceLookup: (devices: DeviceRegistryEntry[]) => AreaDeviceLookup;
/**
 * Produce a comparator function for sorting area ids.
 *
 * If an explicit `order` array is supplied, areas found in that array are sorted by their index
 * and areas not present are pushed after those that are. When both are absent from the order list
 * a locale-aware name comparison (via `stringCompare`) is used.
 *
 * @param entries Lookup of area_id -> AreaRegistryEntry used to resolve names.
 * @param order Optional explicit ordering of area_ids.
 * @returns Comparator function suitable for Array.sort.
 */
export declare const areaCompare: (entries: Record<string, AreaRegistryEntry>, order?: string[]) => (a: string, b: string) => number;
//# sourceMappingURL=areas.d.ts.map