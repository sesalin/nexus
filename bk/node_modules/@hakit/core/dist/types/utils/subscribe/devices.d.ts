import { AreaRegistryEntry, EntityListInfoCommon, EntityRegistryDisplayEntry, EntityRegistryEntry, FloorRegistryEntry, RegistryEntry } from '../..';
import { Connection, HassEntities, HassEntity } from 'home-assistant-js-websocket';
import { EntitySources } from './entity_sources';
/**
 * Home Assistant device registry entry (extended shape).
 * Mirrors HA's `config/device_registry/list` response with selected fields.
 */
export interface DeviceRegistryEntry extends RegistryEntry {
    id: string;
    config_entries: string[];
    config_entries_subentries: Record<string, (string | null)[]>;
    connections: [string, string][];
    identifiers: [string, string][];
    manufacturer: string | null;
    model: string | null;
    model_id: string | null;
    name: string | null;
    labels: string[];
    sw_version: string | null;
    hw_version: string | null;
    serial_number: string | null;
    via_device_id: string | null;
    area_id: string | null;
    name_by_user: string | null;
    entry_type: "service" | null;
    disabled_by: "user" | "integration" | "config_entry" | null;
    configuration_url: string | null;
    primary_config_entry: string | null;
}
/**
 * Public subscription wrapper providing createCollection semantics.
 * @param conn Active HA connection.
 * @param onChange Callback invoked with the latest device list anytime it changes.
 * @returns Unsubscribe function to stop listening.
 */
export declare const subscribeDeviceRegistry: (conn: Connection, onChange: (devices: DeviceRegistryEntry[]) => void) => import('home-assistant-js-websocket').UnsubscribeFunc;
export type DeviceEntityDisplayLookup = Record<string, EntityRegistryDisplayEntry[]>;
export type DeviceEntityLookup = Record<string, EntityRegistryEntry[]>;
export interface DeviceRegistryEntryMutableParams {
    area_id?: string | null;
    name_by_user?: string | null;
    disabled_by?: string | null;
    labels?: string[];
}
/**
 * Attempt to derive a readable device name from one of its entities' state names.
 * Used when the device has no explicit name.
 * @param hassEntities Current states map.
 * @param entities Entities associated with the device (or raw entity_id strings).
 * @returns First non-empty computed state name or undefined.
 */
export declare const fallbackDeviceName: (hassEntities: HassEntities, entities: EntityRegistryEntry[] | EntityRegistryDisplayEntry[] | string[]) => string | undefined;
/**
 * Filter devices by a specific area id.
 * @param devices All devices.
 * @param areaId Target area id.
 */
export declare const devicesInArea: (devices: DeviceRegistryEntry[], areaId: string) => DeviceRegistryEntry[];
/**
 * Update mutable fields on a device registry entry.
 * @param connection HA connection.
 * @param deviceId Target device id.
 * @param updates Partial of mutable params.
 * @returns Updated device entry.
 */
export declare const updateDeviceRegistryEntry: (connection: Connection, deviceId: string, updates: Partial<DeviceRegistryEntryMutableParams>) => Promise<DeviceRegistryEntry>;
/**
 * Detach a config entry from a device (e.g. removing an integration association).
 * @param connection HA connection.
 * @param deviceId Device id.
 * @param configEntryId Config entry id to remove.
 * @returns Updated device entry.
 */
export declare const removeConfigEntryFromDevice: (connection: Connection, deviceId: string, configEntryId: string) => Promise<DeviceRegistryEntry>;
/**
 * Sort devices in-place by their name using locale-aware case-insensitive comparison.
 * @param entries Mutable array of device entries.
 * @param language BCP-47 locale tag.
 */
export declare const sortDeviceRegistryByName: (entries: DeviceRegistryEntry[], language: string) => DeviceRegistryEntry[];
/**
 * Build a lookup mapping device_id => entities (raw registry entries).
 * @param entities All entity registry entries.
 */
export declare const getDeviceEntityLookup: (entities: EntityRegistryEntry[]) => DeviceEntityLookup;
/**
 * Build a lookup mapping device_id => display entities (enriched entries).
 * @param entities Enriched entity display entries.
 */
export declare const getDeviceEntityDisplayLookup: (entities: EntityRegistryDisplayEntry[]) => DeviceEntityDisplayLookup;
export interface ConfigEntry {
    entry_id: string;
    domain: string;
    title: string;
    source: string;
    state: "loaded" | "setup_error" | "migration_error" | "setup_retry" | "not_loaded" | "failed_unload" | "setup_in_progress";
    supports_options: boolean;
    supports_remove_device: boolean;
    supports_unload: boolean;
    supports_reconfigure: boolean;
    supported_subentry_types: Record<string, {
        supports_reconfigure: boolean;
    }>;
    num_subentries: number;
    pref_disable_new_entities: boolean;
    pref_disable_polling: boolean;
    disabled_by: "user" | null;
    reason: string | null;
    error_reason_translation_key: string | null;
    error_reason_translation_placeholders: Record<string, string> | null;
}
/**
 * Derive a mapping of device_id => set of integration domains.
 * Sources:
 * - Primary: entitySources (entity_id -> domain) for entities bound to the device.
 * - Fallback: config entry domains for devices that have no entities.
 * @param entitySources Source map from `entity/source`.
 * @param entities Entity entries (display or raw) to inspect for device linkage.
 * @param devices Optional list of devices (for fallback when no entities).
 * @param configEntries Optional config entry list for domain fallback.
 */
export declare const getDeviceIntegrationLookup: (entitySources: EntitySources, entities: EntityRegistryDisplayEntry[] | EntityRegistryEntry[], devices?: DeviceRegistryEntry[], configEntries?: ConfigEntry[]) => Record<string, Set<string>>;
/**
 * Combined context for a device including resolved area and floor.
 */
interface DeviceContext {
    device: DeviceRegistryEntry;
    area: AreaRegistryEntry | null;
    floor: FloorRegistryEntry | null;
}
/**
 * Resolve the area and floor objects for a given device.
 * @param device Device entry.
 * @param areas Lookup of areas by id.
 * @param floors Lookup of floors by id.
 */
export declare const getDeviceContext: (device: DeviceRegistryEntry, areas: Record<string, AreaRegistryEntry>, floors: Record<string, FloorRegistryEntry>) => DeviceContext;
/**
 * UI-friendly projection of a device suitable for list/search components.
 */
export interface DeviceListItem extends EntityListInfoCommon {
    domain?: string;
    domain_name?: string;
}
/**
 * Build a filtered, decorated list of devices for display/search.
 *
 * Filtering criteria (applied in sequence):
 * - Disabled devices excluded (unless matching `value` id)
 * - includeDomains: keep devices having at least one entity in one of the domains.
 * - excludeDomains: drop devices having any entity in excluded domains.
 * - excludeDevices: explicit id exclusion list.
 * - includeDeviceClasses: keep devices with entities whose state attributes.device_class matches.
 * - entityFilter: arbitrary predicate on entity state objects (logical OR across entities).
 * - deviceFilter: arbitrary predicate on the device (OR forcing inclusion if matches current `value`).
 *
 * Naming logic:
 * - Primary label derived via `computeDeviceNameDisplay` (uses explicit name or entity fallbacks).
 * - Secondary label uses area name when available.
 * - Domain & localized domain name derived from primary config entry (if present).
 *
 * @param hassEntities States map for entity-level filtering/device naming.
 * @param areas Area lookup.
 * @param floors Floor lookup.
 * @param entitiesI Entity display entry lookup keyed by entity_id.
 * @param devicesI Device registry lookup keyed by id.
 * @param configEntryLookup Config entries keyed by entry_id.
 * @param includeDomains Domains that must appear in device's entities to include the device.
 * @param excludeDomains Domains that, if present, exclude the device.
 * @param includeDeviceClasses Device classes that must appear among entities.
 * @param deviceFilter Optional predicate on device entry.
 * @param entityFilter Optional predicate on entity state.
 * @param excludeDevices Explicit list of device ids to omit.
 * @param value Current selected device id (always retained even if disabled or filtered out).
 * @param idPrefix Optional prefix applied to output item ids.
 * @returns Array of `DeviceListItem` ready for rendering/search.
 */
export declare const getDevices: (hassEntities: HassEntities, areas: Record<string, AreaRegistryEntry>, floors: Record<string, FloorRegistryEntry>, entitiesI: Record<string, EntityRegistryDisplayEntry>, devicesI: Record<string, DeviceRegistryEntry>, configEntryLookup: Record<string, ConfigEntry>, includeDomains?: string[], excludeDomains?: string[], includeDeviceClasses?: string[], deviceFilter?: (device: DeviceRegistryEntry) => boolean, entityFilter?: (entity: HassEntity) => boolean, excludeDevices?: string[], value?: string, idPrefix?: string) => DeviceListItem[];
export {};
//# sourceMappingURL=devices.d.ts.map