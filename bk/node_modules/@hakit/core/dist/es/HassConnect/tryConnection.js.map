{"version":3,"file":"tryConnection.js","sources":["../../../src/HassConnect/tryConnection.ts"],"sourcesContent":["// types\nimport type { Connection, getAuthOptions as AuthOptions, Auth } from \"home-assistant-js-websocket\";\n// methods\nimport {\n  getAuth,\n  createLongLivedTokenAuth,\n  createConnection,\n  ERR_HASS_HOST_REQUIRED,\n  ERR_CONNECTION_LOST,\n  ERR_CANNOT_CONNECT,\n  ERR_INVALID_AUTH,\n  ERR_INVALID_HTTPS_TO_HTTP,\n} from \"home-assistant-js-websocket\";\nimport { saveTokens, loadTokens, clearTokens } from \"./token-storage\";\n\nexport function handleError(err: number | string | Error | unknown, hassToken?: string): string {\n  const getMessage = () => {\n    switch (err) {\n      case ERR_INVALID_AUTH:\n        return `ERR_INVALID_AUTH: Invalid authentication. ${hassToken ? 'Check your \"Long-Lived Access Token\".' : \"\"}`;\n      case ERR_CANNOT_CONNECT:\n        return \"ERR_CANNOT_CONNECT: Unable to connect\";\n      case ERR_CONNECTION_LOST:\n        return \"ERR_CONNECTION_LOST: Lost connection to home assistant.\";\n      case ERR_HASS_HOST_REQUIRED:\n        return \"ERR_HASS_HOST_REQUIRED: Please enter a Home Assistant URL.\";\n      case ERR_INVALID_HTTPS_TO_HTTP:\n        return 'ERR_INVALID_HTTPS_TO_HTTP: Cannot connect to Home Assistant instances over \"http://\".';\n      default:\n        return null;\n    }\n  };\n  const message = getMessage();\n  if (message !== null) return message;\n  return (\n    (\n      err as {\n        error: string;\n      }\n    )?.error ||\n    (err as Error)?.message ||\n    `Unknown Error (${err})`\n  );\n}\ntype ConnectionResponse =\n  | {\n      type: \"success\";\n      connection: Connection;\n      auth: Auth;\n    }\n  | {\n      type: \"error\";\n      error: string;\n    }\n  | {\n      type: \"failed\";\n      cannotConnect: true;\n    };\n\ntype ConnectionType = \"auth-callback\" | \"user-request\" | \"saved-tokens\" | \"inherited-auth\" | \"provided-token\";\n\nfunction getInheritedConnection(): typeof window.hassConnection | undefined {\n  try {\n    return window.top?.hassConnection;\n  } catch (e) {\n    console.error(\"Error getting inherited connection\", e);\n    return undefined;\n  }\n}\n\nfunction determineConnectionType(hassUrl: string, hassToken?: string): ConnectionType {\n  const isAuthCallback = location && location.search.includes(\"auth_callback=1\");\n  const hasHassConnection = !!getInheritedConnection();\n  const providedToken = !!hassToken;\n  // when we have a hass connection, we don't need to validate the tokens\n  // so removing the tokens if values are different and we have a connection are not needed.\n  const savedTokens = !!loadTokens(hassUrl, false);\n\n  switch (true) {\n    case isAuthCallback:\n      return \"auth-callback\";\n    case hasHassConnection:\n      return \"inherited-auth\";\n    case providedToken:\n      return \"provided-token\";\n    case savedTokens:\n      return \"saved-tokens\";\n    default:\n      return \"user-request\";\n  }\n}\n\nexport const tryConnection = async (hassUrl: string, hassToken?: string): Promise<ConnectionResponse> => {\n  const connectionType = determineConnectionType(hassUrl, hassToken);\n\n  if (connectionType === \"inherited-auth\") {\n    try {\n      // if we've hit this connect type, the connection will be available\n      const { auth, conn } = (await getInheritedConnection()) as { conn: Connection; auth: Auth };\n      return {\n        type: \"success\",\n        connection: conn,\n        auth: auth,\n      };\n    } catch (e) {\n      const message = handleError(e, hassToken);\n      return {\n        type: \"error\",\n        error: message,\n      };\n    }\n  }\n  if (connectionType === \"provided-token\" && hassToken) {\n    try {\n      const auth = await createLongLivedTokenAuth(hassUrl, hassToken);\n      const connection = await createConnection({ auth });\n      return {\n        type: \"success\",\n        connection,\n        auth,\n      };\n    } catch (e) {\n      const message = handleError(e, hassToken);\n      return {\n        type: \"error\",\n        error: message,\n      };\n    }\n  }\n\n  const options: AuthOptions = {\n    saveTokens,\n    loadTokens: () => Promise.resolve(loadTokens(hassUrl)),\n  };\n\n  if (hassUrl && connectionType === \"user-request\") {\n    options.hassUrl = hassUrl;\n    if (options.hassUrl === \"\") {\n      return {\n        type: \"error\",\n        error: \"Please enter a Home Assistant URL.\",\n      };\n    }\n    if (options.hassUrl.indexOf(\"://\") === -1) {\n      return {\n        type: \"error\",\n        error: \"Please enter your full URL, including the protocol part (https://).\",\n      };\n    }\n    try {\n      new URL(options.hassUrl);\n    } catch (err: unknown) {\n      console.error(\"Error:\", err);\n      return {\n        type: \"error\",\n        error: \"Invalid URL\",\n      };\n    }\n  }\n  let auth: Auth;\n\n  try {\n    auth = await getAuth(options);\n  } catch (err: unknown) {\n    if (\n      (\n        err as {\n          error: string;\n        }\n      )?.error === \"invalid_grant\"\n    ) {\n      // the refresh token is incorrect and most likely from another browser / instance\n      clearTokens();\n      return tryConnection(hassUrl, hassToken);\n    }\n    if (connectionType === \"saved-tokens\" && err === ERR_CANNOT_CONNECT) {\n      return {\n        type: \"failed\",\n        cannotConnect: true,\n      };\n    }\n    return {\n      type: \"error\",\n      error: handleError(err, hassToken),\n    };\n  } finally {\n    // Clear url if we have a auth callback in url.\n    if (location && location.search.includes(\"auth_callback=1\")) {\n      history.replaceState(null, \"\", location.pathname);\n    }\n  }\n  let connection: Connection;\n  try {\n    // create the connection to the websockets\n    connection = await createConnection({ auth });\n  } catch (err) {\n    // In case of saved tokens, silently solve problems.\n    if (connectionType === \"saved-tokens\") {\n      if (err === ERR_CANNOT_CONNECT) {\n        return {\n          type: \"failed\",\n          cannotConnect: true,\n        };\n      } else if (err === ERR_INVALID_AUTH) {\n        saveTokens(null);\n      }\n    }\n    return {\n      type: \"error\",\n      error: handleError(err, hassToken),\n    };\n  }\n  return {\n    type: \"success\",\n    connection,\n    auth,\n  };\n};\n"],"names":["handleError","err","hassToken","message","ERR_INVALID_AUTH","ERR_CANNOT_CONNECT","ERR_CONNECTION_LOST","ERR_HASS_HOST_REQUIRED","ERR_INVALID_HTTPS_TO_HTTP","getInheritedConnection","e","determineConnectionType","hassUrl","isAuthCallback","hasHassConnection","providedToken","savedTokens","loadTokens","tryConnection","connectionType","auth","conn","createLongLivedTokenAuth","createConnection","options","saveTokens","getAuth","clearTokens","connection"],"mappings":"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"}