import { createLongLivedTokenAuth as p, createConnection as l, getAuth as y, ERR_CANNOT_CONNECT as u, ERR_INVALID_AUTH as h, ERR_INVALID_HTTPS_TO_HTTP as f, ERR_HASS_HOST_REQUIRED as T, ERR_CONNECTION_LOST as E } from "home-assistant-js-websocket";
import { saveTokens as d, clearTokens as C, loadTokens as R } from "./token-storage.js";
function i(t, r) {
  const n = (() => {
    switch (t) {
      case h:
        return `ERR_INVALID_AUTH: Invalid authentication. ${r ? 'Check your "Long-Lived Access Token".' : ""}`;
      case u:
        return "ERR_CANNOT_CONNECT: Unable to connect";
      case E:
        return "ERR_CONNECTION_LOST: Lost connection to home assistant.";
      case T:
        return "ERR_HASS_HOST_REQUIRED: Please enter a Home Assistant URL.";
      case f:
        return 'ERR_INVALID_HTTPS_TO_HTTP: Cannot connect to Home Assistant instances over "http://".';
      default:
        return null;
    }
  })();
  return n !== null ? n : t?.error || t?.message || `Unknown Error (${t})`;
}
function _() {
  try {
    return window.top?.hassConnection;
  } catch (t) {
    console.error("Error getting inherited connection", t);
    return;
  }
}
function g(t, r) {
  const o = location && location.search.includes("auth_callback=1"), n = !!_(), c = !!r, a = !!R(t, !1);
  switch (!0) {
    case o:
      return "auth-callback";
    case n:
      return "inherited-auth";
    case c:
      return "provided-token";
    case a:
      return "saved-tokens";
    default:
      return "user-request";
  }
}
const N = async (t, r) => {
  const o = g(t, r);
  if (o === "inherited-auth")
    try {
      const { auth: e, conn: s } = await _();
      return {
        type: "success",
        connection: s,
        auth: e
      };
    } catch (e) {
      return {
        type: "error",
        error: i(e, r)
      };
    }
  if (o === "provided-token" && r)
    try {
      const e = await p(t, r);
      return {
        type: "success",
        connection: await l({ auth: e }),
        auth: e
      };
    } catch (e) {
      return {
        type: "error",
        error: i(e, r)
      };
    }
  const n = {
    saveTokens: d,
    loadTokens: () => Promise.resolve(R(t))
  };
  if (t && o === "user-request") {
    if (n.hassUrl = t, n.hassUrl === "")
      return {
        type: "error",
        error: "Please enter a Home Assistant URL."
      };
    if (n.hassUrl.indexOf("://") === -1)
      return {
        type: "error",
        error: "Please enter your full URL, including the protocol part (https://)."
      };
    try {
      new URL(n.hassUrl);
    } catch (e) {
      return console.error("Error:", e), {
        type: "error",
        error: "Invalid URL"
      };
    }
  }
  let c;
  try {
    c = await y(n);
  } catch (e) {
    return e?.error === "invalid_grant" ? (C(), N(t, r)) : o === "saved-tokens" && e === u ? {
      type: "failed",
      cannotConnect: !0
    } : {
      type: "error",
      error: i(e, r)
    };
  } finally {
    location && location.search.includes("auth_callback=1") && history.replaceState(null, "", location.pathname);
  }
  let a;
  try {
    a = await l({ auth: c });
  } catch (e) {
    if (o === "saved-tokens") {
      if (e === u)
        return {
          type: "failed",
          cannotConnect: !0
        };
      e === h && d(null);
    }
    return {
      type: "error",
      error: i(e, r)
    };
  }
  return {
    type: "success",
    connection: a,
    auth: c
  };
};
export {
  i as handleError,
  N as tryConnection
};
//# sourceMappingURL=tryConnection.js.map
