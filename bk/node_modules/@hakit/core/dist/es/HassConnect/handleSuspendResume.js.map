{"version":3,"file":"handleSuspendResume.js","sources":["../../../src/HassConnect/handleSuspendResume.ts"],"sourcesContent":["import { Connection } from \"home-assistant-js-websocket\";\n\nexport type ConnectionStatus = \"pending\" | \"disconnected\" | \"pending-suspension\" | \"suspended\" | \"connected\";\n\nexport interface HandleSuspendResumeOptions {\n  /** - suspendWhenHidden: if false, never tear down the connection even when the page is hidden. @default true  */\n  suspendWhenHidden?: boolean;\n  /** hiddenDelayMs: how long (in milliseconds) to wait after \"hidden\" before calling connection.suspend(), defaults to 5 minutes (300000 ms). @default 300000 */\n  hiddenDelayMs?: number;\n  /** debug: if true, logs all visibility/freeze/resume steps to the console. @default false */\n  debug?: boolean;\n  /**\n   * Optional callback that will be called whenever the connection status changes.\n   * The argument is one of:\n   *   - \"pending-suspension\": right after suspendReconnectUntil() is called\n   *   - \"suspended\": when the socket is actually suspended via connection.suspend()\n   *   - \"connected\": when the pending suspension is lifted (i.e. reconnection may resume)\n   */\n  onStatusChange?: (status: ConnectionStatus) => void;\n}\n\n/**\n * Attaches listeners to document for:\n *  - visibilitychange (desktop)\n *  - freeze / resume (mobile/Cordova/etc)\n * to “pause” (suspendReconnectUntil + suspend) when the page is hidden/frozen, and “resume” when it becomes visible/resumes.\n *\n * @param connection - connection object from home-assistant-js-websocket\n * @param options - ptional settings (delay, whether to suspend, debug, status callback)\n * @returns a cleanup function that removes all listeners and clears any pending timeouts\n */\nexport function handleSuspendResume(connection: Connection, options: HandleSuspendResumeOptions = {}): () => void {\n  const {\n    suspendWhenHidden = true,\n    hiddenDelayMs = 300_000, // default 5 minutes\n    debug = false,\n    onStatusChange,\n  } = options;\n\n  // If hiddenDelayMs is 0, suspension happens immediately; otherwise wait that many ms.\n  const DELAY_MS = hiddenDelayMs;\n\n  /**\n   * If non-null, we have a pending “resume” promise’s resolve function.\n   * Once invoked, we lift the suspension.\n   */\n  let pendingResolve: (() => void) | null = null;\n\n  /**\n   * ID of the timeout that will eventually call connection.suspend().\n   * Cleared if the user returns early.\n   */\n  let hiddenTimeoutId: number | null = null;\n\n  /**\n   * True if we’ve already called suspendReconnectUntil(...) and not yet resolved it.\n   * Prevents stacking multiple promises.\n   */\n  let isSuspended = false;\n\n  if (connection.connected) {\n    if (debug) console.log(\"[SR] Connection is already active → handleSuspendResume will manage suspension\");\n    onStatusChange?.(\"connected\");\n  } else {\n    if (debug) console.log(\"[SR] Connection is not active\");\n    onStatusChange?.(\"disconnected\");\n  }\n\n  // helper: when the page/tab goes hidden (or “freeze” fires)\n  function onHidden() {\n    if (debug) console.log(\"[SR] onHidden() triggered\");\n\n    // If the user disabled suspension or we’re already suspended, do nothing.\n    if (!suspendWhenHidden) {\n      if (debug) console.log(\"[SR] suspendWhenHidden is false → skipping suspension\");\n      return;\n    }\n    if (isSuspended) {\n      if (debug) console.log(\"[SR] Already suspended → skipping duplicate suspension\");\n      return;\n    }\n\n    isSuspended = true;\n\n    // Create a fresh “resumePromise”\n    const resumePromise = new Promise<void>((resolve) => {\n      pendingResolve = () => {\n        if (debug) console.log(\"[SR] pendingResolve() called → lifting suspension\");\n        isSuspended = false;\n        pendingResolve = null;\n        resolve();\n        onStatusChange?.(\"connected\");\n      };\n    });\n\n    if (debug) console.log(\"[SR] Calling connection.suspendReconnectUntil(...)\");\n    onStatusChange?.(\"pending-suspension\");\n    connection.suspendReconnectUntil(resumePromise);\n\n    // Wait DELAY_MS before actually closing the socket.\n    if (debug) console.log(`[SR] Starting hidden delay of ${DELAY_MS}ms before actual suspend()`);\n    hiddenTimeoutId = window.setTimeout(() => {\n      hiddenTimeoutId = null;\n      // If still hidden, suspend the connection:\n      if (document.hidden) {\n        if (debug) console.log(\"[SR] Hidden timeout elapsed → calling suspend()\");\n        suspend();\n      } else {\n        // User returned before timeout. Resolve immediately.\n        if (pendingResolve) {\n          if (debug) console.log(\"[SR] Hidden timeout elapsed but page is visible → resolving pendingResolve()\");\n          // potentially unreachable, but just in case!\n          pendingResolve();\n        }\n      }\n    }, DELAY_MS);\n\n    // If the user focuses before DELAY_MS is up, resume immediately:\n    window.addEventListener(\"focus\", onVisibleOrResume, { once: true });\n  }\n\n  // helper when page/tab becomes visible or “resume” fires after freeze\n  function onVisibleOrResume() {\n    if (debug) console.log(\"[SR] onVisibleOrResume() fired (page became visible)\");\n\n    // If we still have a pending hiddenTimeout, clear it:\n    if (hiddenTimeoutId !== null) {\n      clearTimeout(hiddenTimeoutId);\n      hiddenTimeoutId = null;\n      if (debug) console.log(\"[SR] Cleared hiddenTimeoutId (user returned before allotted time)\");\n    }\n\n    // If there’s a pending “resume” promise, resolve it:\n    if (pendingResolve) {\n      if (debug) console.log(\"[SR] Resolving pendingResolve() on actual resume\");\n      // resets isSuspended and pendingResolve itself\n      pendingResolve();\n    }\n  }\n\n  // helpers for the event listeners to attach\n  function visibilityChangeHandler() {\n    if (document.hidden) {\n      if (debug) console.log(\"[SR] visibilitychange → HIDDEN\");\n      onHidden();\n    } else {\n      if (debug) console.log(\"[SR] visibilitychange → VISIBLE\");\n      onVisibleOrResume();\n    }\n  }\n\n  function resumeHandler() {\n    if (debug) console.log(\"[SR] resume event fired\");\n    onVisibleOrResume();\n  }\n\n  function suspend() {\n    if (!connection.connected) {\n      if (debug) console.log(\"[SR] Connection already suspended → skipping suspend()\");\n      return;\n    }\n    onStatusChange?.(\"suspended\");\n    if (debug) console.log(\"[SR] suspend() called → suspending connection\");\n    window.stop();\n    connection.suspend();\n  }\n\n  // wire in event handlers\n  document.addEventListener(\"visibilitychange\", visibilityChangeHandler, false);\n  document.addEventListener(\"freeze\", suspend);\n  document.addEventListener(\"resume\", resumeHandler);\n\n  if (debug) console.log(\"[SR] handleSuspendResume() initialized; debugging is ON\");\n\n  // return the cleanup function that removes all listeners and clears timeouts\n  return () => {\n    if (debug) console.log(\"[SR] cleanup() called → removing listeners & clearing timeouts\");\n\n    document.removeEventListener(\"visibilitychange\", visibilityChangeHandler, false);\n    document.removeEventListener(\"freeze\", suspend);\n    document.removeEventListener(\"resume\", resumeHandler);\n    window.removeEventListener(\"focus\", onVisibleOrResume);\n\n    if (hiddenTimeoutId !== null) {\n      if (debug) console.log(\"[SR] cleanup: Clearing hiddenTimeoutId\");\n      clearTimeout(hiddenTimeoutId);\n      hiddenTimeoutId = null;\n    }\n    // If there’s still a pendingResolve (Promise not resolved), resolve it now so reconnection can recover:\n    if (pendingResolve) {\n      if (debug) console.log(\"[SR] cleanup: Resolving pendingResolve() to let reconnection proceed\");\n      pendingResolve();\n      pendingResolve = null;\n      isSuspended = false;\n    }\n  };\n}\n"],"names":["handleSuspendResume","connection","options","suspendWhenHidden","hiddenDelayMs","debug","onStatusChange","DELAY_MS","pendingResolve","hiddenTimeoutId","isSuspended","onHidden","resumePromise","resolve","suspend","onVisibleOrResume","visibilityChangeHandler","resumeHandler"],"mappings":"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"}