{"version":3,"file":"number.js","sources":["../../../src/utils/number.ts"],"sourcesContent":["import { HassEntityAttributeBase, HassEntity } from \"home-assistant-js-websocket\";\nimport { EntityRegistryDisplayEntry } from \"./entity_registry\";\n\n/**\n * Checks if the current entity state should be formatted as an integer based on the `state` and `step` attribute and returns the appropriate `Intl.NumberFormatOptions` object with `maximumFractionDigits` set\n * @param entityState The state object of the entity\n * @returns An `Intl.NumberFormatOptions` object with `maximumFractionDigits` set to 0, or `undefined`\n */\nexport const getNumberFormatOptions = (\n  entityState?: HassEntity,\n  entity?: EntityRegistryDisplayEntry,\n): Intl.NumberFormatOptions | undefined => {\n  const precision = entity?.display_precision;\n  if (precision != null) {\n    return {\n      maximumFractionDigits: precision,\n      minimumFractionDigits: precision,\n    };\n  }\n  if (Number.isInteger(Number(entityState?.attributes?.step)) && Number.isInteger(Number(entityState?.state))) {\n    return { maximumFractionDigits: 0 };\n  }\n  return undefined;\n};\n\n/**\n * Returns true if the entity is considered numeric based on the attributes it has\n * @param stateObj The entity state object\n */\nexport const isNumericState = (stateObj: HassEntity): boolean => isNumericFromAttributes(stateObj.attributes);\n\nexport const isNumericFromAttributes = (attributes: HassEntityAttributeBase, numericDeviceClasses?: string[]): boolean =>\n  !!attributes.unit_of_measurement || !!attributes.state_class || (numericDeviceClasses || []).includes(attributes.device_class || \"\");\n\n/**\n * Generates default options for Intl.NumberFormat\n * @param num The number to be formatted\n * @param options The Intl.NumberFormatOptions that should be included in the returned options\n */\nexport const getDefaultFormatOptions = (num: string | number, options?: Intl.NumberFormatOptions): Intl.NumberFormatOptions => {\n  const defaultOptions: Intl.NumberFormatOptions = {\n    maximumFractionDigits: 2,\n    ...options,\n  };\n\n  if (typeof num !== \"string\") {\n    return defaultOptions;\n  }\n\n  // Keep decimal trailing zeros if they are present in a string numeric value\n  if (!options || (options.minimumFractionDigits === undefined && options.maximumFractionDigits === undefined)) {\n    const digits = num.indexOf(\".\") > -1 ? num.split(\".\")[1].length : 0;\n    defaultOptions.minimumFractionDigits = digits;\n    defaultOptions.maximumFractionDigits = digits;\n  }\n\n  return defaultOptions;\n};\n\nexport const round = (value: number, precision = 2): number => Math.round(value * 10 ** precision) / 10 ** precision;\n\n/**\n * Formats a number based on the user's preference with thousands separator(s) and decimal character for better legibility.\n *\n * @param num The number to format\n * @param localeOptions The user-selected language and formatting, from `hass.locale`\n * @param options Intl.NumberFormatOptions to use\n */\nexport const formatNumber = (num: string | number, options?: Intl.NumberFormatOptions): string => {\n  // Polyfill for Number.isNaN, which is more reliable than the global isNaN()\n  Number.isNaN =\n    Number.isNaN ||\n    function isNaN(input): boolean {\n      return typeof input === \"number\" && isNaN(input);\n    };\n\n  if (!Number.isNaN(Number(num)) && num !== \"\") {\n    // If NumberFormat is none, use en-US format without grouping.\n    return new Intl.NumberFormat(\n      \"en-US\",\n      getDefaultFormatOptions(num, {\n        ...options,\n        useGrouping: false,\n      }),\n    ).format(Number(num));\n  }\n\n  if (typeof num === \"string\") {\n    return num;\n  }\n  return `${round(num, options?.maximumFractionDigits).toString()}${options?.style === \"currency\" ? ` ${options.currency}` : \"\"}`;\n};\n"],"names":["getNumberFormatOptions","entityState","entity","precision","isNumericState","stateObj","isNumericFromAttributes","attributes","numericDeviceClasses","getDefaultFormatOptions","num","options","defaultOptions","digits","round","value","formatNumber","isNaN","input"],"mappings":"AAQO,MAAMA,IAAyB,CACpCC,GACAC,MACyC;AACzC,QAAMC,IAAYD,GAAQ;AAC1B,MAAIC,KAAa;AACf,WAAO;AAAA,MACL,uBAAuBA;AAAA,MACvB,uBAAuBA;AAAA,IAAA;AAG3B,MAAI,OAAO,UAAU,OAAOF,GAAa,YAAY,IAAI,CAAC,KAAK,OAAO,UAAU,OAAOA,GAAa,KAAK,CAAC;AACxG,WAAO,EAAE,uBAAuB,EAAA;AAGpC,GAMaG,IAAiB,CAACC,MAAkCC,EAAwBD,EAAS,UAAU,GAE/FC,IAA0B,CAACC,GAAqCC,MAC3E,CAAC,CAACD,EAAW,uBAAuB,CAAC,CAACA,EAAW,gBAAgBC,KAAwB,CAAA,GAAI,SAASD,EAAW,gBAAgB,EAAE,GAOxHE,IAA0B,CAACC,GAAsBC,MAAiE;AAC7H,QAAMC,IAA2C;AAAA,IAC/C,uBAAuB;AAAA,IACvB,GAAGD;AAAA,EAAA;AAGL,MAAI,OAAOD,KAAQ;AACjB,WAAOE;AAIT,MAAI,CAACD,KAAYA,EAAQ,0BAA0B,UAAaA,EAAQ,0BAA0B,QAAY;AAC5G,UAAME,IAASH,EAAI,QAAQ,GAAG,IAAI,KAAKA,EAAI,MAAM,GAAG,EAAE,CAAC,EAAE,SAAS;AAClE,IAAAE,EAAe,wBAAwBC,GACvCD,EAAe,wBAAwBC;AAAA,EACzC;AAEA,SAAOD;AACT,GAEaE,IAAQ,CAACC,GAAeZ,IAAY,MAAc,KAAK,MAAMY,IAAQ,MAAMZ,CAAS,IAAI,MAAMA,GAS9Fa,IAAe,CAACN,GAAsBC,OAEjD,OAAO,QACL,OAAO,SACP,SAASM,EAAMC,GAAgB;AAC7B,SAAO,OAAOA,KAAU,YAAYD,EAAMC,CAAK;AACjD,GAEE,CAAC,OAAO,MAAM,OAAOR,CAAG,CAAC,KAAKA,MAAQ,KAEjC,IAAI,KAAK;AAAA,EACd;AAAA,EACAD,EAAwBC,GAAK;AAAA,IAC3B,GAAGC;AAAA,IACH,aAAa;AAAA,EAAA,CACd;AAAA,EACD,OAAO,OAAOD,CAAG,CAAC,IAGlB,OAAOA,KAAQ,WACVA,IAEF,GAAGI,EAAMJ,GAAKC,GAAS,qBAAqB,EAAE,UAAU,GAAGA,GAAS,UAAU,aAAa,IAAIA,EAAQ,QAAQ,KAAK,EAAE;"}