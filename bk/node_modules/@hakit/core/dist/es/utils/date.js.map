{"version":3,"file":"date.js","sources":["../../../src/utils/date.ts"],"sourcesContent":["import { HassConfig } from \"home-assistant-js-websocket\";\nimport { FrontendLocaleData, DateFormat } from \"./subscribe/frontend_data\";\n\nconst RESOLVED_TIME_ZONE = Intl.DateTimeFormat?.().resolvedOptions?.().timeZone;\n\n// Browser time zone can be determined from Intl, with fallback to UTC for polyfill or no support.\nexport const LOCAL_TIME_ZONE = RESOLVED_TIME_ZONE ?? \"UTC\";\n\n// Pick time zone based on user profile option.  Core zone is used when local cannot be determined.\nexport const resolveTimeZone = (option: TimeZone, serverTimeZone: string) =>\n  option === TimeZone.local && RESOLVED_TIME_ZONE ? LOCAL_TIME_ZONE : serverTimeZone;\n\nexport enum TimeFormat {\n  language = \"language\",\n  system = \"system\",\n  am_pm = \"12\",\n  twenty_four = \"24\",\n}\n\nexport enum TimeZone {\n  local = \"local\",\n  server = \"server\",\n}\n\nexport const shouldUseAmPm = (locale: FrontendLocaleData): boolean => {\n  if (locale.time_format === TimeFormat.language || locale.time_format === TimeFormat.system) {\n    const testLanguage = locale.time_format === TimeFormat.language ? locale.language : undefined;\n    const test = new Date(\"January 1, 2023 22:00:00\").toLocaleString(testLanguage);\n    return test.includes(\"10\");\n  }\n  return locale.time_format === TimeFormat.am_pm;\n};\n\nconst DAY_IN_MILLISECONDS = 86400000;\nconst HOUR_IN_MILLISECONDS = 3600000;\nconst MINUTE_IN_MILLISECONDS = 60000;\nconst SECOND_IN_MILLISECONDS = 1000;\n\nexport const UNIT_TO_MILLISECOND_CONVERT = {\n  ms: 1,\n  s: SECOND_IN_MILLISECONDS,\n  min: MINUTE_IN_MILLISECONDS,\n  h: HOUR_IN_MILLISECONDS,\n  d: DAY_IN_MILLISECONDS,\n};\n\nexport const formatDuration = (duration: string, units: keyof typeof UNIT_TO_MILLISECOND_CONVERT): string =>\n  millisecondsToDuration(parseFloat(duration) * UNIT_TO_MILLISECOND_CONVERT[units]) || \"0\";\n\nconst leftPad = (num: number, digits = 2) => {\n  let paddedNum = \"\" + num;\n  for (let i = 1; i < digits; i++) {\n    paddedNum = parseInt(paddedNum) < 10 ** i ? `0${paddedNum}` : paddedNum;\n  }\n  return paddedNum;\n};\n\nexport function millisecondsToDuration(d: number) {\n  const h = Math.floor(d / 1000 / 3600);\n  const m = Math.floor(((d / 1000) % 3600) / 60);\n  const s = Math.floor(((d / 1000) % 3600) % 60);\n  const ms = Math.floor(d % 1000);\n\n  if (h > 0) {\n    return `${h}:${leftPad(m)}:${leftPad(s)}`;\n  }\n  if (m > 0) {\n    return `${m}:${leftPad(s)}`;\n  }\n  if (s > 0 || ms > 0) {\n    return `${s}${ms > 0 ? `.${leftPad(ms, 3)}` : ``}`;\n  }\n  return null;\n}\n\n// https://stackoverflow.com/a/14322189/1947205\n// Changes:\n// 1. Do not allow a plus or minus at the start.\n// 2. Enforce that we have a \"T\" or a blank after the date portion\n//    to ensure we have a timestamp and not only a date.\n// 3. Disallow dates based on week number.\n// 4. Disallow dates only consisting of a year.\n// https://regex101.com/r/kc5C14/3\nconst regexp =\n  /^\\d{4}-(0[1-9]|1[0-2])-([12]\\d|0[1-9]|3[01])[T| ](((([01]\\d|2[0-3])((:?)[0-5]\\d)?|24:?00)([.,]\\d+(?!:))?)(\\8[0-5]\\d([.,]\\d+)?)?([zZ]|([+-])([01]\\d|2[0-3]):?([0-5]\\d)?)?)$/;\n\nexport const isTimestamp = (input: string): boolean => regexp.test(input);\n\n// https://regex101.com/r/kc5C14/2\nconst regExpString = \"^\\\\d{4}-(0[1-9]|1[0-2])-([12]\\\\d|0[1-9]|3[01])\";\n\nconst regExp = new RegExp(regExpString + \"$\");\n// 2nd expression without the \"end of string\" enforced, so it can be used\n// to just verify the start of a string and then based on that result e.g.\n// check for a full timestamp string efficiently.\nconst regExpNoStringEnd = new RegExp(regExpString);\n\nexport const isDate = (input: string, allowCharsAfterDate = false): boolean =>\n  allowCharsAfterDate ? regExpNoStringEnd.test(input) : regExp.test(input);\n\nexport function checkValidDate(date?: Date): boolean {\n  if (!date) {\n    return false;\n  }\n\n  return date instanceof Date && !isNaN(date.valueOf());\n}\n\n// Single-entry memo factory: caches only the last invocation per formatter.\n// This keeps memory footprint minimal while still avoiding repeated construction\n// during render cycles with stable locale/timezone preferences.\nfunction singleEntryMemo<Args extends unknown[], R>(factory: (...a: Args) => R) {\n  let lastArgs: Args | null = null;\n  let lastResult: R | null = null;\n  return (...args: Args): R => {\n    if (lastArgs && lastArgs.length === args.length && lastArgs.every((v, i) => v === args[i])) {\n      return lastResult as R;\n    }\n    lastArgs = args;\n    lastResult = factory(...args);\n    return lastResult as R;\n  };\n}\n\nconst dateFormatterMem = singleEntryMemo(\n  (locale: FrontendLocaleData, serverTZ: string) =>\n    new Intl.DateTimeFormat(locale.language, {\n      year: \"numeric\",\n      month: \"long\",\n      day: \"numeric\",\n      timeZone: resolveTimeZone(locale.time_zone, serverTZ),\n    }),\n);\n\nconst timeFormatterMem = singleEntryMemo(\n  (locale: FrontendLocaleData, serverTZ: string) =>\n    new Intl.DateTimeFormat(locale.language, {\n      hour: shouldUseAmPm(locale) ? \"numeric\" : \"2-digit\",\n      minute: \"2-digit\",\n      hourCycle: shouldUseAmPm(locale) ? \"h12\" : \"h23\",\n      timeZone: resolveTimeZone(locale.time_zone, serverTZ),\n    }),\n);\n\n// 24h time (HH:MM) without any day period suffix, always forcing hourCycle h23 but still honoring\n// the user's chosen timezone preference (locale.time_zone vs server time zone). Language is passed\n// purely for consistency but does not materially affect numeric output.\nconst timeWithoutAmPmFormatterMem = singleEntryMemo(\n  (locale: FrontendLocaleData, serverTZ: string) =>\n    new Intl.DateTimeFormat(locale.language, {\n      hour: \"2-digit\",\n      minute: \"2-digit\",\n      hourCycle: \"h23\",\n      timeZone: resolveTimeZone(locale.time_zone, serverTZ),\n    }),\n);\n\n// Hour-only formatter respecting 12/24 preference. For 12h locales returns values like \"5 PM\",\n// for 24h preference returns zero-padded \"17\" (no suffix). Minute component intentionally omitted.\nconst hourOnlyFormatterMem = singleEntryMemo(\n  (locale: FrontendLocaleData, serverTZ: string) =>\n    new Intl.DateTimeFormat(locale.language, {\n      hour: shouldUseAmPm(locale) ? \"numeric\" : \"2-digit\",\n      hourCycle: shouldUseAmPm(locale) ? \"h12\" : \"h23\",\n      timeZone: resolveTimeZone(locale.time_zone, serverTZ),\n    }),\n);\n\n// Minute-only formatter (always 2-digit) respecting timezone\nconst minuteOnlyFormatterMem = singleEntryMemo(\n  (locale: FrontendLocaleData, serverTZ: string) =>\n    new Intl.DateTimeFormat(locale.language, {\n      minute: \"2-digit\",\n      timeZone: resolveTimeZone(locale.time_zone, serverTZ),\n    }),\n);\n\n// Second-only formatter (always 2-digit) respecting timezone\nconst secondOnlyFormatterMem = singleEntryMemo(\n  (locale: FrontendLocaleData, serverTZ: string) =>\n    new Intl.DateTimeFormat(locale.language, {\n      second: \"2-digit\",\n      timeZone: resolveTimeZone(locale.time_zone, serverTZ),\n    }),\n);\n\nconst dateTimeFormatterMem = singleEntryMemo(\n  (locale: FrontendLocaleData, serverTZ: string) =>\n    new Intl.DateTimeFormat(locale.language, {\n      year: \"numeric\",\n      month: \"long\",\n      day: \"numeric\",\n      hour: shouldUseAmPm(locale) ? \"numeric\" : \"2-digit\",\n      minute: \"2-digit\",\n      hourCycle: shouldUseAmPm(locale) ? \"h12\" : \"h23\",\n      timeZone: resolveTimeZone(locale.time_zone, serverTZ),\n    }),\n);\n\nconst dateTimeWithSecondsFormatterMem = singleEntryMemo(\n  (locale: FrontendLocaleData, serverTZ: string) =>\n    new Intl.DateTimeFormat(locale.language, {\n      year: \"numeric\",\n      month: \"long\",\n      day: \"numeric\",\n      hour: shouldUseAmPm(locale) ? \"numeric\" : \"2-digit\",\n      minute: \"2-digit\",\n      second: \"2-digit\",\n      hourCycle: shouldUseAmPm(locale) ? \"h12\" : \"h23\",\n      timeZone: resolveTimeZone(locale.time_zone, serverTZ),\n    }),\n);\n\nconst shortDateTimeWithYearMem = singleEntryMemo(\n  (locale: FrontendLocaleData, serverTZ: string) =>\n    new Intl.DateTimeFormat(locale.language, {\n      year: \"numeric\",\n      month: \"short\",\n      day: \"numeric\",\n      hour: shouldUseAmPm(locale) ? \"numeric\" : \"2-digit\",\n      minute: \"2-digit\",\n      hourCycle: shouldUseAmPm(locale) ? \"h12\" : \"h23\",\n      timeZone: resolveTimeZone(locale.time_zone, serverTZ),\n    }),\n);\n\nconst shortDateTimeMem = singleEntryMemo(\n  (locale: FrontendLocaleData, serverTZ: string) =>\n    new Intl.DateTimeFormat(locale.language, {\n      month: \"short\",\n      day: \"numeric\",\n      hour: shouldUseAmPm(locale) ? \"numeric\" : \"2-digit\",\n      minute: \"2-digit\",\n      hourCycle: shouldUseAmPm(locale) ? \"h12\" : \"h23\",\n      timeZone: resolveTimeZone(locale.time_zone, serverTZ),\n    }),\n);\n\nconst browserDefaultsFormatterMem = singleEntryMemo(\n  () =>\n    new Intl.DateTimeFormat(undefined, {\n      year: \"numeric\",\n      month: \"long\",\n      day: \"numeric\",\n      hour: \"2-digit\",\n      minute: \"2-digit\",\n    }),\n);\n\n// --- Additional granular date formatters for HA parity ---\n\nconst dateWeekdayDayMem = singleEntryMemo(\n  (locale: FrontendLocaleData, serverTZ: string) =>\n    new Intl.DateTimeFormat(locale.language, {\n      weekday: \"long\",\n      month: \"long\",\n      day: \"numeric\",\n      timeZone: resolveTimeZone(locale.time_zone, serverTZ),\n    }),\n);\n\nconst dateShortMem = singleEntryMemo(\n  (locale: FrontendLocaleData, serverTZ: string) =>\n    new Intl.DateTimeFormat(locale.language, {\n      year: \"numeric\",\n      month: \"short\",\n      day: \"numeric\",\n      timeZone: resolveTimeZone(locale.time_zone, serverTZ),\n    }),\n);\n\nconst dateVeryShortMem = singleEntryMemo(\n  (locale: FrontendLocaleData, serverTZ: string) =>\n    new Intl.DateTimeFormat(locale.language, {\n      day: \"numeric\",\n      month: \"short\",\n      timeZone: resolveTimeZone(locale.time_zone, serverTZ),\n    }),\n);\n\nconst dateMonthYearMem = singleEntryMemo(\n  (locale: FrontendLocaleData, serverTZ: string) =>\n    new Intl.DateTimeFormat(locale.language, {\n      month: \"long\",\n      year: \"numeric\",\n      timeZone: resolveTimeZone(locale.time_zone, serverTZ),\n    }),\n);\n\nconst dateMonthMem = singleEntryMemo(\n  (locale: FrontendLocaleData, serverTZ: string) =>\n    new Intl.DateTimeFormat(locale.language, {\n      month: \"long\",\n      timeZone: resolveTimeZone(locale.time_zone, serverTZ),\n    }),\n);\n\nconst dateYearMem = singleEntryMemo(\n  (locale: FrontendLocaleData, serverTZ: string) =>\n    new Intl.DateTimeFormat(locale.language, {\n      year: \"numeric\",\n      timeZone: resolveTimeZone(locale.time_zone, serverTZ),\n    }),\n);\n\nconst dateWeekdayMem = singleEntryMemo(\n  (locale: FrontendLocaleData, serverTZ: string) =>\n    new Intl.DateTimeFormat(locale.language, {\n      weekday: \"long\",\n      timeZone: resolveTimeZone(locale.time_zone, serverTZ),\n    }),\n);\n\nconst dateWeekdayShortMem = singleEntryMemo(\n  (locale: FrontendLocaleData, serverTZ: string) =>\n    new Intl.DateTimeFormat(locale.language, {\n      weekday: \"short\",\n      timeZone: resolveTimeZone(locale.time_zone, serverTZ),\n    }),\n);\n\n// Numeric date with user preference ordering (DMY/MDY/YMD) when locale.date_format overrides language/system.\nconst dateNumericBaseMem = singleEntryMemo((locale: FrontendLocaleData, serverTZ: string) => {\n  const localeString = locale.date_format === DateFormat.system ? undefined : locale.language;\n  return new Intl.DateTimeFormat(localeString, {\n    year: \"numeric\",\n    month: \"numeric\",\n    day: \"numeric\",\n    timeZone: resolveTimeZone(locale.time_zone, serverTZ),\n  });\n});\n\n/** Format a date (long month) e.g. \"August 9, 2021\" */\nexport const formatDate = (dateObj: Date, config: HassConfig, locale: FrontendLocaleData) =>\n  dateFormatterMem(locale, config.time_zone).format(dateObj);\n\n/** Format a time respecting 12/24 preference e.g. \"8:23 AM\" or \"08:23\" */\nexport const formatTime = (dateObj: Date, config: HassConfig, locale: FrontendLocaleData) =>\n  timeFormatterMem(locale, config.time_zone).format(dateObj);\n\n/** Format a time forcing 24h cycle (HH:MM) without an AM/PM suffix, ignoring user 12h preference but honoring timezone preference. */\nexport const formatTimeWithoutAmPm = (dateObj: Date, config: HassConfig, locale: FrontendLocaleData) =>\n  timeWithoutAmPmFormatterMem(locale, config.time_zone).format(dateObj);\n\n/** Hour numeric only respecting 12/24 preference (no suffix). e.g. \"5\" or \"17\" */\nexport const formatHour = (dateObj: Date, config: HassConfig, locale: FrontendLocaleData) => {\n  const parts = hourOnlyFormatterMem(locale, config.time_zone).formatToParts(dateObj);\n  return parts.find((p) => p.type === \"hour\")?.value || \"\";\n};\n\n/** Minute numeric only (zero-padded, e.g. \"07\") */\nexport const formatMinute = (dateObj: Date, config: HassConfig, locale: FrontendLocaleData) => {\n  const parts = minuteOnlyFormatterMem(locale, config.time_zone).formatToParts(dateObj);\n  return parts.find((p) => p.type === \"minute\")?.value || \"\";\n};\n\n/** Seconds numeric only (zero-padded, e.g. \"09\") */\nexport const formatSeconds = (dateObj: Date, config: HassConfig, locale: FrontendLocaleData) => {\n  const parts = secondOnlyFormatterMem(locale, config.time_zone).formatToParts(dateObj);\n  return parts.find((p) => p.type === \"second\")?.value || \"\";\n};\n\n/** Long date & time without seconds e.g. \"August 9, 2021, 8:23 AM\" */\nexport const formatDateTime = (dateObj: Date, config: HassConfig, locale: FrontendLocaleData) =>\n  dateTimeFormatterMem(locale, config.time_zone).format(dateObj);\n\n// August 9, 2021, 8:23:15 AM\n/** Long date & time with seconds e.g. \"August 9, 2021, 8:23:15 AM\" */\nexport const formatDateTimeWithSeconds = (dateObj: Date, locale: FrontendLocaleData, config: HassConfig) =>\n  dateTimeWithSecondsFormatterMem(locale, config.time_zone).format(dateObj);\n\n/** Short date/time without year if same year e.g. \"Aug 9, 8:23 AM\" */\nexport const formatShortDateTime = (dateObj: Date, locale: FrontendLocaleData, config: HassConfig) =>\n  shortDateTimeMem(locale, config.time_zone).format(dateObj);\n\n/** Short date/time with year e.g. \"Aug 9, 2021, 8:23 AM\" */\nexport const formatShortDateTimeWithYear = (dateObj: Date, locale: FrontendLocaleData, config: HassConfig) =>\n  shortDateTimeWithYearMem(locale, config.time_zone).format(dateObj);\n\n/** Conditionally include year (current year omitted) */\nexport const formatShortDateTimeWithConditionalYear = (dateObj: Date, locale: FrontendLocaleData, config: HassConfig) => {\n  const now = new Date();\n  return now.getFullYear() === dateObj.getFullYear()\n    ? formatShortDateTime(dateObj, locale, config)\n    : formatShortDateTimeWithYear(dateObj, locale, config);\n};\n\n/** Browser default locale (useful for fallback) */\nexport const formatDateTimeWithBrowserDefaults = (dateObj: Date) => browserDefaultsFormatterMem().format(dateObj);\n\n/** Numeric date/time variant (delegates to existing helpers if present) */\nexport const formatDateTimeNumeric = (dateObj: Date, locale: FrontendLocaleData, config: HassConfig) => {\n  // Provide a simple numeric format similar to HA's `formatDateTimeNumeric`.\n  // We intentionally do not memoize this combined string (two memoized parts already).\n  const datePart = new Intl.DateTimeFormat(locale.language, {\n    year: \"numeric\",\n    month: \"numeric\",\n    day: \"numeric\",\n    timeZone: resolveTimeZone(locale.time_zone, config.time_zone),\n  }).format(dateObj);\n  return `${datePart}, ${formatTime(dateObj, config, locale)}`;\n};\n\n/** Weekday + Month + Day (e.g. \"Tuesday, August 10\") */\nexport const formatDateWeekdayDay = (dateObj: Date, locale: FrontendLocaleData, config: HassConfig) =>\n  dateWeekdayDayMem(locale, config.time_zone).format(dateObj);\n\n/** Short date (e.g. \"Aug 10, 2021\") */\nexport const formatDateShort = (dateObj: Date, locale: FrontendLocaleData, config: HassConfig) =>\n  dateShortMem(locale, config.time_zone).format(dateObj);\n\n/** Very short date (e.g. \"Aug 10\") */\nexport const formatDateVeryShort = (dateObj: Date, locale: FrontendLocaleData, config: HassConfig) =>\n  dateVeryShortMem(locale, config.time_zone).format(dateObj);\n\n/** Month + Year (e.g. \"August 2021\") */\nexport const formatDateMonthYear = (dateObj: Date, locale: FrontendLocaleData, config: HassConfig) =>\n  dateMonthYearMem(locale, config.time_zone).format(dateObj);\n\n/** Month name (e.g. \"August\") */\nexport const formatDateMonth = (dateObj: Date, locale: FrontendLocaleData, config: HassConfig) =>\n  dateMonthMem(locale, config.time_zone).format(dateObj);\n\n/** Year (e.g. \"2021\") */\nexport const formatDateYear = (dateObj: Date, locale: FrontendLocaleData, config: HassConfig) =>\n  dateYearMem(locale, config.time_zone).format(dateObj);\n\n/** Weekday long (e.g. \"Monday\") */\nexport const formatDateWeekday = (dateObj: Date, locale: FrontendLocaleData, config: HassConfig) =>\n  dateWeekdayMem(locale, config.time_zone).format(dateObj);\n\n/** Weekday short (e.g. \"Mon\") */\nexport const formatDateWeekdayShort = (dateObj: Date, locale: FrontendLocaleData, config: HassConfig) =>\n  dateWeekdayShortMem(locale, config.time_zone).format(dateObj);\n\n/** Numeric date honoring user ordering preference (e.g. DMY -> 10/08/2021) */\nexport const formatDateNumeric = (dateObj: Date, locale: FrontendLocaleData, config: HassConfig) => {\n  const formatter = dateNumericBaseMem(locale, config.time_zone);\n  if (locale.date_format === DateFormat.language || locale.date_format === DateFormat.system) {\n    return formatter.format(dateObj);\n  }\n  const parts = formatter.formatToParts(dateObj);\n  const literal = parts.find((p) => p.type === \"literal\")?.value || \"/\";\n  const day = parts.find((p) => p.type === \"day\")?.value || \"\";\n  const month = parts.find((p) => p.type === \"month\")?.value || \"\";\n  const year = parts.find((p) => p.type === \"year\")?.value || \"\";\n  const lastPart = parts[parts.length - 1];\n  let lastLiteral = lastPart?.type === \"literal\" ? lastPart.value : \"\";\n  if (locale.language === \"bg\" && locale.date_format === DateFormat.YMD) {\n    lastLiteral = \"\";\n  }\n  const byFormat: Record<DateFormat, string> = {\n    [DateFormat.DMY]: `${day}${literal}${month}${literal}${year}${lastLiteral}`,\n    [DateFormat.MDY]: `${month}${literal}${day}${literal}${year}${lastLiteral}`,\n    [DateFormat.YMD]: `${year}${literal}${month}${literal}${day}${lastLiteral}`,\n    [DateFormat.language]: formatter.format(dateObj),\n    [DateFormat.system]: formatter.format(dateObj),\n  };\n  return byFormat[locale.date_format];\n};\n\n/**\n * Return a localized day period (AM/PM or locale equivalent) for the given date.\n * This intentionally ignores the user's 24h preference so callers can always access the suffix if desired.\n * Only timezone and language are considered (not time_format). Falls back to simple \"AM\"/\"PM\" on failure.\n */\nexport const formatAmPmSuffix = (dateObj: Date, locale: FrontendLocaleData, config: HassConfig): string => {\n  try {\n    const formatter = new Intl.DateTimeFormat(locale.language, {\n      hour: \"numeric\",\n      hour12: true,\n      timeZone: resolveTimeZone(locale.time_zone, config.time_zone),\n    });\n    const parts = formatter.formatToParts(dateObj);\n    const period = parts.find((p) => p.type === \"dayPeriod\")?.value;\n    return period || (dateObj.getHours() >= 12 ? \"PM\" : \"AM\");\n  } catch {\n    return dateObj.getHours() >= 12 ? \"PM\" : \"AM\";\n  }\n};\n"],"names":["RESOLVED_TIME_ZONE","LOCAL_TIME_ZONE","resolveTimeZone","option","serverTimeZone","TimeFormat","TimeZone","shouldUseAmPm","locale","testLanguage","DAY_IN_MILLISECONDS","HOUR_IN_MILLISECONDS","MINUTE_IN_MILLISECONDS","SECOND_IN_MILLISECONDS","UNIT_TO_MILLISECOND_CONVERT","formatDuration","duration","units","millisecondsToDuration","leftPad","num","digits","paddedNum","i","d","h","m","s","ms","regexp","isTimestamp","input","regExpString","regExp","regExpNoStringEnd","isDate","allowCharsAfterDate","checkValidDate","date","singleEntryMemo","factory","lastArgs","lastResult","args","v","dateFormatterMem","serverTZ","timeFormatterMem","timeWithoutAmPmFormatterMem","hourOnlyFormatterMem","minuteOnlyFormatterMem","secondOnlyFormatterMem","dateTimeFormatterMem","dateTimeWithSecondsFormatterMem","shortDateTimeWithYearMem","shortDateTimeMem","browserDefaultsFormatterMem","dateWeekdayDayMem","dateShortMem","dateVeryShortMem","dateMonthYearMem","dateMonthMem","dateYearMem","dateWeekdayMem","dateWeekdayShortMem","dateNumericBaseMem","localeString","DateFormat","formatDate","dateObj","config","formatTime","formatTimeWithoutAmPm","formatHour","p","formatMinute","formatSeconds","formatDateTime","formatDateTimeWithSeconds","formatShortDateTime","formatShortDateTimeWithYear","formatShortDateTimeWithConditionalYear","formatDateTimeWithBrowserDefaults","formatDateTimeNumeric","formatDateWeekdayDay","formatDateShort","formatDateVeryShort","formatDateMonthYear","formatDateMonth","formatDateYear","formatDateWeekday","formatDateWeekdayShort","formatDateNumeric","formatter","parts","literal","day","month","year","lastPart","lastLiteral","formatAmPmSuffix"],"mappings":"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"}