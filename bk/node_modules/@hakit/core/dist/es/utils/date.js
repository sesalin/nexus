import { DateFormat as u } from "./subscribe/frontend_data.js";
const D = Intl.DateTimeFormat?.().resolvedOptions?.().timeZone, T = D ?? "UTC", r = (t, e) => t === "local" && D ? T : e;
var M = /* @__PURE__ */ ((t) => (t.language = "language", t.system = "system", t.am_pm = "12", t.twenty_four = "24", t))(M || {}), z = /* @__PURE__ */ ((t) => (t.local = "local", t.server = "server", t))(z || {});
const i = (t) => {
  if (t.time_format === "language" || t.time_format === "system") {
    const e = t.time_format === "language" ? t.language : void 0;
    return (/* @__PURE__ */ new Date("January 1, 2023 22:00:00")).toLocaleString(e).includes("10");
  }
  return t.time_format === "12";
}, I = 864e5, F = 36e5, w = 6e4, p = 1e3, $ = {
  ms: 1,
  s: p,
  min: w,
  h: F,
  d: I
}, nt = (t, e) => S(parseFloat(t) * $[e]) || "0", d = (t, e = 2) => {
  let n = "" + t;
  for (let o = 1; o < e; o++)
    n = parseInt(n) < 10 ** o ? `0${n}` : n;
  return n;
};
function S(t) {
  const e = Math.floor(t / 1e3 / 3600), n = Math.floor(t / 1e3 % 3600 / 60), o = Math.floor(t / 1e3 % 3600 % 60), a = Math.floor(t % 1e3);
  return e > 0 ? `${e}:${d(n)}:${d(o)}` : n > 0 ? `${n}:${d(o)}` : o > 0 || a > 0 ? `${o}${a > 0 ? `.${d(a, 3)}` : ""}` : null;
}
const Z = /^\d{4}-(0[1-9]|1[0-2])-([12]\d|0[1-9]|3[01])[T| ](((([01]\d|2[0-3])((:?)[0-5]\d)?|24:?00)([.,]\d+(?!:))?)(\8[0-5]\d([.,]\d+)?)?([zZ]|([+-])([01]\d|2[0-3]):?([0-5]\d)?)?)$/, ot = (t) => Z.test(t), l = "^\\d{4}-(0[1-9]|1[0-2])-([12]\\d|0[1-9]|3[01])", N = new RegExp(l + "$"), E = new RegExp(l), rt = (t, e = !1) => e ? E.test(t) : N.test(t);
function mt(t) {
  return t ? t instanceof Date && !isNaN(t.valueOf()) : !1;
}
function m(t) {
  let e = null, n = null;
  return (...o) => (e && e.length === o.length && e.every((a, s) => a === o[s]) || (e = o, n = t(...o)), n);
}
const v = m(
  (t, e) => new Intl.DateTimeFormat(t.language, {
    year: "numeric",
    month: "long",
    day: "numeric",
    timeZone: r(t.time_zone, e)
  })
), C = m(
  (t, e) => new Intl.DateTimeFormat(t.language, {
    hour: i(t) ? "numeric" : "2-digit",
    minute: "2-digit",
    hourCycle: i(t) ? "h12" : "h23",
    timeZone: r(t.time_zone, e)
  })
), L = m(
  (t, e) => new Intl.DateTimeFormat(t.language, {
    hour: "2-digit",
    minute: "2-digit",
    hourCycle: "h23",
    timeZone: r(t.time_zone, e)
  })
), P = m(
  (t, e) => new Intl.DateTimeFormat(t.language, {
    hour: i(t) ? "numeric" : "2-digit",
    hourCycle: i(t) ? "h12" : "h23",
    timeZone: r(t.time_zone, e)
  })
), W = m(
  (t, e) => new Intl.DateTimeFormat(t.language, {
    minute: "2-digit",
    timeZone: r(t.time_zone, e)
  })
), Y = m(
  (t, e) => new Intl.DateTimeFormat(t.language, {
    second: "2-digit",
    timeZone: r(t.time_zone, e)
  })
), k = m(
  (t, e) => new Intl.DateTimeFormat(t.language, {
    year: "numeric",
    month: "long",
    day: "numeric",
    hour: i(t) ? "numeric" : "2-digit",
    minute: "2-digit",
    hourCycle: i(t) ? "h12" : "h23",
    timeZone: r(t.time_zone, e)
  })
), O = m(
  (t, e) => new Intl.DateTimeFormat(t.language, {
    year: "numeric",
    month: "long",
    day: "numeric",
    hour: i(t) ? "numeric" : "2-digit",
    minute: "2-digit",
    second: "2-digit",
    hourCycle: i(t) ? "h12" : "h23",
    timeZone: r(t.time_zone, e)
  })
), A = m(
  (t, e) => new Intl.DateTimeFormat(t.language, {
    year: "numeric",
    month: "short",
    day: "numeric",
    hour: i(t) ? "numeric" : "2-digit",
    minute: "2-digit",
    hourCycle: i(t) ? "h12" : "h23",
    timeZone: r(t.time_zone, e)
  })
), x = m(
  (t, e) => new Intl.DateTimeFormat(t.language, {
    month: "short",
    day: "numeric",
    hour: i(t) ? "numeric" : "2-digit",
    minute: "2-digit",
    hourCycle: i(t) ? "h12" : "h23",
    timeZone: r(t.time_zone, e)
  })
), R = m(
  () => new Intl.DateTimeFormat(void 0, {
    year: "numeric",
    month: "long",
    day: "numeric",
    hour: "2-digit",
    minute: "2-digit"
  })
), U = m(
  (t, e) => new Intl.DateTimeFormat(t.language, {
    weekday: "long",
    month: "long",
    day: "numeric",
    timeZone: r(t.time_zone, e)
  })
), V = m(
  (t, e) => new Intl.DateTimeFormat(t.language, {
    year: "numeric",
    month: "short",
    day: "numeric",
    timeZone: r(t.time_zone, e)
  })
), H = m(
  (t, e) => new Intl.DateTimeFormat(t.language, {
    day: "numeric",
    month: "short",
    timeZone: r(t.time_zone, e)
  })
), B = m(
  (t, e) => new Intl.DateTimeFormat(t.language, {
    month: "long",
    year: "numeric",
    timeZone: r(t.time_zone, e)
  })
), J = m(
  (t, e) => new Intl.DateTimeFormat(t.language, {
    month: "long",
    timeZone: r(t.time_zone, e)
  })
), q = m(
  (t, e) => new Intl.DateTimeFormat(t.language, {
    year: "numeric",
    timeZone: r(t.time_zone, e)
  })
), G = m(
  (t, e) => new Intl.DateTimeFormat(t.language, {
    weekday: "long",
    timeZone: r(t.time_zone, e)
  })
), K = m(
  (t, e) => new Intl.DateTimeFormat(t.language, {
    weekday: "short",
    timeZone: r(t.time_zone, e)
  })
), Q = m((t, e) => {
  const n = t.date_format === u.system ? void 0 : t.language;
  return new Intl.DateTimeFormat(n, {
    year: "numeric",
    month: "numeric",
    day: "numeric",
    timeZone: r(t.time_zone, e)
  });
}), at = (t, e, n) => v(n, e.time_zone).format(t), X = (t, e, n) => C(n, e.time_zone).format(t), it = (t, e, n) => L(n, e.time_zone).format(t), st = (t, e, n) => P(n, e.time_zone).formatToParts(t).find((a) => a.type === "hour")?.value || "", ut = (t, e, n) => W(n, e.time_zone).formatToParts(t).find((a) => a.type === "minute")?.value || "", gt = (t, e, n) => Y(n, e.time_zone).formatToParts(t).find((a) => a.type === "second")?.value || "", ct = (t, e, n) => k(n, e.time_zone).format(t), ft = (t, e, n) => O(e, n.time_zone).format(t), b = (t, e, n) => x(e, n.time_zone).format(t), j = (t, e, n) => A(e, n.time_zone).format(t), dt = (t, e, n) => (/* @__PURE__ */ new Date()).getFullYear() === t.getFullYear() ? b(t, e, n) : j(t, e, n), ht = (t) => R().format(t), yt = (t, e, n) => `${new Intl.DateTimeFormat(e.language, {
  year: "numeric",
  month: "numeric",
  day: "numeric",
  timeZone: r(e.time_zone, n.time_zone)
}).format(t)}, ${X(t, n, e)}`, _t = (t, e, n) => U(e, n.time_zone).format(t), Dt = (t, e, n) => V(e, n.time_zone).format(t), lt = (t, e, n) => H(e, n.time_zone).format(t), Tt = (t, e, n) => B(e, n.time_zone).format(t), Mt = (t, e, n) => J(e, n.time_zone).format(t), zt = (t, e, n) => q(e, n.time_zone).format(t), It = (t, e, n) => G(e, n.time_zone).format(t), Ft = (t, e, n) => K(e, n.time_zone).format(t), wt = (t, e, n) => {
  const o = Q(e, n.time_zone);
  if (e.date_format === u.language || e.date_format === u.system)
    return o.format(t);
  const a = o.formatToParts(t), s = a.find((g) => g.type === "literal")?.value || "/", c = a.find((g) => g.type === "day")?.value || "", h = a.find((g) => g.type === "month")?.value || "", y = a.find((g) => g.type === "year")?.value || "", _ = a[a.length - 1];
  let f = _?.type === "literal" ? _.value : "";
  return e.language === "bg" && e.date_format === u.YMD && (f = ""), {
    [u.DMY]: `${c}${s}${h}${s}${y}${f}`,
    [u.MDY]: `${h}${s}${c}${s}${y}${f}`,
    [u.YMD]: `${y}${s}${h}${s}${c}${f}`,
    [u.language]: o.format(t),
    [u.system]: o.format(t)
  }[e.date_format];
}, pt = (t, e, n) => {
  try {
    return new Intl.DateTimeFormat(e.language, {
      hour: "numeric",
      hour12: !0,
      timeZone: r(e.time_zone, n.time_zone)
    }).formatToParts(t).find((c) => c.type === "dayPeriod")?.value || (t.getHours() >= 12 ? "PM" : "AM");
  } catch {
    return t.getHours() >= 12 ? "PM" : "AM";
  }
};
export {
  T as LOCAL_TIME_ZONE,
  M as TimeFormat,
  z as TimeZone,
  $ as UNIT_TO_MILLISECOND_CONVERT,
  mt as checkValidDate,
  pt as formatAmPmSuffix,
  at as formatDate,
  Mt as formatDateMonth,
  Tt as formatDateMonthYear,
  wt as formatDateNumeric,
  Dt as formatDateShort,
  ct as formatDateTime,
  yt as formatDateTimeNumeric,
  ht as formatDateTimeWithBrowserDefaults,
  ft as formatDateTimeWithSeconds,
  lt as formatDateVeryShort,
  It as formatDateWeekday,
  _t as formatDateWeekdayDay,
  Ft as formatDateWeekdayShort,
  zt as formatDateYear,
  nt as formatDuration,
  st as formatHour,
  ut as formatMinute,
  gt as formatSeconds,
  b as formatShortDateTime,
  dt as formatShortDateTimeWithConditionalYear,
  j as formatShortDateTimeWithYear,
  X as formatTime,
  it as formatTimeWithoutAmPm,
  rt as isDate,
  ot as isTimestamp,
  S as millisecondsToDuration,
  r as resolveTimeZone,
  i as shouldUseAmPm
};
//# sourceMappingURL=date.js.map
