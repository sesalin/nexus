{"version":3,"file":"user.js","sources":["../../../../src/utils/subscribe/user.ts"],"sourcesContent":["export interface MFAModule {\n  id: string;\n  name: string;\n  enabled: boolean;\n}\n\nexport interface CurrentUser {\n  id: string;\n  is_owner: boolean;\n  is_admin: boolean;\n  name: string;\n  credentials: Credential[];\n  mfa_modules: MFAModule[];\n}\n\nimport type { Connection } from \"home-assistant-js-websocket\";\nimport { getCollection, getUser } from \"home-assistant-js-websocket\";\n\n// -----------------------------\n// Users list subscription (one-shot fetch)\n// -----------------------------\n// Home Assistant currently exposes a one-time fetch for the full users list via\n// the websocket command `config/auth/list`. There is no push event for user list\n// changes, so we implement a simple helper that fetches once and invokes the\n// callback. The returned function is a no-op unsubscribe for symmetry with other\n// subscribe* utilities.\n\nexport interface AuthUser {\n  id: string;\n  name: string;\n  is_active: boolean;\n  is_owner: boolean;\n  credentials: { type: string }[];\n  group_ids: string[];\n  system_generated?: boolean;\n  username?: string;\n}\n\nexport interface FetchUsersArgs {\n  includeSystemGenerated?: boolean; // default false\n  includeInactiveUsers?: boolean; // default false\n}\n\n/** Fetch all users then apply optional filtering. */\nconst fetchUsers = async (\n  conn: Connection,\n  { includeSystemGenerated = false, includeInactiveUsers = false }: FetchUsersArgs = {},\n): Promise<AuthUser[]> => {\n  const users = await conn.sendMessagePromise<AuthUser[]>({ type: \"config/auth/list\" });\n  return users.filter((user) => {\n    if (!includeSystemGenerated && user.system_generated) return false;\n    if (!includeInactiveUsers && !user.is_active) return false;\n    return true;\n  });\n};\n\n/**\n * Subscribe to (fetch once) the list of users. Returns an unsubscribe no-op.\n * If you need periodic refresh, wrap this in a polling interval externally.\n */\nexport const subscribeUsers = (conn: Connection, onChange: (users: AuthUser[]) => void, args?: FetchUsersArgs): (() => void) => {\n  fetchUsers(conn, args)\n    .then(onChange)\n    .catch((e) => {\n      console.warn(\"subscribeUsers: failed to fetch users\", e);\n      onChange([]);\n    });\n  return () => {\n    // No persistent subscription to clean up.\n  };\n};\n\nexport const userCollection = (conn: Connection) => getCollection(conn, \"_usr\", () => getUser(conn) as Promise<CurrentUser>, undefined);\n\nexport const subscribeUser = (conn: Connection, onChange: (user: CurrentUser) => void) => userCollection(conn).subscribe(onChange);\n"],"names":["fetchUsers","conn","includeSystemGenerated","includeInactiveUsers","user","subscribeUsers","onChange","args","e","userCollection","getCollection","getUser","subscribeUser"],"mappings":";AA4CA,MAAMA,IAAa,OACjBC,GACA,EAAE,wBAAAC,IAAyB,IAAO,sBAAAC,IAAuB,GAAA,IAA0B,QAErE,MAAMF,EAAK,mBAA+B,EAAE,MAAM,oBAAoB,GACvE,OAAO,CAACG,MACf,GAACF,KAA0BE,EAAK,oBAChC,CAACD,KAAwB,CAACC,EAAK,UAEpC,GAOUC,IAAiB,CAACJ,GAAkBK,GAAuCC,OACtFP,EAAWC,GAAMM,CAAI,EAClB,KAAKD,CAAQ,EACb,MAAM,CAACE,MAAM;AACZ,UAAQ,KAAK,yCAAyCA,CAAC,GACvDF,EAAS,CAAA,CAAE;AACb,CAAC,GACI,MAAM;AAEb,IAGWG,IAAiB,CAACR,MAAqBS,EAAcT,GAAM,QAAQ,MAAMU,EAAQV,CAAI,GAA2B,MAAS,GAEzHW,IAAgB,CAACX,GAAkBK,MAA0CG,EAAeR,CAAI,EAAE,UAAUK,CAAQ;"}