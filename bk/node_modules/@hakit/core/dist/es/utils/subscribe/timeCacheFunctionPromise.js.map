{"version":3,"file":"timeCacheFunctionPromise.js","sources":["../../../../src/utils/subscribe/timeCacheFunctionPromise.ts"],"sourcesContent":["import { Connection, HassEntities } from \"home-assistant-js-websocket\";\n\ninterface CacheResult<T> {\n  result: T;\n  cacheKey: unknown;\n}\n\nconst CACHE_OBJECT: Record<string, CacheResult<unknown> | Promise<CacheResult<unknown>> | undefined> = {};\n\nfunction getCacheObject<T>(cacheKey: string): CacheResult<T> | undefined {\n  return CACHE_OBJECT[cacheKey] as CacheResult<T> | undefined;\n}\n\nfunction setCacheObject<T>(cacheKey: string, value: CacheResult<T> | undefined | Promise<CacheResult<T>>): void {\n  CACHE_OBJECT[cacheKey] = value;\n}\n\n/**\n * Caches a result of a promise for X time. Allows optional extra validation\n * check to invalidate the cache.\n * @param cacheKey the key to store the cache\n * @param cacheTime the time to cache the result\n * @param func the function to fetch the data\n * @param generateCacheKey optional function to generate a cache key based on current hass + cached result. Cache is invalid if generates a different cache key.\n * @param hass Home Assistant object\n * @param args extra arguments to pass to the function to fetch the data\n * @returns\n */\nexport const timeCachePromiseFunc = async <T>(\n  cacheKey: string,\n  cacheTime: number,\n  func: (connection: Connection) => Promise<T>,\n  generateCacheKey: ((hassEntities: HassEntities, lastResult: T) => unknown) | undefined,\n  connection: Connection,\n  hassEntities: HassEntities,\n): Promise<T> => {\n  const lastResult: Promise<CacheResult<T>> | CacheResult<T> | undefined = getCacheObject(cacheKey);\n\n  const checkCachedResult = (result: CacheResult<T>): T | Promise<T> => {\n    if (!generateCacheKey || generateCacheKey(hassEntities, result.result) === result.cacheKey) {\n      return result.result;\n    }\n\n    CACHE_OBJECT[cacheKey] = undefined;\n    return timeCachePromiseFunc(cacheKey, cacheTime, func, generateCacheKey, connection, hassEntities);\n  };\n\n  // If we have a cached result, return it if it's still valid\n  if (lastResult) {\n    return lastResult instanceof Promise ? lastResult.then(checkCachedResult) : checkCachedResult(lastResult);\n  }\n\n  const resultPromise = func(connection);\n  setCacheObject<T>(cacheKey, resultPromise as Promise<CacheResult<T>>);\n\n  resultPromise.then(\n    // When successful, set timer to clear cache\n    (result) => {\n      setCacheObject(cacheKey, {\n        result,\n        cacheKey: generateCacheKey?.(hassEntities, result),\n      });\n      setTimeout(() => {\n        setCacheObject(cacheKey, undefined);\n      }, cacheTime);\n    },\n    // On failure, clear cache right away\n    () => {\n      setCacheObject(cacheKey, undefined);\n    },\n  );\n\n  return resultPromise;\n};\n"],"names":["CACHE_OBJECT","getCacheObject","cacheKey","setCacheObject","value","timeCachePromiseFunc","cacheTime","func","generateCacheKey","connection","hassEntities","lastResult","checkCachedResult","result","resultPromise"],"mappings":"AAOA,MAAMA,IAAiG,CAAA;AAEvG,SAASC,EAAkBC,GAA8C;AACvE,SAAOF,EAAaE,CAAQ;AAC9B;AAEA,SAASC,EAAkBD,GAAkBE,GAAmE;AAC9G,EAAAJ,EAAaE,CAAQ,IAAIE;AAC3B;AAaO,MAAMC,IAAuB,OAClCH,GACAI,GACAC,GACAC,GACAC,GACAC,MACe;AACf,QAAMC,IAAmEV,EAAeC,CAAQ,GAE1FU,IAAoB,CAACC,MACrB,CAACL,KAAoBA,EAAiBE,GAAcG,EAAO,MAAM,MAAMA,EAAO,WACzEA,EAAO,UAGhBb,EAAaE,CAAQ,IAAI,QAClBG,EAAqBH,GAAUI,GAAWC,GAAMC,GAAkBC,GAAYC,CAAY;AAInG,MAAIC;AACF,WAAOA,aAAsB,UAAUA,EAAW,KAAKC,CAAiB,IAAIA,EAAkBD,CAAU;AAG1G,QAAMG,IAAgBP,EAAKE,CAAU;AACrC,SAAAN,EAAkBD,GAAUY,CAAwC,GAEpEA,EAAc;AAAA;AAAA,IAEZ,CAACD,MAAW;AACV,MAAAV,EAAeD,GAAU;AAAA,QACvB,QAAAW;AAAA,QACA,UAAUL,IAAmBE,GAAcG,CAAM;AAAA,MAAA,CAClD,GACD,WAAW,MAAM;AACf,QAAAV,EAAeD,GAAU,MAAS;AAAA,MACpC,GAAGI,CAAS;AAAA,IACd;AAAA;AAAA,IAEA,MAAM;AACJ,MAAAH,EAAeD,GAAU,MAAS;AAAA,IACpC;AAAA,EAAA,GAGKY;AACT;"}