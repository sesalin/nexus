import "lodash";
import { W as p, q as w, r as O } from "../../../index-1tDtVGr2.js";
import { computeDomain as j } from "../../utils/computeDomain.js";
import "react";
import "../useLocale/locales/index.js";
import "home-assistant-js-websocket";
import "@iconify/react";
import "use-debounce";
import { stringCompare as z } from "../../utils/string.js";
import "../../utils/date.js";
const G = (a) => {
  const o = {};
  for (const i of a)
    i.device_id && (i.device_id in o || (o[i.device_id] = []), o[i.device_id].push(i));
  return o;
}, J = (a, o) => (i, u) => {
  {
    const f = a?.[i], d = a?.[u];
    if (f && d && f.level !== d.level)
      return (d.level ?? -9999) - (f.level ?? -9999);
    const v = f?.name ?? i, g = d?.name ?? u;
    return z(v, g);
  }
}, K = (a) => {
  const o = {};
  for (const i of a)
    i.floor_id && (i.floor_id in o || (o[i.floor_id] = []), o[i.floor_id].push(i));
  return o;
}, D = (a, o, i, u, f, d, v) => {
  const { joinHassUrl: g } = p.getState().helpers, y = p((t) => t.entities), k = p((t) => t.entitiesRegistryDisplay), N = p((t) => t.devices), B = p((t) => t.areas), A = p((t) => t.floors), H = Object.values(A), R = Object.values(B), S = Object.values(N), E = Object.values(k);
  let l = {}, s, c;
  (a || o || i || u || f) && (l = G(E), s = S, c = E.filter((t) => t.area_id), a && (s = s.filter((t) => {
    const e = l[t.id];
    return !e || !e.length ? !1 : l[t.id].some((r) => a.includes(j(r.entity_id)));
  }), c = c.filter((t) => a.includes(j(t.entity_id)))), o && (s = s.filter((t) => {
    const e = l[t.id];
    return !e || !e.length ? !0 : E.every((r) => !o.includes(j(r.entity_id)));
  }), c = c.filter((t) => !o.includes(j(t.entity_id)))), i && (s = s.filter((t) => {
    const e = l[t.id];
    return !e || !e.length ? !1 : l[t.id].some((r) => {
      const n = y[r.entity_id];
      return n ? n.attributes.device_class && i.includes(n.attributes.device_class) : !1;
    });
  }), c = c.filter((t) => {
    const e = y[t.entity_id];
    return e.attributes.device_class && i.includes(e.attributes.device_class);
  })), u && (s = s.filter((t) => u(t))), f && (s = s.filter((t) => {
    const e = l[t.id];
    return !e || !e.length ? !1 : l[t.id].some((r) => {
      const n = y[r.entity_id];
      return n ? f(n) : !1;
    });
  }), c = c.filter((t) => {
    const e = y[t.entity_id];
    return e ? f(e) : !1;
  })));
  let _ = R.map((t) => ({
    ...t,
    picture: t.picture ? g(t.picture) : t.picture
  })), m;
  s && (m = s.filter((t) => t.area_id).map((t) => t.area_id)), c && (m = (m ?? []).concat(c.filter((t) => t.area_id).map((t) => t.area_id))), m && (_ = _.filter((t) => m.includes(t.area_id))), d && (_ = _.filter((t) => !d.includes(t.area_id))), v && (_ = _.filter((t) => !t.floor_id || !v.includes(t.floor_id)));
  const L = K(_), q = Object.values(_).filter((t) => !t.floor_id || !L[t.floor_id]), I = J(A), U = Object.entries(L).map(([t, e]) => [H.find((n) => n.floor_id === t), e]).sort(([t], [e]) => I(t.floor_id, e.floor_id)), b = [];
  return U.forEach(([t, e]) => {
    if (t) {
      const r = w(t), n = e.map((h) => {
        const W = O(h) || h.area_id;
        return [h.area_id, W, ...h.aliases];
      }).flat();
      b.push({
        id: ["floor", t.floor_id].join("______"),
        type: "floor",
        primary: r,
        floor: t,
        icon: t.icon || void 0,
        search_labels: [t.floor_id, r, ...t.aliases, ...n]
      });
    }
    b.push(
      ...e.map((r) => {
        const n = O(r) || r.area_id;
        return {
          id: ["area", r.area_id].join("______"),
          type: "area",
          primary: n,
          area: r,
          icon: r.icon || void 0,
          search_labels: [r.area_id, n, ...r.aliases]
        };
      })
    );
  }), b.push(
    ...q.map((t) => {
      const e = O(t) || t.area_id;
      return {
        id: ["area", t.area_id].join("______"),
        type: "area",
        primary: e,
        area: t,
        icon: t.icon || void 0,
        search_labels: [t.area_id, e, ...t.aliases]
      };
    })
  ), b;
};
export {
  K as getFloorAreaLookup,
  D as useAreas
};
//# sourceMappingURL=getFloorsAndAreas.js.map
