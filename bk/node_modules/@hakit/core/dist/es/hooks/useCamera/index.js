import "lodash";
import { W as M } from "../../../index-1tDtVGr2.js";
import { useRef as T, useState as a, useMemo as b, useCallback as m, useEffect as A } from "react";
import "../useLocale/locales/index.js";
import { supportsFeatureFromAttributes as j } from "../../utils/supports-feature.js";
import "home-assistant-js-websocket";
import { u as F } from "../../../index-BiRhtKmJ.js";
import "@iconify/react";
import "use-debounce";
import { MAX_IMAGE_WIDTH as H, ASPECT_RATIO_DEFAULT as J, CAMERA_SUPPORT_STREAM as q, STREAM_TYPE_WEB_RTC as D } from "./constants.js";
import "../../utils/date.js";
import { isUnavailableState as v } from "../../data/entity.js";
import { computeMJPEGStreamUrl as O, fetchThumbnailUrlWithCache as k, fetchStreamUrl as B } from "./camera.js";
function ae(W, r) {
  const e = F(W), { joinHassUrl: n } = M.getState().helpers, s = M((t) => t.connection), f = T(!1), l = T(!1), [_, L] = a(void 0), [y, w] = a(void 0), [i, x] = a(void 0), [h, G] = a(void 0), [E, d] = a(r?.stream !== !1), [g, p] = a(r?.poster !== !1), P = b(() => n(O(e)), [e, n]), [o, I] = a({ frontend_stream_types: [] }), c = m(async () => {
    if (r?.poster !== !1 && s && !v(e.state) && !l.current) {
      l.current = !0, p(!0);
      try {
        const t = Math.ceil((r?.imageWidth ?? H) * devicePixelRatio), R = Math.ceil(t * (r?.aspectRatio ?? J)), C = await k(s, e.entity_id, t, R);
        L(n(C)), p(!1);
      } catch (t) {
        p(!1), t instanceof Error && G(t);
      }
    }
  }, [e.entity_id, n, e.state, s, r?.poster, r?.aspectRatio, r?.imageWidth]), S = m(
    async () => s?.sendMessagePromise({
      type: "camera/capabilities",
      entity_id: e.entity_id
    }),
    [s, e.entity_id]
  );
  A(() => {
    async function t() {
      I(await S() || { frontend_stream_types: [] });
    }
    t();
  }, [S]);
  const u = m(async () => {
    if (r?.stream !== !1 && s && !v(e.state) && !f.current) {
      f.current = !0, d(!0);
      try {
        const t = await B(s, e.entity_id);
        w(n(t)), d(!1);
      } catch (t) {
        d(!1), console.error(t), t instanceof Error && x(t);
      }
    }
  }, [e.entity_id, n, e.state, s, r?.stream]), U = m(() => i || !j(e.attributes, q) ? !0 : o.frontend_stream_types.includes(D) ? typeof RTCPeerConnection > "u" : !1, [e.attributes, o, i]);
  return A(() => {
    u(), c();
  }, [u, c]), b(() => ({
    ...e,
    stream: {
      url: y,
      loading: E,
      error: i,
      refresh: async () => (f.current = !1, u())
    },
    poster: {
      url: _,
      loading: g,
      error: h,
      refresh: async () => (l.current = !1, c())
    },
    mjpeg: {
      url: P,
      shouldRenderMJPEG: U()
    },
    ...o
  }), [
    e,
    y,
    U,
    E,
    i,
    u,
    _,
    g,
    h,
    P,
    c,
    o
  ]);
}
export {
  ae as useCamera
};
//# sourceMappingURL=index.js.map
