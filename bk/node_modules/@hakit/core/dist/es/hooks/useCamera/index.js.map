{"version":3,"file":"index.js","sources":["../../../../src/hooks/useCamera/index.ts"],"sourcesContent":["import { useEntity, isUnavailableState, useHass, supportsFeatureFromAttributes } from \"@core\";\nimport type { HassEntityWithService, FilterByDomain, EntityName } from \"@core\";\nimport { useRef, useState, useCallback, useMemo, useEffect } from \"react\";\nimport { fetchThumbnailUrlWithCache, fetchStreamUrl, computeMJPEGStreamUrl } from \"./camera\";\nimport { ASPECT_RATIO_DEFAULT, MAX_IMAGE_WIDTH, CAMERA_SUPPORT_STREAM, STREAM_TYPE_WEB_RTC, type StreamType } from \"./constants\";\n\nexport interface UseCameraOptions {\n  /** the requested width of the poster image @default 640 */\n  imageWidth?: number;\n  /** the requested aspect ratio of the image @default 9/16 */\n  aspectRatio?: number;\n  /** enable/disable the request for the poster */\n  poster?: boolean;\n  /** enable/disable the request for the stream */\n  stream?: boolean;\n}\n\ninterface CameraCapabilities {\n  frontend_stream_types: StreamType[];\n}\n\nexport interface CameraEntityExtended extends HassEntityWithService<\"camera\">, CameraCapabilities {\n  stream: {\n    url: string | undefined;\n    loading: boolean;\n    error: Error | undefined;\n    refresh: () => Promise<void>;\n  };\n  poster: {\n    url: string | undefined;\n    loading: boolean;\n    error: Error | undefined;\n    refresh: () => Promise<void>;\n  };\n  mjpeg: {\n    url: string | undefined;\n    shouldRenderMJPEG: boolean;\n  };\n}\n/** The useCamera hook is designed to return all the custom complex logic in an easy to retrieve structure, it supports streams, motion jpeg, posters and the camera entity */\nexport function useCamera(entity: FilterByDomain<EntityName, \"camera\">, options?: UseCameraOptions): CameraEntityExtended {\n  const camera = useEntity(entity);\n  const { joinHassUrl } = useHass.getState().helpers;\n  const connection = useHass((state) => state.connection);\n  const requestedStreamUrl = useRef(false);\n  const requestedPosterUrl = useRef(false);\n  const [posterUrl, setPosterUrl] = useState<string | undefined>(undefined);\n  const [streamUrl, setStreamUrl] = useState<string | undefined>(undefined);\n  const [streamError, setStreamError] = useState<Error | undefined>(undefined);\n  const [posterError, setPosterError] = useState<Error | undefined>(undefined);\n  const [streamLoading, setStreamLoading] = useState<boolean>(options?.stream === false ? false : true);\n  const [posterLoading, setPosterLoading] = useState<boolean>(options?.poster === false ? false : true);\n  const mjpeg = useMemo(() => joinHassUrl(computeMJPEGStreamUrl(camera)), [camera, joinHassUrl]);\n  const [capabilities, setCapabilities] = useState<CameraCapabilities>({ frontend_stream_types: [] });\n\n  const _getPosterUrl = useCallback(async (): Promise<void> => {\n    if (options?.poster === false) return;\n    if (!connection) return;\n    if (isUnavailableState(camera.state)) {\n      return;\n    }\n    if (requestedPosterUrl.current) return;\n    requestedPosterUrl.current = true;\n    setPosterLoading(true);\n    try {\n      const width = Math.ceil((options?.imageWidth ?? MAX_IMAGE_WIDTH) * devicePixelRatio);\n      const height = Math.ceil(width * (options?.aspectRatio ?? ASPECT_RATIO_DEFAULT));\n      const cameraImageSrc = await fetchThumbnailUrlWithCache(connection, camera.entity_id, width, height);\n      setPosterUrl(joinHassUrl(cameraImageSrc));\n      setPosterLoading(false);\n    } catch (err) {\n      setPosterLoading(false);\n      // poster url is optional\n      if (err instanceof Error) {\n        setPosterError(err);\n      }\n    }\n  }, [camera.entity_id, joinHassUrl, camera.state, connection, options?.poster, options?.aspectRatio, options?.imageWidth]);\n\n  const fetchCapabilities = useCallback(\n    async () =>\n      connection?.sendMessagePromise<CameraCapabilities>({\n        type: \"camera/capabilities\",\n        entity_id: camera.entity_id,\n      }),\n    [connection, camera.entity_id],\n  );\n\n  useEffect(() => {\n    async function load() {\n      setCapabilities((await fetchCapabilities()) || { frontend_stream_types: [] });\n    }\n    load();\n  }, [fetchCapabilities]);\n\n  const _getStreamUrl = useCallback(async (): Promise<void> => {\n    if (options?.stream === false) return;\n    if (!connection) return;\n    if (isUnavailableState(camera.state)) {\n      return;\n    }\n    if (requestedStreamUrl.current) return;\n    requestedStreamUrl.current = true;\n    setStreamLoading(true);\n    try {\n      const url = await fetchStreamUrl(connection, camera.entity_id);\n      setStreamUrl(joinHassUrl(url));\n      setStreamLoading(false);\n    } catch (err) {\n      setStreamLoading(false);\n      // Fails if we were unable to get a stream\n      console.error(err);\n      if (err instanceof Error) {\n        setStreamError(err);\n      }\n    }\n  }, [camera.entity_id, joinHassUrl, camera.state, connection, options?.stream]);\n\n  const _shouldRenderMJPEG = useCallback(() => {\n    if (streamError) {\n      // Fallback when unable to fetch stream url\n      return true;\n    }\n    if (!supportsFeatureFromAttributes(camera.attributes, CAMERA_SUPPORT_STREAM)) {\n      // Steaming is not supported by the camera so fallback to MJPEG stream\n      return true;\n    }\n    if (capabilities.frontend_stream_types.includes(STREAM_TYPE_WEB_RTC)) {\n      // Browser support required for WebRTC\n      return typeof RTCPeerConnection === \"undefined\";\n    }\n    // Server side stream component required for HLS\n    return false;\n  }, [camera.attributes, capabilities, streamError]);\n\n  useEffect(() => {\n    _getStreamUrl();\n    _getPosterUrl();\n  }, [_getStreamUrl, _getPosterUrl]);\n\n  return useMemo(() => {\n    const stream = {\n      url: streamUrl,\n      loading: streamLoading,\n      error: streamError,\n      refresh: async () => {\n        requestedStreamUrl.current = false;\n        return _getStreamUrl();\n      },\n    };\n    const poster = {\n      url: posterUrl,\n      loading: posterLoading,\n      error: posterError,\n      refresh: async () => {\n        requestedPosterUrl.current = false;\n        return _getPosterUrl();\n      },\n    };\n    const extendedCamera = {\n      ...camera,\n      stream,\n      poster,\n      mjpeg: {\n        url: mjpeg,\n        shouldRenderMJPEG: _shouldRenderMJPEG(),\n      },\n      ...capabilities,\n    } satisfies CameraEntityExtended;\n    return extendedCamera;\n  }, [\n    camera,\n    streamUrl,\n    _shouldRenderMJPEG,\n    streamLoading,\n    streamError,\n    _getStreamUrl,\n    posterUrl,\n    posterLoading,\n    posterError,\n    mjpeg,\n    _getPosterUrl,\n    capabilities,\n  ]);\n}\n"],"names":["useCamera","entity","options","camera","useEntity","joinHassUrl","useHass","connection","state","requestedStreamUrl","useRef","requestedPosterUrl","posterUrl","setPosterUrl","useState","streamUrl","setStreamUrl","streamError","setStreamError","posterError","setPosterError","streamLoading","setStreamLoading","posterLoading","setPosterLoading","mjpeg","useMemo","computeMJPEGStreamUrl","capabilities","setCapabilities","_getPosterUrl","useCallback","isUnavailableState","width","MAX_IMAGE_WIDTH","height","ASPECT_RATIO_DEFAULT","cameraImageSrc","fetchThumbnailUrlWithCache","err","fetchCapabilities","useEffect","load","_getStreamUrl","url","fetchStreamUrl","_shouldRenderMJPEG","supportsFeatureFromAttributes","CAMERA_SUPPORT_STREAM","STREAM_TYPE_WEB_RTC"],"mappings":";;;;;;;;;;;;;AAwCO,SAASA,GAAUC,GAA8CC,GAAkD;AACxH,QAAMC,IAASC,EAAUH,CAAM,GACzB,EAAE,aAAAI,EAAA,IAAgBC,EAAQ,WAAW,SACrCC,IAAaD,EAAQ,CAACE,MAAUA,EAAM,UAAU,GAChDC,IAAqBC,EAAO,EAAK,GACjCC,IAAqBD,EAAO,EAAK,GACjC,CAACE,GAAWC,CAAY,IAAIC,EAA6B,MAAS,GAClE,CAACC,GAAWC,CAAY,IAAIF,EAA6B,MAAS,GAClE,CAACG,GAAaC,CAAc,IAAIJ,EAA4B,MAAS,GACrE,CAACK,GAAaC,CAAc,IAAIN,EAA4B,MAAS,GACrE,CAACO,GAAeC,CAAgB,IAAIR,EAAkBZ,GAAS,WAAW,EAAoB,GAC9F,CAACqB,GAAeC,CAAgB,IAAIV,EAAkBZ,GAAS,WAAW,EAAoB,GAC9FuB,IAAQC,EAAQ,MAAMrB,EAAYsB,EAAsBxB,CAAM,CAAC,GAAG,CAACA,GAAQE,CAAW,CAAC,GACvF,CAACuB,GAAcC,CAAe,IAAIf,EAA6B,EAAE,uBAAuB,CAAA,GAAI,GAE5FgB,IAAgBC,EAAY,YAA2B;AAC3D,QAAI7B,GAAS,WAAW,MACnBK,KACD,CAAAyB,EAAmB7B,EAAO,KAAK,KAG/B,CAAAQ,EAAmB,SACvB;AAAA,MAAAA,EAAmB,UAAU,IAC7Ba,EAAiB,EAAI;AACrB,UAAI;AACF,cAAMS,IAAQ,KAAK,MAAM/B,GAAS,cAAcgC,KAAmB,gBAAgB,GAC7EC,IAAS,KAAK,KAAKF,KAAS/B,GAAS,eAAekC,EAAqB,GACzEC,IAAiB,MAAMC,EAA2B/B,GAAYJ,EAAO,WAAW8B,GAAOE,CAAM;AACnG,QAAAtB,EAAaR,EAAYgC,CAAc,CAAC,GACxCb,EAAiB,EAAK;AAAA,MACxB,SAASe,GAAK;AACZ,QAAAf,EAAiB,EAAK,GAElBe,aAAe,SACjBnB,EAAemB,CAAG;AAAA,MAEtB;AAAA;AAAA,EACF,GAAG,CAACpC,EAAO,WAAWE,GAAaF,EAAO,OAAOI,GAAYL,GAAS,QAAQA,GAAS,aAAaA,GAAS,UAAU,CAAC,GAElHsC,IAAoBT;AAAA,IACxB,YACExB,GAAY,mBAAuC;AAAA,MACjD,MAAM;AAAA,MACN,WAAWJ,EAAO;AAAA,IAAA,CACnB;AAAA,IACH,CAACI,GAAYJ,EAAO,SAAS;AAAA,EAAA;AAG/B,EAAAsC,EAAU,MAAM;AACd,mBAAeC,IAAO;AACpB,MAAAb,EAAiB,MAAMW,EAAA,KAAwB,EAAE,uBAAuB,CAAA,GAAI;AAAA,IAC9E;AACA,IAAAE,EAAA;AAAA,EACF,GAAG,CAACF,CAAiB,CAAC;AAEtB,QAAMG,IAAgBZ,EAAY,YAA2B;AAC3D,QAAI7B,GAAS,WAAW,MACnBK,KACD,CAAAyB,EAAmB7B,EAAO,KAAK,KAG/B,CAAAM,EAAmB,SACvB;AAAA,MAAAA,EAAmB,UAAU,IAC7Ba,EAAiB,EAAI;AACrB,UAAI;AACF,cAAMsB,IAAM,MAAMC,EAAetC,GAAYJ,EAAO,SAAS;AAC7D,QAAAa,EAAaX,EAAYuC,CAAG,CAAC,GAC7BtB,EAAiB,EAAK;AAAA,MACxB,SAASiB,GAAK;AACZ,QAAAjB,EAAiB,EAAK,GAEtB,QAAQ,MAAMiB,CAAG,GACbA,aAAe,SACjBrB,EAAeqB,CAAG;AAAA,MAEtB;AAAA;AAAA,EACF,GAAG,CAACpC,EAAO,WAAWE,GAAaF,EAAO,OAAOI,GAAYL,GAAS,MAAM,CAAC,GAEvE4C,IAAqBf,EAAY,MACjCd,KAIA,CAAC8B,EAA8B5C,EAAO,YAAY6C,CAAqB,IAElE,KAELpB,EAAa,sBAAsB,SAASqB,CAAmB,IAE1D,OAAO,oBAAsB,MAG/B,IACN,CAAC9C,EAAO,YAAYyB,GAAcX,CAAW,CAAC;AAEjD,SAAAwB,EAAU,MAAM;AACd,IAAAE,EAAA,GACAb,EAAA;AAAA,EACF,GAAG,CAACa,GAAeb,CAAa,CAAC,GAE1BJ,EAAQ,OAmBU;AAAA,IACrB,GAAGvB;AAAA,IACH,QApBa;AAAA,MACb,KAAKY;AAAA,MACL,SAASM;AAAA,MACT,OAAOJ;AAAA,MACP,SAAS,aACPR,EAAmB,UAAU,IACtBkC,EAAA;AAAA,IACT;AAAA,IAcA,QAZa;AAAA,MACb,KAAK/B;AAAA,MACL,SAASW;AAAA,MACT,OAAOJ;AAAA,MACP,SAAS,aACPR,EAAmB,UAAU,IACtBmB,EAAA;AAAA,IACT;AAAA,IAMA,OAAO;AAAA,MACL,KAAKL;AAAA,MACL,mBAAmBqB,EAAA;AAAA,IAAmB;AAAA,IAExC,GAAGlB;AAAA,EAAA,IAGJ;AAAA,IACDzB;AAAA,IACAY;AAAA,IACA+B;AAAA,IACAzB;AAAA,IACAJ;AAAA,IACA0B;AAAA,IACA/B;AAAA,IACAW;AAAA,IACAJ;AAAA,IACAM;AAAA,IACAK;AAAA,IACAF;AAAA,EAAA,CACD;AACH;"}