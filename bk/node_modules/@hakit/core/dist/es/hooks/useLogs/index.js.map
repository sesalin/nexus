{"version":3,"file":"index.js","sources":["../../../../src/hooks/useLogs/index.ts"],"sourcesContent":["import { useCallback, useState, useMemo, useEffect, useRef } from \"react\";\nimport { subscribeLogbook, type LogbookStreamMessage, type LogbookEntry } from \"./logbook\";\nimport { type EntityName, useHass } from \"@core\";\nimport type { Connection } from \"home-assistant-js-websocket\";\nimport { useDebouncedCallback } from \"use-debounce\";\n\ninterface LogbookTimePeriod {\n  now: Date;\n  startTime: Date;\n  endTime: Date;\n  purgeBeforePythonTime: number | undefined;\n}\n\nexport interface UseLogOptions {\n  /**The hours to show in the response */\n  hoursToShow?: number;\n  /** The start time of the logbook period */\n  startTime?: Date;\n  /** The end time of the logbook period */\n  endTime?: Date;\n}\ntype RecentTime = {\n  // Seconds\n  recent: number;\n};\ntype TimeRange = { range: [Date, Date] };\ntype Time = TimeRange | RecentTime;\n\nconst DEFAULT_HOURS_TO_SHOW = 24;\n\nconst findStartOfRecentTime = (now: Date, recentTime: number) => new Date(now.getTime() - recentTime * 1000).getTime() / 1000;\n\nexport function useLogs(entityId: EntityName, options?: UseLogOptions): LogbookEntry[] {\n  const [error, setError] = useState<string | undefined>(undefined);\n  const connection = useHass((state) => state.connection);\n  const [entries, setEntries] = useState<LogbookEntry[]>([]);\n  const _entriesRef = useRef<LogbookEntry[]>([]);\n  const _subscribed = useRef<boolean>(false);\n  const _unsubscribe = useRef<void | (() => Promise<void>)>(undefined);\n\n  const time = useMemo(() => {\n    // @ts-expect-error - properties are added manually\n    const time: Time = {};\n    if (options?.hoursToShow) {\n      (time as RecentTime).recent = options.hoursToShow * 60 * 60;\n    } else if (options?.startTime && options?.endTime) {\n      (time as TimeRange).range = [options.startTime, options.endTime];\n    } else {\n      (time as RecentTime).recent = DEFAULT_HOURS_TO_SHOW * 60 * 60;\n    }\n    return time;\n  }, [options]);\n\n  const _calculateLogbookPeriod = useCallback(() => {\n    const now = new Date();\n    if (\"range\" in time) {\n      return <LogbookTimePeriod>{\n        now: now,\n        startTime: time.range[0],\n        endTime: time.range[1],\n        purgeBeforePythonTime: undefined,\n      };\n    }\n    if (\"recent\" in time) {\n      const purgeBeforePythonTime = findStartOfRecentTime(now, time.recent);\n      return <LogbookTimePeriod>{\n        now: now,\n        startTime: new Date(purgeBeforePythonTime * 1000),\n        // end streaming one year from now\n        endTime: new Date(now.getTime() + 86400 * 365 * 1000),\n        purgeBeforePythonTime: findStartOfRecentTime(now, time.recent),\n      };\n    }\n    throw new Error(\"Unexpected time specified\");\n  }, [time]);\n\n  const _nonExpiredRecords = useCallback(\n    (purgeBeforePythonTime: number | undefined) =>\n      !_entriesRef.current\n        ? []\n        : purgeBeforePythonTime\n          ? _entriesRef.current.filter((entry) => entry.when > purgeBeforePythonTime!)\n          : _entriesRef.current,\n    [],\n  );\n\n  const _processStreamMessage = useCallback(\n    (streamMessage: LogbookStreamMessage) => {\n      const purgeBeforePythonTime = time && \"recent\" in time ? findStartOfRecentTime(new Date(), time.recent) : undefined;\n      // Put newest ones on top. Reverse works in-place so\n      // make a copy first.\n      const newEntries = [...streamMessage.events].reverse();\n      if (!_entriesRef.current.length) {\n        _entriesRef.current = newEntries;\n        setEntries(newEntries);\n        return;\n      }\n      if (!newEntries.length) {\n        // Empty messages are still sent to\n        // indicate no more historical events\n        return;\n      }\n      const nonExpiredRecords = _nonExpiredRecords(purgeBeforePythonTime);\n      // Entries are sorted in descending order with newest first.\n      if (!nonExpiredRecords.length) {\n        _entriesRef.current = newEntries;\n        // We have no records left, so we can just replace the list\n        setEntries(newEntries);\n      } else if (\n        newEntries[newEntries.length - 1].when > // oldest new entry\n        nonExpiredRecords[0].when // newest old entry\n      ) {\n        // The new records are newer than the old records\n        // append the old records to the end of the new records\n        _entriesRef.current = newEntries.concat(nonExpiredRecords);\n        setEntries(_entriesRef.current);\n      } else if (\n        nonExpiredRecords[nonExpiredRecords.length - 1].when > // oldest old entry\n        newEntries[0].when // newest new entry\n      ) {\n        _entriesRef.current = nonExpiredRecords.concat(newEntries);\n        // The new records are older than the old records\n        // append the new records to the end of the old records\n        setEntries(_entriesRef.current);\n      } else {\n        _entriesRef.current = nonExpiredRecords.concat(newEntries).sort((a: LogbookEntry, b: LogbookEntry) => b.when - a.when);\n        // The new records are in the middle of the old records\n        // so we need to re-sort them\n        setEntries(_entriesRef.current);\n      }\n    },\n    [time, _nonExpiredRecords],\n  );\n\n  useEffect(() => {\n    return () => {\n      _subscribed.current = false;\n      _entriesRef.current = [];\n      setEntries([]);\n    };\n  }, []);\n\n  const subscribeLogbookPeriod = useCallback(\n    (entityId: EntityName, logbookPeriod: LogbookTimePeriod) => {\n      const unsubscribe = subscribeLogbook(\n        connection as Connection,\n        (streamMessage) => {\n          // \"recent\" means start time is a sliding window\n          // so we need to calculate an expireTime to\n          // purge old events\n          if (!_subscribed.current) {\n            // Message came in before we had a chance to unload\n            return;\n          }\n          _processStreamMessage(streamMessage);\n        },\n        logbookPeriod.startTime.toISOString(),\n        logbookPeriod.endTime.toISOString(),\n        [entityId],\n      ).catch((err) => {\n        _subscribed.current = false;\n        if (err instanceof Error) {\n          setError(err.message);\n        }\n      });\n\n      return unsubscribe;\n    },\n    [connection, _processStreamMessage],\n  );\n\n  const debounceSubscribeLogbookPeriod = useDebouncedCallback(\n    async (entityId: EntityName, logBookPeriod: LogbookTimePeriod) => {\n      if (_unsubscribe.current) {\n        const unsubscribe = await _unsubscribe.current;\n        if (unsubscribe) {\n          await unsubscribe();\n        }\n        _unsubscribe.current = undefined;\n      }\n      _subscribed.current = true;\n      _unsubscribe.current = await subscribeLogbookPeriod(entityId, logBookPeriod);\n    },\n    100,\n    {\n      leading: true,\n      trailing: true,\n    },\n  );\n\n  useEffect(() => {\n    const logBookPeriod = _calculateLogbookPeriod();\n\n    debounceSubscribeLogbookPeriod(entityId, logBookPeriod);\n\n    return () => {\n      _subscribed.current = false;\n      if (_unsubscribe.current) {\n        _unsubscribe.current();\n      }\n    };\n  }, [_calculateLogbookPeriod, debounceSubscribeLogbookPeriod, subscribeLogbookPeriod, entityId]);\n\n  if (error) {\n    throw new Error(error);\n  }\n\n  return useMemo(() => entries, [entries]);\n}\n"],"names":["DEFAULT_HOURS_TO_SHOW","findStartOfRecentTime","now","recentTime","useLogs","entityId","options","error","setError","useState","connection","useHass","state","entries","setEntries","_entriesRef","useRef","_subscribed","_unsubscribe","time","useMemo","_calculateLogbookPeriod","useCallback","purgeBeforePythonTime","_nonExpiredRecords","entry","_processStreamMessage","streamMessage","newEntries","nonExpiredRecords","a","b","useEffect","subscribeLogbookPeriod","logbookPeriod","subscribeLogbook","err","debounceSubscribeLogbookPeriod","useDebouncedCallback","logBookPeriod","unsubscribe"],"mappings":"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"}