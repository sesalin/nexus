import "lodash";
import { X as e } from "../../../index-1tDtVGr2.js";
import { computeDomain as o } from "../../utils/computeDomain.js";
import "home-assistant-js-websocket";
import "react";
import "@iconify/react";
import "use-debounce";
import "../useLocale/locales/index.js";
import "../../utils/date.js";
import { DOMAINS_WITH_DYNAMIC_PICTURE as _, ON as u, OFF as d, UNKNOWN as m, UNAVAILABLE as p } from "../../data/entity.js";
const S = ["counter", "proximity", "sensor", "zone"], z = (r, a) => ({
  entity_id: r.entity_id,
  state: a,
  attributes: {
    // Rebuild the historical state by copying static attributes only
    device_class: r?.attributes.device_class,
    source_type: r?.attributes.source_type,
    has_date: r?.attributes.has_date,
    has_time: r?.attributes.has_time,
    // We do not want to use dynamic entity pictures (e.g., from media player) for the log book rendering,
    // as they would present a false state in the log (played media right now vs actual historic data).
    entity_picture_local: _.has(o(r.entity_id)) ? void 0 : r?.attributes.entity_picture_local,
    entity_picture: _.has(o(r.entity_id)) ? void 0 : r?.attributes.entity_picture
  }
}), M = (r, a, i, s, t, c) => {
  if ((t || c) && (!t || t.length === 0) && (!c || c.length === 0))
    return Promise.reject(`${e("no_matching_entities_found")}, ${e("no_matching_devices_found")}`);
  const n = {
    type: "logbook/event_stream",
    start_time: i,
    end_time: s
  };
  return t?.length && (n.entity_ids = t), c?.length && (n.device_ids = c), r.subscribeMessage((g) => a(g), n);
}, l = {
  "numeric state of": "triggered_by_numeric_state_of",
  // number state trigger
  "state of": "triggered_by_state_of",
  // state trigger
  event: "triggered_by_event",
  // event trigger
  time: "triggered_by_time",
  // time trigger
  "time pattern": "triggered_by_time_pattern",
  // time trigger
  "Home Assistant stopping": "triggered_by_home_assistant_stopping",
  // stop event
  "Home Assistant starting": "triggered_by_home_assistant_starting"
  // start event
}, U = (r) => {
  for (const a in l)
    if (r.startsWith(a))
      return r.replace(
        a,
        // @ts-expect-error - this is fine, it'll return undefined
        `${e(`${l[a]}`)}`
      );
  return r;
}, D = (r, a, i) => {
  switch (i) {
    case "device_tracker":
    case "person":
      return r === "not_home" ? e("was_detected_away") : r === "home" ? e("was_detected_at_home") : e("was_detected_at_state", {
        search: "{state}",
        replace: r
      });
    case "sun":
      return r === "above_horizon" ? e("rose") : e("set");
    case "binary_sensor": {
      const s = r === u, t = r === d, c = a.attributes.device_class;
      switch (c) {
        case "battery":
          if (s)
            return e("was_low");
          if (t)
            return e("was_normal");
          break;
        case "connectivity":
          if (s)
            return e("was_connected");
          if (t)
            return e("was_disconnected");
          break;
        case "door":
        case "garage_door":
        case "opening":
        case "window":
          if (s)
            return e("was_opened");
          if (t)
            return e("was_closed");
          break;
        case "lock":
          if (s)
            return e("was_unlocked");
          if (t)
            return e("was_locked");
          break;
        case "plug":
          if (s)
            return e("was_plugged_in");
          if (t)
            return e("was_unplugged");
          break;
        case "presence":
          if (s)
            return e("was_detected_at_home");
          if (t)
            return e("was_detected_away");
          break;
        case "safety":
          if (s)
            return e("was_unsafe");
          if (t)
            return e("was_safe");
          break;
        case "cold":
        case "gas":
        case "heat":
        case "moisture":
        case "motion":
        case "occupancy":
        case "power":
        case "problem":
        case "smoke":
        case "sound":
        case "vibration":
          if (s)
            return e("detected_deviceclass", {
              search: "{device_class}",
              replace: c
            });
          if (t)
            return e("cleared_no_deviceclass_detected", {
              search: "{device_class}",
              replace: c
            });
          break;
        case "tamper":
          if (s)
            return e("detected_tampering");
          if (t)
            return e("cleared_tampering");
          break;
      }
      break;
    }
    case "cover":
      switch (r) {
        case "open":
          return e("was_opened");
        case "opening":
          return e("is_opening");
        case "closing":
          return e("is_closing");
        case "closed":
          return e("was_closed");
      }
      break;
    case "event":
      return e("detected_an_event");
    case "lock":
      switch (r) {
        case "unlocked":
          return e("was_unlocked");
        case "locking":
          return e("is_locking");
        case "unlocking":
          return e("is_unlocking");
        case "locked":
          return e("was_locked");
        case "jammed":
          return e("is_jammed");
      }
      break;
  }
  return r === u ? e("turned_on") : r === d ? e("turned_off") : r === m ? e("became_unknown") : r === p ? e("became_unavailable") : e("changed_to_state", {
    search: "{state}",
    replace: a ? a.state : r
  });
};
export {
  S as CONTINUOUS_DOMAINS,
  z as createHistoricState,
  D as localizeStateMessage,
  U as localizeTriggerSource,
  M as subscribeLogbook
};
//# sourceMappingURL=logbook.js.map
