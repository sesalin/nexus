{"version":3,"file":"coordinates.js","sources":["../../../../src/hooks/useHistory/coordinates.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-explicit-any */\nimport type { EntityHistoryState } from \"./history\";\nconst STROKE_WIDTH = 5;\nconst average = (items: any[]): number => items.reduce((sum, entry) => sum + parseFloat(entry.state), 0) / items.length;\n\nconst lastValue = (items: any[]): number => parseFloat(items[items.length - 1].state) || 0;\n\nconst calcPoints = (history: any, hours: number, width: number, detail: number, min: number, max: number): number[][] => {\n  const coords = [] as number[][];\n  const height = 80;\n  let yRatio = (max - min) / height;\n  yRatio = yRatio !== 0 ? yRatio : height;\n  let xRatio = width / (hours - (detail === 1 ? 1 : 0));\n  xRatio = isFinite(xRatio) ? xRatio : width;\n\n  const first = history.filter(Boolean)[0];\n  let last = [average(first), lastValue(first)];\n\n  const getCoords = (item: any[], i: number, offset = 0, depth = 1): void => {\n    if (depth > 1 && item) {\n      return item.forEach((subItem, index) => getCoords(subItem, i, index, depth - 1));\n    }\n\n    const x = xRatio * (i + offset / 6);\n\n    if (item) {\n      last = [average(item), lastValue(item)];\n    }\n    const y = height + STROKE_WIDTH / 2 - ((item ? last[0] : last[1]) - min) / yRatio;\n    // @ts-expect-error - bad types FROM HOME ASSISTANT\n    return coords.push([x, y]);\n  };\n\n  for (let i = 0; i < history.length; i += 1) {\n    getCoords(history[i], i, 0, detail);\n  }\n\n  if (coords.length === 1) {\n    coords[1] = [width, coords[0][1]];\n  }\n\n  coords.push([width, coords[coords.length - 1][1]]);\n  return coords;\n};\n\ntype AccumulatorType = { [key: number]: NumericEntityHistoryState[] };\n\nexport const coordinates = (\n  history: NumericEntityHistoryState[],\n  hours: number,\n  width: number,\n  detail: number,\n  limits?: { min?: number; max?: number },\n): number[][] | undefined => {\n  history.forEach((item) => {\n    item.state = Number(item.state);\n  });\n  if (history.every((item) => Number.isNaN(item.state))) {\n    history = history.map((item, index) => {\n      if (Number.isNaN(item.state)) {\n        return {\n          ...item,\n          state: index,\n        };\n      }\n      return item;\n    });\n  }\n  history = history.filter((item) => !Number.isNaN(item.state));\n\n  const min = limits?.min !== undefined ? limits.min : Math.min(...history.map((item) => item.state));\n  const max = limits?.max !== undefined ? limits.max : Math.max(...history.map((item) => item.state));\n  const now = new Date().getTime();\n\n  const reduce = (res: NumericEntityHistoryState[][], item: NumericEntityHistoryState, point: boolean): AccumulatorType => {\n    const age = now - new Date(item.last_changed).getTime();\n\n    let key = Math.abs(age / (1000 * 3600) - hours);\n    if (point) {\n      key = (key - Math.floor(key)) * 60;\n      key = Number((Math.round(key / 10) * 10).toString()[0]);\n    } else {\n      key = Math.floor(key);\n    }\n    if (!res[key]) {\n      res[key] = [];\n    }\n    res[key].push(item);\n    return res;\n  };\n  // @ts-expect-error - bad typing, fix later\n  history = history.reduce<NumericEntityHistoryState[][]>(\n    // @ts-expect-error - bad typing, fix later\n    (res, item) => reduce(res, item, false),\n    [],\n  );\n  if (detail > 1) {\n    history = history.map((entry) =>\n      // @ts-expect-error - bad typing, fix later\n      entry.reduce((res, item) => reduce(res, item, true), []),\n    );\n  }\n  if (!history.length) {\n    return undefined;\n  }\n\n  return calcPoints(history, hours, width, detail, min, max);\n};\n\nexport interface NumericEntityHistoryState {\n  state: number;\n  _state: string;\n  last_changed: number;\n}\n\nexport const coordinatesMinimalResponseCompressedState = (\n  history: EntityHistoryState[],\n  hours: number,\n  width: number,\n  detail: number,\n  limits?: { min?: number; max?: number },\n): number[][] | undefined => {\n  if (!history) {\n    return undefined;\n  }\n  const numericHistory: NumericEntityHistoryState[] = history.map((item) => ({\n    _state: item.s,\n    state: Number(item.s),\n    // With minimal response and compressed state, we don't have last_changed,\n    // so we use last_updated since its always the same as last_changed since\n    // we already filtered out states that are the same.\n    last_changed: item.lu * 1000,\n  }));\n  return coordinates(numericHistory, hours, width, detail, limits);\n};\n"],"names":["average","items","sum","entry","lastValue","calcPoints","history","hours","width","detail","min","max","coords","yRatio","xRatio","first","last","getCoords","item","i","offset","depth","subItem","index","x","y","coordinates","limits","now","reduce","res","point","age","key","coordinatesMinimalResponseCompressedState","numericHistory"],"mappings":"AAGA,MAAMA,IAAU,CAACC,MAAyBA,EAAM,OAAO,CAACC,GAAKC,MAAUD,IAAM,WAAWC,EAAM,KAAK,GAAG,CAAC,IAAIF,EAAM,QAE3GG,IAAY,CAACH,MAAyB,WAAWA,EAAMA,EAAM,SAAS,CAAC,EAAE,KAAK,KAAK,GAEnFI,IAAa,CAACC,GAAcC,GAAeC,GAAeC,GAAgBC,GAAaC,MAA4B;AACvH,QAAMC,IAAS,CAAA;AAEf,MAAIC,KAAUF,IAAMD,KAAO;AAC3B,EAAAG,IAASA,MAAW,IAAIA,IAAS;AACjC,MAAIC,IAASN,KAASD,KAASE,MAAW,IAAI,IAAI;AAClD,EAAAK,IAAS,SAASA,CAAM,IAAIA,IAASN;AAErC,QAAMO,IAAQT,EAAQ,OAAO,OAAO,EAAE,CAAC;AACvC,MAAIU,IAAO,CAAChB,EAAQe,CAAK,GAAGX,EAAUW,CAAK,CAAC;AAE5C,QAAME,IAAY,CAACC,GAAaC,GAAWC,IAAS,GAAGC,IAAQ,MAAY;AACzE,QAAIA,IAAQ,KAAKH;AACf,aAAOA,EAAK,QAAQ,CAACI,GAASC,MAAUN,EAAUK,GAASH,GAAGI,GAAOF,IAAQ,CAAC,CAAC;AAGjF,UAAMG,IAAIV,KAAUK,IAAIC,IAAS;AAEjC,IAAIF,MACFF,IAAO,CAAChB,EAAQkB,CAAI,GAAGd,EAAUc,CAAI,CAAC;AAExC,UAAMO,IAAI,KAAS,IAAe,MAAMP,IAAOF,EAAK,CAAC,IAAIA,EAAK,CAAC,KAAKN,KAAOG;AAE3E,WAAOD,EAAO,KAAK,CAACY,GAAGC,CAAC,CAAC;AAAA,EAC3B;AAEA,WAASN,IAAI,GAAGA,IAAIb,EAAQ,QAAQa,KAAK;AACvC,IAAAF,EAAUX,EAAQa,CAAC,GAAGA,GAAG,GAAGV,CAAM;AAGpC,SAAIG,EAAO,WAAW,MACpBA,EAAO,CAAC,IAAI,CAACJ,GAAOI,EAAO,CAAC,EAAE,CAAC,CAAC,IAGlCA,EAAO,KAAK,CAACJ,GAAOI,EAAOA,EAAO,SAAS,CAAC,EAAE,CAAC,CAAC,CAAC,GAC1CA;AACT,GAIac,IAAc,CACzBpB,GACAC,GACAC,GACAC,GACAkB,MAC2B;AAC3B,EAAArB,EAAQ,QAAQ,CAACY,MAAS;AACxB,IAAAA,EAAK,QAAQ,OAAOA,EAAK,KAAK;AAAA,EAChC,CAAC,GACGZ,EAAQ,MAAM,CAACY,MAAS,OAAO,MAAMA,EAAK,KAAK,CAAC,MAClDZ,IAAUA,EAAQ,IAAI,CAACY,GAAMK,MACvB,OAAO,MAAML,EAAK,KAAK,IAClB;AAAA,IACL,GAAGA;AAAA,IACH,OAAOK;AAAA,EAAA,IAGJL,CACR,IAEHZ,IAAUA,EAAQ,OAAO,CAACY,MAAS,CAAC,OAAO,MAAMA,EAAK,KAAK,CAAC;AAE5D,QAAMR,IAAMiB,GAAQ,QAAQ,SAAYA,EAAO,MAAM,KAAK,IAAI,GAAGrB,EAAQ,IAAI,CAACY,MAASA,EAAK,KAAK,CAAC,GAC5FP,IAAMgB,GAAQ,QAAQ,SAAYA,EAAO,MAAM,KAAK,IAAI,GAAGrB,EAAQ,IAAI,CAACY,MAASA,EAAK,KAAK,CAAC,GAC5FU,KAAM,oBAAI,KAAA,GAAO,QAAA,GAEjBC,IAAS,CAACC,GAAoCZ,GAAiCa,MAAoC;AACvH,UAAMC,IAAMJ,IAAM,IAAI,KAAKV,EAAK,YAAY,EAAE,QAAA;AAE9C,QAAIe,IAAM,KAAK,IAAID,KAAO,MAAO,QAAQzB,CAAK;AAC9C,WAAIwB,KACFE,KAAOA,IAAM,KAAK,MAAMA,CAAG,KAAK,IAChCA,IAAM,QAAQ,KAAK,MAAMA,IAAM,EAAE,IAAI,IAAI,SAAA,EAAW,CAAC,CAAC,KAEtDA,IAAM,KAAK,MAAMA,CAAG,GAEjBH,EAAIG,CAAG,MACVH,EAAIG,CAAG,IAAI,CAAA,IAEbH,EAAIG,CAAG,EAAE,KAAKf,CAAI,GACXY;AAAA,EACT;AAaA,MAXAxB,IAAUA,EAAQ;AAAA;AAAA,IAEhB,CAACwB,GAAKZ,MAASW,EAAOC,GAAKZ,GAAM,EAAK;AAAA,IACtC,CAAA;AAAA,EAAC,GAECT,IAAS,MACXH,IAAUA,EAAQ;AAAA,IAAI,CAACH;AAAA;AAAA,MAErBA,EAAM,OAAO,CAAC2B,GAAKZ,MAASW,EAAOC,GAAKZ,GAAM,EAAI,GAAG,CAAA,CAAE;AAAA;AAAA,EAAA,IAGvD,EAACZ,EAAQ;AAIb,WAAOD,EAAWC,GAASC,GAAOC,GAAOC,GAAQC,GAAKC,CAAG;AAC3D,GAQauB,IAA4C,CACvD5B,GACAC,GACAC,GACAC,GACAkB,MAC2B;AAC3B,MAAI,CAACrB;AACH;AAEF,QAAM6B,IAA8C7B,EAAQ,IAAI,CAACY,OAAU;AAAA,IACzE,QAAQA,EAAK;AAAA,IACb,OAAO,OAAOA,EAAK,CAAC;AAAA;AAAA;AAAA;AAAA,IAIpB,cAAcA,EAAK,KAAK;AAAA,EAAA,EACxB;AACF,SAAOQ,EAAYS,GAAgB5B,GAAOC,GAAOC,GAAQkB,CAAM;AACjE;"}