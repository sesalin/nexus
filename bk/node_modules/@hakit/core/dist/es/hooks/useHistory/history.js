import "lodash";
import { W as b, X as O, h as E } from "../../../index-1tDtVGr2.js";
import { computeDomain as g } from "../../utils/computeDomain.js";
import "home-assistant-js-websocket";
import "react";
import "@iconify/react";
import "use-debounce";
import "../useLocale/locales/index.js";
import "../../utils/date.js";
const k = ["climate", "humidifier", "water_heater"], C = ["climate", "humidifier", "input_datetime", "water_heater", "person", "device_tracker"], T = [
  "temperature",
  "current_temperature",
  "target_temp_low",
  "target_temp_high",
  "hvac_action",
  "humidity",
  "mode",
  "action",
  "current_humidity"
], j = (e) => C.includes(g(e)), Q = ({
  connection: e,
  entityIds: i,
  callbackFunction: n,
  hoursToShow: s = 24,
  minimalResponse: t = !0,
  significantChangesOnly: o = !0,
  noAttributes: u
}) => {
  const r = {
    type: "history/stream",
    entity_ids: i,
    start_time: new Date((/* @__PURE__ */ new Date()).getTime() - 3600 * s * 1e3).toISOString(),
    minimal_response: t,
    significant_changes_only: o,
    no_attributes: u ?? !i.some((c) => j(c))
  }, f = new U(s);
  return e.subscribeMessage((c) => n(f.processMessage(c)), r);
};
class U {
  hoursToShow;
  combinedHistory;
  constructor(i) {
    this.hoursToShow = i, this.combinedHistory = {};
  }
  processMessage(i) {
    if (!this.combinedHistory || !Object.keys(this.combinedHistory).length)
      return this.combinedHistory = i.states, this.combinedHistory;
    if (!Object.keys(i.states).length)
      return this.combinedHistory;
    const n = this.hoursToShow ? ((/* @__PURE__ */ new Date()).getTime() - 3600 * this.hoursToShow * 1e3) / 1e3 : void 0, s = {};
    for (const t of Object.keys(this.combinedHistory))
      s[t] = [];
    for (const t of Object.keys(i.states))
      s[t] = [];
    for (const t of Object.keys(s)) {
      if (t in this.combinedHistory && t in i.states) {
        const o = this.combinedHistory[t], u = o[o.length - 1];
        s[t] = o.concat(i.states[t]), i.states[t][0].lu < u.lu && (s[t] = s[t].sort((r, f) => r.lu - f.lu));
      } else t in this.combinedHistory ? s[t] = this.combinedHistory[t] : s[t] = i.states[t];
      if (n && t in this.combinedHistory) {
        const o = s[t].filter((r) => r.lu < n);
        if (!o.length || (s[t] = s[t].filter((r) => r.lu >= n), s[t].length && s[t][0].lu === n))
          continue;
        const u = o[o.length - 1];
        u.lu = n, s[t].unshift(u);
      }
    }
    return this.combinedHistory = s, this.combinedHistory;
  }
}
const v = (e, i) => e.state === i.state && // Only compare attributes if both states have an attributes object.
// When `minimal_response` is sent, only the first and last state
// will have attributes except for domains in DOMAINS_USE_LAST_UPDATED.
(!e.attributes || !i.attributes || T.every((n) => e.attributes[n] === i.attributes[n])), L = (e, i, n) => {
  const s = b.getState().entities, t = [];
  return Object.keys(n).forEach((o) => {
    const u = n[o], r = u[0], f = g(o), c = [];
    for (const a of u) {
      let l;
      if (k.includes(f)) {
        l = {
          state: a.s,
          last_changed: a.lu * 1e3,
          attributes: {}
        };
        for (const m of T)
          m in a.a && (l.attributes[m] = a.a[m]);
      } else
        l = {
          state: a.s,
          // lc (last_changed) may be omitted if its the same
          // as lu (last_updated).
          last_changed: (a.lc ? a.lc : a.lu) * 1e3,
          attributes: {}
        };
      c.length > 1 && v(l, c[c.length - 1]) && v(l, c[c.length - 2]) || c.push(l);
    }
    const S = o in s ? s[o].attributes : "friendly_name" in r.a ? r.a : void 0;
    t.push({
      domain: f,
      name: E(o, S || {}),
      entity_id: o,
      states: c
    });
  }), {
    unit: e,
    device_class: i,
    identifier: Object.keys(n).join(""),
    data: t
  };
}, z = (e, i, n) => {
  const s = [], t = i[0], o = b.getState().formatter, u = b.getState().entities;
  for (const r of i) {
    if (s.length > 0 && r.s === s[s.length - 1].state)
      continue;
    const f = {};
    n?.attributes.device_class && (f.device_class = n?.attributes.device_class);
    const c = u[e];
    s.push({
      state_localize: o.attributeValue(
        {
          ...c,
          attributes: {
            ...r.a || t.a,
            ...f
          }
        },
        r.s
      ),
      state: r.s,
      // lc (last_changed) may be omitted if its the same
      // as lu (last_updated).
      last_changed: (r.lc ? r.lc : r.lu) * 1e3
    });
  }
  return {
    name: E(e, n?.attributes || t.a),
    entity_id: e,
    data: s
  };
}, B = ["counter", "input_number", "number"], N = (e) => B.includes(e), D = (e) => "unit_of_measurement" in e || "state_class" in e, F = (e, i) => e.attributes.device_class != null && i.includes(e.attributes.device_class), K = (e, i, n, s, t = !1) => t || N(e) || i != null && D(i.attributes) || i != null && e === "sensor" && F(i, s) || n != null, x = " ", P = (e, i, n) => n ? `${e}_${i || ""}` : e, Y = (e, i, n = !1, s = !1) => {
  const t = {}, o = [], u = {}, r = b.getState().sensorNumericDeviceClasses, f = b.getState().config, c = b.getState().entities;
  return e.entity_id in i ? u[e.entity_id] = i[e.entity_id] : c[e.entity_id] && (u[e.entity_id] = [
    {
      s: c[e.entity_id].state,
      a: c[e.entity_id].attributes,
      lu: new Date(c[e.entity_id].last_updated).getTime() / 1e3
    }
  ]), u ? (Object.keys(i).forEach((a) => {
    const l = u[a];
    if (l.length === 0)
      return;
    const m = g(a), _ = a in c ? c[a] : void 0, y = _ || N(m) ? void 0 : l.find((H) => H.a && D(H.a)), w = K(m, _, y, r, n);
    let d;
    w ? d = _?.attributes.unit_of_measurement || y?.a.unit_of_measurement || x : m === "zone" ? d = O("people_in_zone") : m === "climate" || m === "water_heater" ? d = f?.unit_system.temperature : m === "humidifier" && (d = "%");
    let p;
    m === "climate" ? p = "temperature" : m === "humidifier" ? p = "humidity" : m === "water_heater" && (p = "temperature");
    const A = p || (_?.attributes || y?.a)?.device_class, h = P(d, A, s);
    d ? h && h in t && a in t[h] ? t[h][a].push(...l) : h && (h in t || (t[h] = {}), t[h][a] = l) : o.push(z(a, l, _));
  }), { line: Object.keys(t).map((a) => {
    const l = a.split("_"), m = l[0], _ = l.slice(1).join("_") || void 0;
    return L(m, _, t[a]);
  }), timeline: o }) : { line: [], timeline: [] };
};
export {
  Y as computeHistory,
  Q as subscribeHistory
};
//# sourceMappingURL=history.js.map
