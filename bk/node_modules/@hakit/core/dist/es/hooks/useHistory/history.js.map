{"version":3,"file":"history.js","sources":["../../../../src/hooks/useHistory/history.ts"],"sourcesContent":["import { Connection, HassEntity, HassEntityAttributeBase, MessageBase } from \"home-assistant-js-websocket\";\nimport { computeDomain, computeStateNameFromEntityAttributes, localize, useHass } from \"@core\";\nimport type { EntityName } from \"@core\";\n\nconst DOMAINS_USE_LAST_UPDATED = [\"climate\", \"humidifier\", \"water_heater\"];\nconst NEED_ATTRIBUTE_DOMAINS = [\"climate\", \"humidifier\", \"input_datetime\", \"water_heater\", \"person\", \"device_tracker\"];\nconst LINE_ATTRIBUTES_TO_KEEP = [\n  \"temperature\",\n  \"current_temperature\",\n  \"target_temp_low\",\n  \"target_temp_high\",\n  \"hvac_action\",\n  \"humidity\",\n  \"mode\",\n  \"action\",\n  \"current_humidity\",\n];\n\nexport interface LineChartState {\n  state: string;\n  last_changed: number;\n  attributes?: HassEntity[\"attributes\"];\n}\n\nexport interface LineChartEntity {\n  domain: string;\n  name: string;\n  entity_id: string;\n  states: LineChartState[];\n  statistics?: LineChartState[];\n}\n\nexport interface LineChartUnit {\n  unit: string;\n  device_class?: string;\n  identifier: string;\n  data: LineChartEntity[];\n}\n\nexport interface HistoryStreamMessage {\n  states: HistoryStates;\n  start_time?: number; // Start time of this historical chunk\n  end_time?: number; // End time of this historical chunk\n}\n\nexport interface TimelineState {\n  state_localize: string;\n  state: string;\n  last_changed: number;\n}\n\nexport interface TimelineEntity {\n  name: string;\n  entity_id: string;\n  data: TimelineState[];\n}\n\nexport interface HistoryResult {\n  line: LineChartUnit[];\n  timeline: TimelineEntity[];\n}\n\nexport interface HistoryStates {\n  [entityId: string]: EntityHistoryState[];\n}\n\nexport interface EntityHistoryState {\n  /** state */\n  s: string;\n  /** attributes */\n  a: HassEntity[\"attributes\"];\n  /** last_changed; if set, also applies to lu */\n  lc?: number;\n  /** last_updated */\n  lu: number;\n}\n\nconst entityIdHistoryNeedsAttributes = (entityId: EntityName) => NEED_ATTRIBUTE_DOMAINS.includes(computeDomain(entityId));\ninterface SubscribeOptions {\n  connection: Connection;\n  entityIds: EntityName[];\n  callbackFunction: (data: HistoryStates) => void;\n  hoursToShow?: number;\n  minimalResponse?: boolean;\n  significantChangesOnly?: boolean;\n  noAttributes?: boolean;\n}\n\nexport const subscribeHistory = ({\n  connection,\n  entityIds,\n  callbackFunction,\n  hoursToShow = 24,\n  minimalResponse = true,\n  significantChangesOnly = true,\n  noAttributes,\n}: SubscribeOptions): Promise<() => Promise<void>> => {\n  const params: MessageBase = {\n    type: \"history/stream\",\n    entity_ids: entityIds,\n    start_time: new Date(new Date().getTime() - 60 * 60 * hoursToShow * 1000).toISOString(),\n    minimal_response: minimalResponse,\n    significant_changes_only: significantChangesOnly,\n    no_attributes: noAttributes ?? !entityIds.some((entityId) => entityIdHistoryNeedsAttributes(entityId)),\n  };\n  const stream = new HistoryStream(hoursToShow);\n  return connection.subscribeMessage<HistoryStreamMessage>((message) => callbackFunction(stream.processMessage(message)), params);\n};\n\nclass HistoryStream {\n  hoursToShow?: number;\n\n  combinedHistory: HistoryStates;\n\n  constructor(hoursToShow?: number) {\n    this.hoursToShow = hoursToShow;\n    this.combinedHistory = {};\n  }\n\n  processMessage(streamMessage: HistoryStreamMessage): HistoryStates {\n    if (!this.combinedHistory || !Object.keys(this.combinedHistory).length) {\n      this.combinedHistory = streamMessage.states;\n      return this.combinedHistory;\n    }\n    if (!Object.keys(streamMessage.states).length) {\n      // Empty messages are still sent to\n      // indicate no more historical events\n      return this.combinedHistory;\n    }\n    const purgeBeforePythonTime = this.hoursToShow ? (new Date().getTime() - 60 * 60 * this.hoursToShow * 1000) / 1000 : undefined;\n    const newHistory: HistoryStates = {};\n    for (const entityId of Object.keys(this.combinedHistory)) {\n      newHistory[entityId] = [];\n    }\n    for (const entityId of Object.keys(streamMessage.states)) {\n      newHistory[entityId] = [];\n    }\n    for (const entityId of Object.keys(newHistory)) {\n      if (entityId in this.combinedHistory && entityId in streamMessage.states) {\n        const entityCombinedHistory = this.combinedHistory[entityId];\n        const lastEntityCombinedHistory = entityCombinedHistory[entityCombinedHistory.length - 1];\n        newHistory[entityId] = entityCombinedHistory.concat(streamMessage.states[entityId]);\n        if (streamMessage.states[entityId][0].lu < lastEntityCombinedHistory.lu) {\n          // If the history is out of order we have to sort it.\n          newHistory[entityId] = newHistory[entityId].sort((a, b) => a.lu - b.lu);\n        }\n      } else if (entityId in this.combinedHistory) {\n        newHistory[entityId] = this.combinedHistory[entityId];\n      } else {\n        newHistory[entityId] = streamMessage.states[entityId];\n      }\n      // Remove old history\n      if (purgeBeforePythonTime && entityId in this.combinedHistory) {\n        const expiredStates = newHistory[entityId].filter((state) => state.lu < purgeBeforePythonTime);\n        if (!expiredStates.length) {\n          continue;\n        }\n        newHistory[entityId] = newHistory[entityId].filter((state) => state.lu >= purgeBeforePythonTime);\n        if (newHistory[entityId].length && newHistory[entityId][0].lu === purgeBeforePythonTime) {\n          continue;\n        }\n        // Update the first entry to the start time state\n        // as we need to preserve the start time state and\n        // only expire the rest of the history as it ages.\n        const lastExpiredState = expiredStates[expiredStates.length - 1];\n        lastExpiredState.lu = purgeBeforePythonTime;\n        newHistory[entityId].unshift(lastExpiredState);\n      }\n    }\n    this.combinedHistory = newHistory;\n    return this.combinedHistory;\n  }\n}\n\nconst equalState = (obj1: LineChartState, obj2: LineChartState) =>\n  obj1.state === obj2.state &&\n  // Only compare attributes if both states have an attributes object.\n  // When `minimal_response` is sent, only the first and last state\n  // will have attributes except for domains in DOMAINS_USE_LAST_UPDATED.\n  (!obj1.attributes || !obj2.attributes || LINE_ATTRIBUTES_TO_KEEP.every((attr) => obj1.attributes![attr] === obj2.attributes![attr]));\n\nconst processLineChartEntities = (unit: string, device_class: string | undefined, entities: HistoryStates): LineChartUnit => {\n  const hassEntities = useHass.getState().entities;\n  const data: LineChartEntity[] = [];\n\n  Object.keys(entities).forEach((entityId) => {\n    const states = entities[entityId];\n    const first: EntityHistoryState = states[0];\n    const domain = computeDomain(entityId as EntityName);\n    const processedStates: LineChartState[] = [];\n\n    for (const state of states) {\n      let processedState: LineChartState;\n\n      if (DOMAINS_USE_LAST_UPDATED.includes(domain)) {\n        processedState = {\n          state: state.s,\n          last_changed: state.lu * 1000,\n          attributes: {},\n        };\n\n        for (const attr of LINE_ATTRIBUTES_TO_KEEP) {\n          if (attr in state.a) {\n            processedState.attributes![attr] = state.a[attr];\n          }\n        }\n      } else {\n        processedState = {\n          state: state.s,\n          // lc (last_changed) may be omitted if its the same\n          // as lu (last_updated).\n          last_changed: (state.lc ? state.lc : state.lu) * 1000,\n          attributes: {},\n        };\n      }\n\n      if (\n        processedStates.length > 1 &&\n        equalState(processedState, processedStates[processedStates.length - 1]) &&\n        equalState(processedState, processedStates[processedStates.length - 2])\n      ) {\n        continue;\n      }\n\n      processedStates.push(processedState);\n    }\n\n    const attributes = entityId in hassEntities ? hassEntities[entityId].attributes : \"friendly_name\" in first.a ? first.a : undefined;\n\n    data.push({\n      domain,\n      name: computeStateNameFromEntityAttributes(entityId, attributes || {}),\n      entity_id: entityId,\n      states: processedStates,\n    });\n  });\n\n  return {\n    unit,\n    device_class,\n    identifier: Object.keys(entities).join(\"\"),\n    data,\n  };\n};\n\nconst processTimelineEntity = (entityId: string, states: EntityHistoryState[], current_state: HassEntity | undefined): TimelineEntity => {\n  const data: TimelineState[] = [];\n  const first: EntityHistoryState = states[0];\n  const formatter = useHass.getState().formatter;\n  const entities = useHass.getState().entities;\n  for (const state of states) {\n    if (data.length > 0 && state.s === data[data.length - 1].state) {\n      continue;\n    }\n\n    const currentAttributes: HassEntityAttributeBase = {};\n    if (current_state?.attributes.device_class) {\n      currentAttributes.device_class = current_state?.attributes.device_class;\n    }\n    const entity = entities[entityId];\n\n    data.push({\n      state_localize: formatter.attributeValue(\n        {\n          ...entity,\n          attributes: {\n            ...(state.a || first.a),\n            ...currentAttributes,\n          },\n        },\n        state.s,\n      ),\n      state: state.s,\n      // lc (last_changed) may be omitted if its the same\n      // as lu (last_updated).\n      last_changed: (state.lc ? state.lc : state.lu) * 1000,\n    });\n  }\n\n  return {\n    name: computeStateNameFromEntityAttributes(entityId, current_state?.attributes || first.a),\n    entity_id: entityId,\n    data,\n  };\n};\n\nconst NUMERICAL_DOMAINS = [\"counter\", \"input_number\", \"number\"];\n\nconst isNumericFromDomain = (domain: string) => NUMERICAL_DOMAINS.includes(domain);\n\nconst isNumericFromAttributes = (attributes: Record<string, unknown>) => \"unit_of_measurement\" in attributes || \"state_class\" in attributes;\n\nconst isNumericSensorEntity = (stateObj: HassEntity, sensorNumericalDeviceClasses: string[]) =>\n  stateObj.attributes.device_class != null && sensorNumericalDeviceClasses.includes(stateObj.attributes.device_class);\n\nconst isNumericEntity = (\n  domain: string,\n  currentState: HassEntity | undefined,\n  numericStateFromHistory: EntityHistoryState | undefined,\n  sensorNumericalDeviceClasses: string[],\n  forceNumeric = false,\n): boolean =>\n  forceNumeric ||\n  isNumericFromDomain(domain) ||\n  (currentState != null && isNumericFromAttributes(currentState.attributes)) ||\n  (currentState != null && domain === \"sensor\" && isNumericSensorEntity(currentState, sensorNumericalDeviceClasses)) ||\n  numericStateFromHistory != null;\n\nconst BLANK_UNIT = \" \";\n\nconst computeGroupKey = (unit: string | undefined, device_class: string | undefined, splitDeviceClasses: boolean) =>\n  splitDeviceClasses ? `${unit}_${device_class || \"\"}` : unit;\n\nexport const computeHistory = (\n  entity: HassEntity,\n  stateHistory: HistoryStates,\n  forceNumeric = false,\n  splitDeviceClasses = false,\n): HistoryResult => {\n  const lineChartDevices: { [unit: string]: HistoryStates } = {};\n  const timelineDevices: TimelineEntity[] = [];\n  const localStateHistory: HistoryStates = {};\n  const sensorNumericalDeviceClasses = useHass.getState().sensorNumericDeviceClasses;\n  const config = useHass.getState().config;\n  const entities = useHass.getState().entities;\n\n  if (entity.entity_id in stateHistory) {\n    localStateHistory[entity.entity_id] = stateHistory[entity.entity_id];\n  } else if (entities[entity.entity_id]) {\n    localStateHistory[entity.entity_id] = [\n      {\n        s: entities[entity.entity_id].state,\n        a: entities[entity.entity_id].attributes,\n        lu: new Date(entities[entity.entity_id].last_updated).getTime() / 1000,\n      },\n    ];\n  }\n\n  if (!localStateHistory) {\n    return { line: [], timeline: [] };\n  }\n  Object.keys(stateHistory).forEach((entityId) => {\n    const stateInfo = localStateHistory[entityId];\n    if (stateInfo.length === 0) {\n      return;\n    }\n\n    const domain = computeDomain(entityId as EntityName);\n\n    const currentState = entityId in entities ? entities[entityId] : undefined;\n    const numericStateFromHistory =\n      currentState || isNumericFromDomain(domain) ? undefined : stateInfo.find((state) => state.a && isNumericFromAttributes(state.a));\n\n    const isNumeric = isNumericEntity(domain, currentState, numericStateFromHistory, sensorNumericalDeviceClasses, forceNumeric);\n\n    let unit: string | undefined;\n\n    if (isNumeric) {\n      unit = currentState?.attributes.unit_of_measurement || numericStateFromHistory?.a.unit_of_measurement || BLANK_UNIT;\n    } else {\n      if (domain === \"zone\") {\n        unit = localize(\"people_in_zone\");\n      } else if (domain === \"climate\" || domain === \"water_heater\") {\n        unit = config?.unit_system.temperature;\n      } else if (domain === \"humidifier\") {\n        unit = \"%\";\n      }\n    }\n\n    let deviceClassSpecial: string | undefined;\n\n    if (domain === \"climate\") {\n      deviceClassSpecial = \"temperature\";\n    } else if (domain === \"humidifier\") {\n      deviceClassSpecial = \"humidity\";\n    } else if (domain === \"water_heater\") {\n      deviceClassSpecial = \"temperature\";\n    }\n\n    const deviceClass: string | undefined = deviceClassSpecial || (currentState?.attributes || numericStateFromHistory?.a)?.device_class;\n\n    const key = computeGroupKey(unit, deviceClass, splitDeviceClasses);\n\n    if (!unit) {\n      timelineDevices.push(processTimelineEntity(entityId, stateInfo, currentState));\n    } else if (key && key in lineChartDevices && entityId in lineChartDevices[key]) {\n      lineChartDevices[key][entityId].push(...stateInfo);\n    } else if (key) {\n      if (!(key in lineChartDevices)) {\n        lineChartDevices[key] = {};\n      }\n      lineChartDevices[key][entityId] = stateInfo;\n    }\n  });\n\n  const unitStates = Object.keys(lineChartDevices).map((key) => {\n    const splitKey = key.split(\"_\");\n    const unit = splitKey[0];\n    const deviceClass = splitKey.slice(1).join(\"_\") || undefined;\n    return processLineChartEntities(unit, deviceClass, lineChartDevices[key]);\n  });\n\n  return { line: unitStates, timeline: timelineDevices };\n};\n"],"names":["DOMAINS_USE_LAST_UPDATED","NEED_ATTRIBUTE_DOMAINS","LINE_ATTRIBUTES_TO_KEEP","entityIdHistoryNeedsAttributes","entityId","computeDomain","subscribeHistory","connection","entityIds","callbackFunction","hoursToShow","minimalResponse","significantChangesOnly","noAttributes","params","stream","HistoryStream","message","streamMessage","purgeBeforePythonTime","newHistory","entityCombinedHistory","lastEntityCombinedHistory","a","b","expiredStates","state","lastExpiredState","equalState","obj1","obj2","attr","processLineChartEntities","unit","device_class","entities","hassEntities","useHass","data","states","first","domain","processedStates","processedState","attributes","computeStateNameFromEntityAttributes","processTimelineEntity","current_state","formatter","currentAttributes","entity","NUMERICAL_DOMAINS","isNumericFromDomain","isNumericFromAttributes","isNumericSensorEntity","stateObj","sensorNumericalDeviceClasses","isNumericEntity","currentState","numericStateFromHistory","forceNumeric","BLANK_UNIT","computeGroupKey","splitDeviceClasses","computeHistory","stateHistory","lineChartDevices","timelineDevices","localStateHistory","config","stateInfo","isNumeric","localize","deviceClassSpecial","deviceClass","key","splitKey"],"mappings":"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"}