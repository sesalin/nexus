const m = (t) => t.reduce((c, s) => c + parseFloat(s.state), 0) / t.length, x = (t) => parseFloat(t[t.length - 1].state) || 0, _ = (t, c, s, u, r, g) => {
  const n = [];
  let l = (g - r) / 80;
  l = l !== 0 ? l : 80;
  let e = s / (c - (u === 1 ? 1 : 0));
  e = isFinite(e) ? e : s;
  const o = t.filter(Boolean)[0];
  let f = [m(o), x(o)];
  const p = (a, d, M = 0, b = 1) => {
    if (b > 1 && a)
      return a.forEach((T, R) => p(T, d, R, b - 1));
    const h = e * (d + M / 6);
    a && (f = [m(a), x(a)]);
    const v = 80 + 5 / 2 - ((a ? f[0] : f[1]) - r) / l;
    return n.push([h, v]);
  };
  for (let a = 0; a < t.length; a += 1)
    p(t[a], a, 0, u);
  return n.length === 1 && (n[1] = [s, n[0][1]]), n.push([s, n[n.length - 1][1]]), n;
}, D = (t, c, s, u, r) => {
  t.forEach((e) => {
    e.state = Number(e.state);
  }), t.every((e) => Number.isNaN(e.state)) && (t = t.map((e, o) => Number.isNaN(e.state) ? {
    ...e,
    state: o
  } : e)), t = t.filter((e) => !Number.isNaN(e.state));
  const g = r?.min !== void 0 ? r.min : Math.min(...t.map((e) => e.state)), n = r?.max !== void 0 ? r.max : Math.max(...t.map((e) => e.state)), N = (/* @__PURE__ */ new Date()).getTime(), l = (e, o, f) => {
    const p = N - new Date(o.last_changed).getTime();
    let a = Math.abs(p / (1e3 * 3600) - c);
    return f ? (a = (a - Math.floor(a)) * 60, a = Number((Math.round(a / 10) * 10).toString()[0])) : a = Math.floor(a), e[a] || (e[a] = []), e[a].push(o), e;
  };
  if (t = t.reduce(
    // @ts-expect-error - bad typing, fix later
    (e, o) => l(e, o, !1),
    []
  ), u > 1 && (t = t.map(
    (e) => (
      // @ts-expect-error - bad typing, fix later
      e.reduce((o, f) => l(o, f, !0), [])
    )
  )), !!t.length)
    return _(t, c, s, u, g, n);
}, E = (t, c, s, u, r) => {
  if (!t)
    return;
  const g = t.map((n) => ({
    _state: n.s,
    state: Number(n.s),
    // With minimal response and compressed state, we don't have last_changed,
    // so we use last_updated since its always the same as last_changed since
    // we already filtered out states that are the same.
    last_changed: n.lu * 1e3
  }));
  return D(g, c, s, u, r);
};
export {
  D as coordinates,
  E as coordinatesMinimalResponseCompressedState
};
//# sourceMappingURL=coordinates.js.map
