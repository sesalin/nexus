import * as q from "react/jsx-runtime";
import * as H from "react";
import mt, { useState as Ie, useEffect as Y, forwardRef as dt, useContext as pt, useMemo as ke, useCallback as be, useRef as me, memo as yt } from "react";
import _t from "@emotion/cache";
import { getRegisteredStyles as gt, registerStyles as ht, insertStyles as vt } from "@emotion/utils";
import { serializeStyles as St } from "@emotion/serialize";
import { callService as bt, createCollection as Fe, subscribeEntities as Et, subscribeConfig as Dt, subscribeServices as Tt } from "home-assistant-js-websocket";
import { clearTokens as Ct, loadTokens as Rt } from "./es/HassConnect/token-storage.js";
import { create as Ue } from "zustand";
import { isArray as wt, snakeCase as Ee, debounce as je } from "lodash";
import { temperature2rgb as Pt } from "./es/utils/colors/convert-light-color.js";
import de from "./es/hooks/useLocale/locales/index.js";
import "@iconify/react";
import "use-debounce";
import { formatDateTimeWithBrowserDefaults as De, formatDateNumeric as At, formatDateWeekdayShort as Nt, formatDateWeekday as xt, formatDateYear as Wt, formatDateMonth as Ot, formatDateMonthYear as Mt, formatDateVeryShort as $t, formatDateShort as Lt, formatDateWeekdayDay as It, formatDateTimeNumeric as kt, formatShortDateTimeWithConditionalYear as Ft, formatShortDateTimeWithYear as Ut, formatShortDateTime as jt, formatDateTimeWithSeconds as Ye, formatDateTime as re, formatSeconds as Yt, formatMinute as Ht, formatAmPmSuffix as zt, formatHour as Bt, formatTimeWithoutAmPm as Vt, formatTime as He, formatDate as _e, resolveTimeZone as qt, shouldUseAmPm as Gt, formatDuration as ze, isDate as Kt, isTimestamp as Jt, checkValidDate as Te, UNIT_TO_MILLISECOND_CONVERT as Xt } from "./es/utils/date.js";
import Be from "@emotion/styled";
import { keyframes as Zt } from "@emotion/react";
import { LIGHT_COLOR_MODES as F } from "./es/types/autogenerated-types-by-domain.js";
import { computeDomain as U } from "./es/utils/computeDomain.js";
import { formatNumber as pe, isNumericFromAttributes as Qt, getNumberFormatOptions as Ce } from "./es/utils/number.js";
import { blankBeforeUnit as er } from "./es/utils/blankBeforeUnit.js";
import { UNAVAILABLE as Ve, isUnavailableState as tr, OFF as rr, UNKNOWN as nr } from "./es/data/entity.js";
import { handleSuspendResume as or } from "./es/HassConnect/handleSuspendResume.js";
import { tryConnection as ir, handleError as sr } from "./es/HassConnect/tryConnection.js";
import { caseInsensitiveStringCompare as qe } from "./es/utils/string.js";
import { stripPrefixFromEntityName as ar } from "./es/utils/stripPrefixFromEntityName.js";
import { subscribeAreaRegistry as cr } from "./es/utils/subscribe/areas.js";
import { subscribeFloorRegistry as ur } from "./es/utils/subscribe/floors.js";
import { subscribeFrontendUserData as fr, getUserLocaleLanguage as lr } from "./es/utils/subscribe/frontend_data.js";
import { subscribeUser as mr, subscribeUsers as dr } from "./es/utils/subscribe/user.js";
const ge = [
  F.HS,
  F.XY,
  F.RGB,
  F.RGBW,
  F.RGBWW
], pr = [
  ...ge,
  F.COLOR_TEMP,
  F.BRIGHTNESS,
  F.WHITE
], Ge = (e, r) => e.attributes.supported_color_modes?.includes(r) || !1, In = (e) => e.attributes.color_mode && ge.includes(e.attributes.color_mode) || !1, Ke = (e) => e.attributes.supported_color_modes?.some((r) => ge.includes(r)) || !1, kn = (e) => e.attributes.supported_color_modes?.some((r) => pr.includes(r)) || !1, Fn = (e) => Ke(e) || Ge(e, F.COLOR_TEMP), Un = (e) => e.attributes.color_mode === F.RGBWW ? e.attributes.rgbww_color : e.attributes.color_mode === F.RGBW ? e.attributes.rgbw_color : e.attributes.rgb_color, Q = 4, yr = [
  { rgb_color: [127, 172, 255] },
  // blue #7FACFF
  { rgb_color: [215, 150, 255] },
  // purple #D796FF
  { rgb_color: [255, 158, 243] },
  // pink #FF9EF3
  { rgb_color: [255, 110, 84] }
  // red #FF6E54
], jn = (e) => {
  const r = [], t = Ge(e, F.COLOR_TEMP), n = Ke(e);
  if (t) {
    const o = e.attributes.min_color_temp_kelvin, i = (e.attributes.max_color_temp_kelvin - o) / (Q - 1);
    for (let a = 0; a < Q; a++)
      r.push({
        color_temp_kelvin: Math.round(o + i * a)
      });
  } else if (n) {
    const i = 4500 / (Q - 1);
    for (let a = 0; a < Q; a++)
      r.push({
        rgb_color: Pt(Math.round(2e3 + i * a))
      });
  }
  return n && r.push(...yr), r;
};
function N(e) {
  return typeof e == "string" ? new Date(e) : e;
}
function _r() {
  const e = (g) => De(g), r = () => M.getState();
  return {
    formatDate: (g) => {
      const u = N(g), { locale: f, config: l } = r();
      return !f || !l ? e(u) : _e(u, l, f);
    },
    formatTime: (g) => {
      const u = N(g), { locale: f, config: l } = r();
      return !f || !l ? e(u) : He(u, l, f);
    },
    formatTimeWithoutAmPm: (g) => {
      const u = N(g), { locale: f, config: l } = r();
      return !f || !l ? `${u.getHours().toString().padStart(2, "0")}:${u.getMinutes().toString().padStart(2, "0")}` : Vt(u, l, f);
    },
    formatHour: (g) => {
      const u = N(g), { locale: f, config: l } = r();
      return !f || !l ? u.getHours().toString().padStart(2, "0") : Bt(u, l, f);
    },
    formatAmPmSuffix: (g) => {
      const u = N(g), { locale: f, config: l } = r();
      return !f || !l ? u.getHours() >= 12 ? "PM" : "AM" : zt(u, f, l);
    },
    formatMinute: (g) => {
      const u = N(g), { locale: f, config: l } = r();
      return !f || !l ? u.getMinutes().toString().padStart(2, "0") : Ht(u, l, f);
    },
    formatSeconds: (g) => {
      const u = N(g), { locale: f, config: l } = r();
      return !f || !l ? u.getSeconds().toString().padStart(2, "0") : Yt(u, l, f);
    },
    formatDateTime: (g) => {
      const u = N(g), { locale: f, config: l } = r();
      return !f || !l ? e(u) : re(u, l, f);
    },
    formatDateTimeWithSeconds: (g) => {
      const u = N(g), { locale: f, config: l } = r();
      return !f || !l ? e(u) : Ye(u, f, l);
    },
    formatShortDateTime: (g) => {
      const u = N(g), { locale: f, config: l } = r();
      return !f || !l ? e(u) : jt(u, f, l);
    },
    formatShortDateTimeWithYear: (g) => {
      const u = N(g), { locale: f, config: l } = r();
      return !f || !l ? e(u) : Ut(u, f, l);
    },
    formatShortDateTimeWithConditionalYear: (g) => {
      const u = N(g), { locale: f, config: l } = r();
      return !f || !l ? e(u) : Ft(u, f, l);
    },
    formatDateTimeWithBrowserDefaults: (g) => De(N(g)),
    formatDateTimeNumeric: (g) => {
      const u = N(g), { locale: f, config: l } = r();
      return !f || !l ? e(u) : kt(u, f, l);
    },
    formatDateWeekdayDay: (g) => {
      const u = N(g), { locale: f, config: l } = r();
      return !f || !l ? e(u) : It(u, f, l);
    },
    formatDateShort: (g) => {
      const u = N(g), { locale: f, config: l } = r();
      return !f || !l ? e(u) : Lt(u, f, l);
    },
    formatDateVeryShort: (g) => {
      const u = N(g), { locale: f, config: l } = r();
      return !f || !l ? e(u) : $t(u, f, l);
    },
    formatDateMonthYear: (g) => {
      const u = N(g), { locale: f, config: l } = r();
      return !f || !l ? e(u) : Mt(u, f, l);
    },
    formatDateMonth: (g) => {
      const u = N(g), { locale: f, config: l } = r();
      return !f || !l ? e(u) : Ot(u, f, l);
    },
    formatDateYear: (g) => {
      const u = N(g), { locale: f, config: l } = r();
      return !f || !l ? e(u) : Wt(u, f, l);
    },
    formatDateWeekday: (g) => {
      const u = N(g), { locale: f, config: l } = r();
      return !f || !l ? e(u) : xt(u, f, l);
    },
    formatDateWeekdayShort: (g) => {
      const u = N(g), { locale: f, config: l } = r();
      return !f || !l ? e(u) : Nt(u, f, l);
    },
    formatDateNumeric: (g) => {
      const u = N(g), { locale: f, config: l } = r();
      return !f || !l ? e(u) : At(u, f, l);
    }
  };
}
async function gr(e, r) {
  try {
    const { connection: t, hassUrl: n } = M.getState(), o = await fetch(`${n}/api${e}`, {
      method: "GET",
      ...r ?? {},
      headers: {
        Authorization: "Bearer " + t?.options.auth?.accessToken,
        "Content-type": "application/json;charset=UTF-8",
        ...r?.headers ?? {}
      }
    });
    return o.status === 200 ? {
      status: "success",
      data: await o.json()
    } : {
      status: "error",
      data: o.statusText
    };
  } catch (t) {
    return console.error("API Error:", t), {
      status: "error",
      data: `API Request failed for endpoint "${e}", follow instructions here: https://shannonhochkins.github.io/ha-component-kit/?path=/docs/core-hooks-usehass-hass-callapi--docs.`
    };
  }
}
const hr = (e, r) => {
  const { last_changed: t, last_updated: n, context: o, ...s } = e, { last_changed: i, last_updated: a, context: p, ...d } = r;
  return JSON.stringify(s) === JSON.stringify(d);
}, M = Ue((e, r) => ({
  sensorNumericDeviceClasses: [],
  setSensorNumericDeviceClasses: (t) => e({ sensorNumericDeviceClasses: t }),
  locale: null,
  setLocale: (t) => e({ locale: t }),
  routes: [],
  setRoutes: (t) => e(() => ({ routes: t })),
  entities: {},
  devices: {},
  setDevices: (t) => e(() => ({ devices: t })),
  entitiesRegistryDisplay: {},
  setEntitiesRegistryDisplay: (t) => e(() => ({ entitiesRegistryDisplay: t })),
  areas: {},
  setAreas: (t) => e(() => ({ areas: t })),
  floors: {},
  services: {},
  setServices: (t) => e(() => ({ services: t })),
  setFloors: (t) => e(() => ({ floors: t })),
  setHassUrl: (t) => e({ hassUrl: t }),
  hassUrl: null,
  hash: "",
  locales: null,
  setLocales: (t) => e({ locales: t }),
  setHash: (t) => e({ hash: t }),
  setPortalRoot: (t) => e({ portalRoot: t }),
  windowContext: window,
  setWindowContext: (t) => e({ windowContext: t }),
  setEntities: (t) => e((n) => {
    let o = !1;
    const s = { ...n.entities };
    for (const [i, a] of Object.entries(t)) {
      const p = n.entities[i];
      if (!p) {
        s[i] = a, o = !0;
        continue;
      }
      hr(p, a) || (s[i] = a, o = !0);
    }
    return o ? { entities: s, lastUpdated: Date.now(), ready: !0 } : n;
  }),
  connectionStatus: "pending",
  setConnectionStatus: (t) => e({ connectionStatus: t }),
  connection: null,
  setConnection: (t) => e({ connection: t }),
  cannotConnect: !1,
  setCannotConnect: (t) => e({ cannotConnect: t }),
  ready: !1,
  setReady: (t) => e({ ready: t }),
  auth: null,
  setAuth: (t) => e({ auth: t }),
  config: null,
  setConfig: (t) => e({ config: t }),
  user: null,
  setUser: (t) => e({ user: t }),
  users: [],
  setUsers: (t) => e({ users: t }),
  error: null,
  setError: (t) => e({ error: t }),
  globalComponentStyles: {},
  setGlobalComponentStyles: (t) => e(() => ({ globalComponentStyles: t })),
  disconnectCallbacks: [],
  onDisconnect: (t) => e((n) => ({ disconnectCallbacks: [...n.disconnectCallbacks, t] })),
  triggerOnDisconnect: () => e((t) => (t.disconnectCallbacks.forEach((n) => n()), { disconnectCallbacks: [] })),
  helpers: {
    logout() {
      const { reset: t } = B.getState(), { setError: n } = r();
      try {
        t(), Ct(), location && location.reload();
      } catch (o) {
        console.error("Error:", o), n("Unable to log out!");
      }
    },
    callService: ((t) => {
      const { domain: n, service: o, serviceData: s, target: i, returnResponse: a } = t, { connection: p, ready: d } = r(), y = typeof i == "string" || wt(i) ? { entity_id: i } : i;
      if (!p || !d)
        return a ? Promise.reject(new Error("callService: connection not established or not ready")) : void 0;
      try {
        const _ = bt(p, Ee(n), Ee(o), s ?? {}, y, a);
        return a ? _ : void 0;
      } catch (_) {
        return console.error("Error calling service:", _), a ? Promise.reject(_) : void 0;
      }
    }),
    addRoute(t) {
      const { routes: n, setRoutes: o } = r();
      if (!n.find((i) => i.hash === t.hash)) {
        const i = typeof window < "u" ? window.location.hash.replace("#", "") : "", a = i !== "" && i === t.hash;
        o([...n, { ...t, active: a }]);
      }
    },
    getRoute(t) {
      const { routes: n } = r();
      return n.find((o) => o.hash === t) || null;
    },
    getAllEntities() {
      return r().entities;
    },
    joinHassUrl(t) {
      const { connection: n } = r();
      return n ? new URL(t, n.options.auth?.data.hassUrl).toString() : "";
    },
    callApi: gr,
    dateTime: {
      shouldUseAmPm: () => {
        const { locale: t } = r();
        return t ? Gt(t) : !0;
      },
      getTimeZone() {
        const { locale: t, config: n } = r();
        return !n || !t ? "UTC" : qt(t.time_zone, n.time_zone);
      }
    }
  },
  formatter: {
    stateValue: (t) => {
      const { config: n, entitiesRegistryDisplay: o, locale: s, sensorNumericDeviceClasses: i } = r();
      return !n || !s ? "" : rn(t, n, o, s, i, t.state);
    },
    attributeValue: (t, n) => {
      const { config: o, entitiesRegistryDisplay: s, locale: i } = r();
      return !o || !i ? "" : ot(t, i, o, s, n);
    },
    ..._r()
  }
})), B = Ue((e, r) => ({
  authenticated: !1,
  setAuthenticated: (t) => e({ authenticated: t }),
  subscriptions: {},
  addSubscription: (t, n) => {
    if (!n) return;
    const o = r().subscriptions;
    if (o[t])
      try {
        o[t]();
      } catch (s) {
        process.env.NODE_ENV !== "production" && console.warn(`Failed to unsubscribe previous subscription for key '${t}'`, s);
      }
    e({ subscriptions: { ...o, [t]: n } });
  },
  removeSubscription: (t) => {
    const n = r().subscriptions;
    if (!n[t]) return;
    try {
      n[t]();
    } catch (s) {
      process.env.NODE_ENV !== "production" && console.warn(`Failed to unsubscribe subscription for key '${t}'`, s);
    }
    const o = { ...n };
    delete o[t], e({ subscriptions: o });
  },
  unsubscribeAll: () => {
    const t = r().subscriptions;
    for (const n of Object.keys(t))
      try {
        t[n]();
      } catch (o) {
        process.env.NODE_ENV !== "production" && console.warn(`Failed during mass unsubscribe for key '${n}'`, o);
      }
    e({ subscriptions: {} });
  },
  reset() {
    const { unsubscribeAll: t, setAuthenticated: n } = r(), {
      setAuth: o,
      setUser: s,
      setCannotConnect: i,
      setConfig: a,
      setConnection: p,
      setEntities: d,
      setError: y,
      setReady: _,
      setRoutes: P,
      setConnectionStatus: x
    } = M.getState();
    o(null), P([]), _(!1), p(null), d({}), a(null), y(null), i(!1), s(null), x("pending"), n(!1), t();
  }
})), Yn = [
  "routes",
  "setRoutes",
  "entities",
  "hassUrl",
  "hash",
  "setHash",
  "locales",
  "portalRoot",
  "windowContext",
  "setWindowContext",
  "connectionStatus",
  "connection",
  "ready",
  "auth",
  "config",
  "user",
  "users",
  "globalComponentStyles",
  "setGlobalComponentStyles",
  "entitiesRegistryDisplay",
  "services",
  "areas",
  "devices",
  "floors",
  "services",
  "formatter",
  "helpers",
  "locale",
  "sensorNumericDeviceClasses"
], Hn = M, ne = M, V = {};
function vr(e) {
  Object.assign(V, e);
}
function j(e, r) {
  const { search: t, replace: n, fallback: o } = r ?? {};
  return V[e] ? typeof t == "string" && typeof n == "string" ? V[e].replace(`${t}`, n).trim() : V[e] : o || e;
}
function zn() {
  return V;
}
const Bn = (e, r) => {
  const { fallback: t = j("unknown") } = r ?? {}, [n, o] = Ie(t), s = ne((a) => a.config), i = ne((a) => a.locale);
  return Y(() => {
    (async () => {
      const p = s?.language, d = de.find((y) => y.code === i?.language || y.code === p);
      if (d) {
        const y = await d.fetch();
        o(y[e] ?? t);
      }
    })();
  }, [e, t, i, s]), n;
}, Sr = [{ type: "device" }, { type: "entity" }], br = " ";
function Vn(e) {
  const r = U(e.entity_id), t = e.state;
  if (["button", "event", "input_button", "scene"].includes(r))
    return t !== Ve;
  if (tr(t) || t === rr && r !== "alert")
    return !1;
  switch (r) {
    case "alarm_control_panel":
      return t !== "disarmed";
    case "alert":
      return t !== "idle";
    case "cover":
      return t !== "closed";
    case "device_tracker":
    case "person":
      return t !== "not_home";
    case "lawn_mower":
      return ["mowing", "error"].includes(t);
    case "lock":
      return t !== "locked";
    case "media_player":
      return t !== "standby";
    case "vacuum":
      return !["idle", "docked", "paused"].includes(t);
    case "plant":
      return t === "problem";
    case "group":
      return ["on", "home", "open", "locked", "problem"].includes(t);
    case "timer":
      return t === "active";
    case "camera":
      return t === "streaming";
  }
  return !0;
}
const Er = (e) => e.substr(e.indexOf(".") + 1), Dr = (e, r) => r?.friendly_name === void 0 ? Er(e).replace(/_/g, " ") : r.friendly_name || "", G = (e) => Dr(e.entity_id, e.attributes), Tr = (e, r, t, n, o) => {
  const s = r[e.entity_id];
  return s ? Cr(s, r, t, n, o) : {
    entity: null,
    device: null,
    area: null,
    floor: null
  };
}, Cr = (e, r, t, n, o) => {
  const s = r[e.entity_id], i = e?.device_id, a = i ? t[i] : void 0, p = e?.area_id || a?.area_id, d = p ? n[p] : void 0, y = d?.floor_id, _ = y ? o[y] : void 0;
  return {
    entity: s,
    device: a || null,
    area: d || null,
    floor: _ || null
  };
}, Rr = (e, r, t) => he(e) || t && qr(r, t) || j("unnamed_device"), he = (e) => (e.name_by_user || e.name)?.trim(), Je = (e, r, t) => {
  const n = r[e.entity_id];
  return n ? wr(n, t) : G(e);
}, wr = (e, r, t) => {
  const n = e.name || ("original_name" in e && e.original_name != null ? String(e.original_name) : void 0), o = e.device_id ? r[e.device_id] : void 0;
  if (!o)
    return n || (t ? G(t) : void 0);
  const s = he(o);
  if (s !== n)
    return s && n && ar(n, s) || n;
}, Pr = (e) => e.name?.trim(), Xe = (e) => e.name?.trim(), Ze = (e, r, t, n, o, s) => {
  const { device: i, area: a, floor: p } = Tr(e, t, n, o, s);
  return r.map((y) => {
    switch (y.type) {
      case "entity":
        return Je(e, t, n);
      case "device":
        return i ? he(i) : void 0;
      case "area":
        return a ? Xe(a) : void 0;
      case "floor":
        return p ? Pr(p) : void 0;
      case "text":
        return y.text;
      default:
        return "";
    }
  });
}, Ar = (e, r, t) => !Je(e, r, t), qn = (e, r, t, n, o, s, i) => {
  let a = Array.isArray(r) ? r : r ? [r] : Sr;
  const p = i?.separator ?? br;
  if (a.every((_) => _.type === "text"))
    return a.map((_) => _.text).join(p);
  Ar(e, t, n) && (a.some((P) => P.type === "device") || (a = a.map((P) => P.type === "entity" ? { type: "device" } : P)));
  const y = Ze(e, a, t, n, o, s);
  return y.length === 1 ? y[0] || "" : y.filter((_) => _).join(p);
};
var ee = { exports: {} }, T = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Re;
function Nr() {
  if (Re) return T;
  Re = 1;
  var e = typeof Symbol == "function" && Symbol.for, r = e ? Symbol.for("react.element") : 60103, t = e ? Symbol.for("react.portal") : 60106, n = e ? Symbol.for("react.fragment") : 60107, o = e ? Symbol.for("react.strict_mode") : 60108, s = e ? Symbol.for("react.profiler") : 60114, i = e ? Symbol.for("react.provider") : 60109, a = e ? Symbol.for("react.context") : 60110, p = e ? Symbol.for("react.async_mode") : 60111, d = e ? Symbol.for("react.concurrent_mode") : 60111, y = e ? Symbol.for("react.forward_ref") : 60112, _ = e ? Symbol.for("react.suspense") : 60113, P = e ? Symbol.for("react.suspense_list") : 60120, x = e ? Symbol.for("react.memo") : 60115, b = e ? Symbol.for("react.lazy") : 60116, w = e ? Symbol.for("react.block") : 60121, m = e ? Symbol.for("react.fundamental") : 60117, E = e ? Symbol.for("react.responder") : 60118, $ = e ? Symbol.for("react.scope") : 60119;
  function v(c) {
    if (typeof c == "object" && c !== null) {
      var R = c.$$typeof;
      switch (R) {
        case r:
          switch (c = c.type, c) {
            case p:
            case d:
            case n:
            case s:
            case o:
            case _:
              return c;
            default:
              switch (c = c && c.$$typeof, c) {
                case a:
                case y:
                case b:
                case x:
                case i:
                  return c;
                default:
                  return R;
              }
          }
        case t:
          return R;
      }
    }
  }
  function S(c) {
    return v(c) === d;
  }
  return T.AsyncMode = p, T.ConcurrentMode = d, T.ContextConsumer = a, T.ContextProvider = i, T.Element = r, T.ForwardRef = y, T.Fragment = n, T.Lazy = b, T.Memo = x, T.Portal = t, T.Profiler = s, T.StrictMode = o, T.Suspense = _, T.isAsyncMode = function(c) {
    return S(c) || v(c) === p;
  }, T.isConcurrentMode = S, T.isContextConsumer = function(c) {
    return v(c) === a;
  }, T.isContextProvider = function(c) {
    return v(c) === i;
  }, T.isElement = function(c) {
    return typeof c == "object" && c !== null && c.$$typeof === r;
  }, T.isForwardRef = function(c) {
    return v(c) === y;
  }, T.isFragment = function(c) {
    return v(c) === n;
  }, T.isLazy = function(c) {
    return v(c) === b;
  }, T.isMemo = function(c) {
    return v(c) === x;
  }, T.isPortal = function(c) {
    return v(c) === t;
  }, T.isProfiler = function(c) {
    return v(c) === s;
  }, T.isStrictMode = function(c) {
    return v(c) === o;
  }, T.isSuspense = function(c) {
    return v(c) === _;
  }, T.isValidElementType = function(c) {
    return typeof c == "string" || typeof c == "function" || c === n || c === d || c === s || c === o || c === _ || c === P || typeof c == "object" && c !== null && (c.$$typeof === b || c.$$typeof === x || c.$$typeof === i || c.$$typeof === a || c.$$typeof === y || c.$$typeof === m || c.$$typeof === E || c.$$typeof === $ || c.$$typeof === w);
  }, T.typeOf = v, T;
}
var C = {};
/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var we;
function xr() {
  return we || (we = 1, process.env.NODE_ENV !== "production" && (function() {
    var e = typeof Symbol == "function" && Symbol.for, r = e ? Symbol.for("react.element") : 60103, t = e ? Symbol.for("react.portal") : 60106, n = e ? Symbol.for("react.fragment") : 60107, o = e ? Symbol.for("react.strict_mode") : 60108, s = e ? Symbol.for("react.profiler") : 60114, i = e ? Symbol.for("react.provider") : 60109, a = e ? Symbol.for("react.context") : 60110, p = e ? Symbol.for("react.async_mode") : 60111, d = e ? Symbol.for("react.concurrent_mode") : 60111, y = e ? Symbol.for("react.forward_ref") : 60112, _ = e ? Symbol.for("react.suspense") : 60113, P = e ? Symbol.for("react.suspense_list") : 60120, x = e ? Symbol.for("react.memo") : 60115, b = e ? Symbol.for("react.lazy") : 60116, w = e ? Symbol.for("react.block") : 60121, m = e ? Symbol.for("react.fundamental") : 60117, E = e ? Symbol.for("react.responder") : 60118, $ = e ? Symbol.for("react.scope") : 60119;
    function v(h) {
      return typeof h == "string" || typeof h == "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
      h === n || h === d || h === s || h === o || h === _ || h === P || typeof h == "object" && h !== null && (h.$$typeof === b || h.$$typeof === x || h.$$typeof === i || h.$$typeof === a || h.$$typeof === y || h.$$typeof === m || h.$$typeof === E || h.$$typeof === $ || h.$$typeof === w);
    }
    function S(h) {
      if (typeof h == "object" && h !== null) {
        var ue = h.$$typeof;
        switch (ue) {
          case r:
            var Z = h.type;
            switch (Z) {
              case p:
              case d:
              case n:
              case s:
              case o:
              case _:
                return Z;
              default:
                var Se = Z && Z.$$typeof;
                switch (Se) {
                  case a:
                  case y:
                  case b:
                  case x:
                  case i:
                    return Se;
                  default:
                    return ue;
                }
            }
          case t:
            return ue;
        }
      }
    }
    var c = p, R = d, L = a, I = i, g = r, u = y, f = n, l = b, ie = x, K = t, se = s, z = o, W = _, J = !1;
    function ae(h) {
      return J || (J = !0, console.warn("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.")), X(h) || S(h) === p;
    }
    function X(h) {
      return S(h) === d;
    }
    function ce(h) {
      return S(h) === a;
    }
    function D(h) {
      return S(h) === i;
    }
    function O(h) {
      return typeof h == "object" && h !== null && h.$$typeof === r;
    }
    function A(h) {
      return S(h) === y;
    }
    function it(h) {
      return S(h) === n;
    }
    function st(h) {
      return S(h) === b;
    }
    function at(h) {
      return S(h) === x;
    }
    function ct(h) {
      return S(h) === t;
    }
    function ut(h) {
      return S(h) === s;
    }
    function ft(h) {
      return S(h) === o;
    }
    function lt(h) {
      return S(h) === _;
    }
    C.AsyncMode = c, C.ConcurrentMode = R, C.ContextConsumer = L, C.ContextProvider = I, C.Element = g, C.ForwardRef = u, C.Fragment = f, C.Lazy = l, C.Memo = ie, C.Portal = K, C.Profiler = se, C.StrictMode = z, C.Suspense = W, C.isAsyncMode = ae, C.isConcurrentMode = X, C.isContextConsumer = ce, C.isContextProvider = D, C.isElement = O, C.isForwardRef = A, C.isFragment = it, C.isLazy = st, C.isMemo = at, C.isPortal = ct, C.isProfiler = ut, C.isStrictMode = ft, C.isSuspense = lt, C.isValidElementType = v, C.typeOf = S;
  })()), C;
}
var Pe;
function Wr() {
  return Pe || (Pe = 1, process.env.NODE_ENV === "production" ? ee.exports = Nr() : ee.exports = xr()), ee.exports;
}
var fe, Ae;
function Or() {
  if (Ae) return fe;
  Ae = 1;
  var e = Wr(), r = {
    childContextTypes: !0,
    contextType: !0,
    contextTypes: !0,
    defaultProps: !0,
    displayName: !0,
    getDefaultProps: !0,
    getDerivedStateFromError: !0,
    getDerivedStateFromProps: !0,
    mixins: !0,
    propTypes: !0,
    type: !0
  }, t = {
    name: !0,
    length: !0,
    prototype: !0,
    caller: !0,
    callee: !0,
    arguments: !0,
    arity: !0
  }, n = {
    $$typeof: !0,
    render: !0,
    defaultProps: !0,
    displayName: !0,
    propTypes: !0
  }, o = {
    $$typeof: !0,
    compare: !0,
    defaultProps: !0,
    displayName: !0,
    propTypes: !0,
    type: !0
  }, s = {};
  s[e.ForwardRef] = n, s[e.Memo] = o;
  function i(b) {
    return e.isMemo(b) ? o : s[b.$$typeof] || r;
  }
  var a = Object.defineProperty, p = Object.getOwnPropertyNames, d = Object.getOwnPropertySymbols, y = Object.getOwnPropertyDescriptor, _ = Object.getPrototypeOf, P = Object.prototype;
  function x(b, w, m) {
    if (typeof w != "string") {
      if (P) {
        var E = _(w);
        E && E !== P && x(b, E, m);
      }
      var $ = p(w);
      d && ($ = $.concat(d(w)));
      for (var v = i(b), S = i(w), c = 0; c < $.length; ++c) {
        var R = $[c];
        if (!t[R] && !(m && m[R]) && !(S && S[R]) && !(v && v[R])) {
          var L = y(w, R);
          try {
            a(b, R, L);
          } catch {
          }
        }
      }
    }
    return b;
  }
  return fe = x, fe;
}
Or();
var Mr = function(r) {
  return r();
}, $r = H.useInsertionEffect ? H.useInsertionEffect : !1, Lr = $r || Mr, Qe = /* @__PURE__ */ H.createContext(
  // we're doing this to avoid preconstruct's dead code elimination in this one case
  // because this module is primarily intended for the browser and node
  // but it's also required in react native and similar environments sometimes
  // and we could have a special build just for that
  // but this is much easier and the native packages
  // might use a different theme context in the future anyway
  typeof HTMLElement < "u" ? /* @__PURE__ */ _t({
    key: "css"
  }) : null
);
Qe.Provider;
var Ir = function(r) {
  return /* @__PURE__ */ dt(function(t, n) {
    var o = pt(Qe);
    return r(t, o, n);
  });
}, kr = /* @__PURE__ */ H.createContext({}), oe = {}.hasOwnProperty, ye = "__EMOTION_TYPE_PLEASE_DO_NOT_USE__", et = function(r, t) {
  var n = {};
  for (var o in t)
    oe.call(t, o) && (n[o] = t[o]);
  return n[ye] = r, n;
}, Fr = function(r) {
  var t = r.cache, n = r.serialized, o = r.isStringTag;
  return ht(t, n, o), Lr(function() {
    return vt(t, n, o);
  }), null;
}, Ur = /* @__PURE__ */ Ir(function(e, r, t) {
  var n = e.css;
  typeof n == "string" && r.registered[n] !== void 0 && (n = r.registered[n]);
  var o = e[ye], s = [n], i = "";
  typeof e.className == "string" ? i = gt(r.registered, s, e.className) : e.className != null && (i = e.className + " ");
  var a = St(s, void 0, H.useContext(kr));
  i += r.key + "-" + a.name;
  var p = {};
  for (var d in e)
    oe.call(e, d) && d !== "css" && d !== ye && (p[d] = e[d]);
  return p.className = i, t && (p.ref = t), /* @__PURE__ */ H.createElement(H.Fragment, null, /* @__PURE__ */ H.createElement(Fr, {
    cache: r,
    serialized: a,
    isStringTag: typeof o == "string"
  }), /* @__PURE__ */ H.createElement(o, p));
}), tt = Ur, Ne = q.Fragment, k = function(r, t, n) {
  return oe.call(t, "css") ? q.jsx(tt, et(r, t), n) : q.jsx(r, t, n);
}, ve = function(r, t, n) {
  return oe.call(t, "css") ? q.jsxs(tt, et(r, t), n) : q.jsxs(r, t, n);
};
const xe = (e) => Symbol.iterator in e, We = (e) => (
  // HACK: avoid checking entries type
  "entries" in e
), Oe = (e, r) => {
  const t = e instanceof Map ? e : new Map(e.entries()), n = r instanceof Map ? r : new Map(r.entries());
  if (t.size !== n.size)
    return !1;
  for (const [o, s] of t)
    if (!n.has(o) || !Object.is(s, n.get(o)))
      return !1;
  return !0;
}, jr = (e, r) => {
  const t = e[Symbol.iterator](), n = r[Symbol.iterator]();
  let o = t.next(), s = n.next();
  for (; !o.done && !s.done; ) {
    if (!Object.is(o.value, s.value))
      return !1;
    o = t.next(), s = n.next();
  }
  return !!o.done && !!s.done;
};
function Yr(e, r) {
  return Object.is(e, r) ? !0 : typeof e != "object" || e === null || typeof r != "object" || r === null || Object.getPrototypeOf(e) !== Object.getPrototypeOf(r) ? !1 : xe(e) && xe(r) ? We(e) && We(r) ? Oe(e, r) : jr(e, r) : Oe(
    { entries: () => Object.entries(e) },
    { entries: () => Object.entries(r) }
  );
}
function Hr(e) {
  const r = mt.useRef(void 0);
  return (t) => {
    const n = e(t);
    return Yr(r.current, n) ? r.current : r.current = n;
  };
}
function zr() {
  const e = ne((r) => r.config);
  return ke(() => e, [e]);
}
const rt = (e) => e.sendMessagePromise({ type: "config/device_registry/list" }), Br = (e, r) => e.subscribeEvents(
  je(() => rt(e).then((t) => r.setState(t, !0)), 500, { leading: !0, trailing: !0 }),
  "device_registry_updated"
), Vr = (e, r) => Fe("_dr", rt, Br, e, r), qr = (e, r) => {
  for (const t of r || []) {
    const n = typeof t == "string" ? t : t.entity_id, o = e[n];
    if (o)
      return G(o);
  }
}, Gn = (e, r) => e.filter((t) => t.area_id === r), Kn = (e, r, t) => e.sendMessagePromise({ type: "config/device_registry/update", device_id: r, ...t }), Jn = (e, r, t) => e.sendMessagePromise({
  type: "config/device_registry/remove_config_entry",
  device_id: r,
  config_entry_id: t
}), Xn = (e, r) => e.sort((t, n) => qe(t.name || "", n.name || "", r)), Zn = (e) => {
  const r = {};
  for (const t of e)
    t.device_id && (t.device_id in r || (r[t.device_id] = []), r[t.device_id].push(t));
  return r;
}, Gr = (e) => {
  const r = {};
  for (const t of e)
    t.device_id && (t.device_id in r || (r[t.device_id] = []), r[t.device_id].push(t));
  return r;
}, Qn = (e, r, t, n) => {
  const o = {};
  for (const s of r) {
    const i = e[s.entity_id];
    !i?.domain || s.device_id === null || (o[s.device_id] = o[s.device_id] || /* @__PURE__ */ new Set(), o[s.device_id].add(i.domain));
  }
  if (t && n)
    for (const s of t)
      for (const i of s.config_entries) {
        const a = n.find((p) => p.entry_id === i);
        a?.domain && (o[s.id] = o[s.id] || /* @__PURE__ */ new Set(), o[s.id].add(a.domain));
      }
  return o;
}, Kr = (e, r, t) => {
  const n = e.area_id, o = n ? r[n] : void 0, s = o?.floor_id, i = s ? t[s] : void 0;
  return {
    device: e,
    area: o || null,
    floor: i || null
  };
}, eo = (e, r, t, n, o, s, i, a, p, d, y, _, P, x = "") => {
  const b = Object.values(o), w = Object.values(n);
  let m = {};
  (i || a || p || y) && (m = Gr(w));
  let E = b.filter((v) => v.id === P || !v.disabled_by);
  return i && (E = E.filter((v) => {
    const S = m[v.id];
    return !S || !S.length ? !1 : m[v.id].some((c) => i.includes(U(c.entity_id)));
  })), a && (E = E.filter((v) => {
    const S = m[v.id];
    return !S || !S.length ? !0 : w.every((c) => !a.includes(U(c.entity_id)));
  })), _ && (E = E.filter((v) => !_.includes(v.id))), p && (E = E.filter((v) => {
    const S = m[v.id];
    return !S || !S.length ? !1 : m[v.id].some((c) => {
      const R = e[c.entity_id];
      return R ? R.attributes.device_class && p.includes(R.attributes.device_class) : !1;
    });
  })), y && (E = E.filter((v) => {
    const S = m[v.id];
    return !S || !S.length ? !1 : S.some((c) => {
      const R = e[c.entity_id];
      return R ? y(R) : !1;
    });
  })), d && (E = E.filter(
    (v) => (
      // We always want to include the device of the current value
      v.id === P || d(v)
    )
  )), E.map((v) => {
    const S = Rr(v, e, m[v.id]), { area: c } = Kr(v, r, t), R = c ? Xe(c) : void 0, L = v.primary_config_entry ? s?.[v.primary_config_entry] : void 0, I = L?.domain, g = I ? j(`${I}.title`, {
      fallback: I
    }) : void 0;
    return {
      id: `${x}${v.id}`,
      label: "",
      primary: S || j("unnamed_device"),
      secondary: R,
      domain: L?.domain,
      domain_name: g,
      search_labels: [S, R, I, g].filter(Boolean),
      sorting_label: S || "zzz"
    };
  });
}, le = ["sensor", "binary_sensor"], to = (e, r) => {
  const t = r.filter(
    (n) => e[n.entity_id] && e[n.entity_id].attributes.device_class === "battery" && le.includes(U(n.entity_id))
  ).sort(
    (n, o) => le.indexOf(U(n.entity_id)) - le.indexOf(U(o.entity_id))
  );
  if (t.length > 0)
    return t[0];
}, ro = (e, r) => r.find(
  (t) => e[t.entity_id] && e[t.entity_id].attributes.device_class === "battery_charging"
), no = (e, r) => {
  if (r.name)
    return r.name;
  const t = e[r.entity_id];
  return t ? G(t) : r.original_name ? r.original_name : r.entity_id;
}, oo = (e, r) => e.sendMessagePromise({
  type: "config/entity_registry/get",
  entity_id: r
}), io = (e, r) => e.sendMessagePromise({
  type: "config/entity_registry/get_entries",
  entity_ids: r
}), so = (e, r, t) => e.sendMessagePromise({
  type: "config/entity_registry/update",
  entity_id: r,
  ...t
}), ao = (e, r) => e.sendMessagePromise({
  type: "config/entity_registry/remove",
  entity_id: r
}), nt = (e) => e.sendMessagePromise({
  type: "config/entity_registry/list_for_display"
}), Jr = (e, r) => e.subscribeEvents(
  je(() => nt(e).then((t) => r.setState(t, !0)), 500, {
    leading: !0,
    trailing: !0
  }),
  "entity_registry_updated"
), Xr = (e, r) => Fe(
  "_entityRegistryDisplay",
  nt,
  Jr,
  e,
  r
), co = (e, r) => e.sort((t, n) => qe(t.name || "", n.name || "", r)), uo = (e) => {
  const r = {};
  for (const t of e)
    r[t.entity_id] = t;
  return r;
}, fo = (e) => {
  const r = {};
  for (const t of e)
    r[t.id] = t;
  return r;
}, lo = (e) => {
  const r = {};
  for (const t of e)
    t.platform && (r[t.entity_id] = t.platform);
  return r;
}, mo = (e, r) => e.sendMessagePromise({
  type: "config/entity_registry/get_automatic_entity_ids",
  entity_ids: r
}), po = (e, r, t, n, o, s, i, a, p, d, y, _, P, x = "") => {
  let b = [], w = Object.keys(e);
  return y && (w = w.filter((m) => y.includes(m))), _ && (w = w.filter((m) => !_.includes(m))), s && (w = w.filter((m) => s.includes(U(m)))), i && (w = w.filter((m) => !i.includes(U(m)))), b = w.map((m) => {
    const E = e[m], $ = G(E), [v, S, c] = Ze(
      E,
      [{ type: "entity" }, { type: "device" }, { type: "area" }],
      r,
      t,
      n,
      o
    ), R = U(m), L = j(`${R}.title`, {
      fallback: j(R)
    }), I = v || S || m, g = [c, v ? S : void 0].filter(Boolean).join(" ▸ ");
    return {
      id: `${x}${m}`,
      primary: I,
      secondary: g,
      domain_name: L,
      sorting_label: [S, v].filter(Boolean).join("_"),
      search_labels: [v, S, c, L, $, m].filter(Boolean),
      stateObj: E
    };
  }), p && (b = b.filter(
    (m) => (
      // We always want to include the entity of the current value
      m.id === P || m.stateObj?.attributes.device_class && p.includes(m.stateObj.attributes.device_class)
    )
  )), d && (b = b.filter(
    (m) => (
      // We always want to include the entity of the current value
      m.id === P || m.stateObj?.attributes.unit_of_measurement && d.includes(m.stateObj.attributes.unit_of_measurement)
    )
  )), a && (b = b.filter(
    (m) => (
      // We always want to include the entity of the current value
      m.id === P || m.stateObj && a(m.stateObj)
    )
  )), b;
}, Zr = /* @__PURE__ */ new Set([
  "temperature",
  "current_temperature",
  "target_temperature",
  "target_temp_temp",
  "target_temp_high",
  "target_temp_low",
  "target_temp_step",
  "min_temp",
  "max_temp"
]), Qr = {
  light: {
    brightness: (e) => Math.round(e / 255 * 100).toString()
  },
  media_player: {
    volume_level: (e) => Math.round(e * 100).toString(),
    media_duration: (e) => ze(e.toString(), "s")
  }
}, en = {
  climate: {
    humidity: "%",
    current_humidity: "%",
    target_humidity_low: "%",
    target_humidity_high: "%",
    target_humidity_step: "%",
    min_humidity: "%",
    max_humidity: "%"
  },
  cover: {
    current_position: "%",
    current_tilt_position: "%"
  },
  fan: {
    percentage: "%"
  },
  humidifier: {
    humidity: "%",
    current_humidity: "%",
    min_humidity: "%",
    max_humidity: "%"
  },
  light: {
    color_temp: "mired",
    max_mireds: "mired",
    min_mireds: "mired",
    color_temp_kelvin: "K",
    min_color_temp_kelvin: "K",
    max_color_temp_kelvin: "K",
    brightness: "%"
  },
  sun: {
    azimuth: "°",
    elevation: "°"
  },
  vacuum: {
    battery_level: "%"
  },
  valve: {
    current_position: "%"
  },
  sensor: {
    battery_level: "%"
  },
  media_player: {
    volume_level: "%"
  }
}, tn = (e, r, t) => {
  const n = e.unit_system.length || "";
  switch (t) {
    case "visibility":
      return r.attributes.visibility_unit || n;
    case "precipitation":
      return r.attributes.precipitation_unit || (n === "km" ? "mm" : "in");
    case "pressure":
      return r.attributes.pressure_unit || (n === "km" ? "hPa" : "inHg");
    case "temperature":
    case "templow":
      return r.attributes.temperature_unit || e.unit_system.temperature;
    case "wind_speed":
      return r.attributes.wind_speed_unit || `${n}/h`;
    case "humidity":
    case "precipitation_probability":
      return "%";
    default: {
      const o = e.unit_system;
      return t in o ? o[t] : "";
    }
  }
}, ot = (e, r, t, n, o, s) => {
  const i = s !== void 0 ? s : e.attributes[o];
  if (i == null)
    return j("unknown");
  if (typeof i == "number") {
    const a = U(e.entity_id), p = Qr[a]?.[o], d = p ? p(i) : pe(i);
    let _ = en[a]?.[o];
    return a === "weather" ? _ = tn(t, e, o) : Zr.has(o) && (_ = t.unit_system.temperature), _ ? `${d}${er(_, r)}${_}` : d;
  }
  if (typeof i == "string" && Kt(i, !0)) {
    if (Jt(i)) {
      const p = new Date(i);
      if (Te(p))
        return Ye(p, r, t);
    }
    const a = new Date(i);
    if (Te(a))
      return _e(a, t, r);
  }
  return Array.isArray(i) && i.some((a) => a instanceof Object) || !Array.isArray(i) && i instanceof Object ? JSON.stringify(i) : Array.isArray(i) ? i.map((a) => ot(e, r, t, n, o, a)).join(", ") : j(i);
}, rn = (e, r, t, n, o, s) => {
  const i = t?.[e.entity_id];
  return nn(
    n,
    o,
    r,
    i,
    e.entity_id,
    e.attributes,
    s !== void 0 ? s : e.state
  );
}, nn = (e, r, t, n, o, s, i) => {
  if (i === nr || i === Ve)
    return j(i);
  const a = U(o), p = a === "counter" || a === "number" || a === "input_number";
  if (Qt(s, a === "sensor" ? r : []) || p) {
    const d = s.unit_of_measurement;
    if (s.device_class === "duration" && s.unit_of_measurement && Xt[d] && n?.display_precision === void 0)
      try {
        return ze(i, d);
      } catch {
      }
    if (s.device_class === "monetary")
      try {
        return pe(i, {
          style: "currency",
          currency: s.unit_of_measurement,
          minimumFractionDigits: 2,
          // Override monetary options with number format
          ...Ce({ state: i, attributes: s }, n)
        });
      } catch {
      }
    const y = pe(i, Ce({ state: i, attributes: s }, n)), _ = s.unit_of_measurement;
    return _ ? `${y}${_}` : y;
  }
  if (["date", "input_datetime", "time"].includes(a))
    try {
      const d = i.split(" ");
      if (d.length === 2)
        return e ? re(new Date(d.join("T")), t, e) : new Date(d.join("T")).toLocaleString();
      if (d.length === 1) {
        if (i.includes("-"))
          return e ? _e(/* @__PURE__ */ new Date(`${i}T00:00`), t, e) : (/* @__PURE__ */ new Date(`${i}T00:00`)).toLocaleDateString();
        if (i.includes(":")) {
          const y = /* @__PURE__ */ new Date();
          return e ? He(/* @__PURE__ */ new Date(`${y.toISOString().split("T")[0]}T${i}`), t, e) : (/* @__PURE__ */ new Date(`${y.toISOString().split("T")[0]}T${i}`)).toLocaleTimeString();
        }
      }
      return i;
    } catch {
      return i;
    }
  if ([
    "ai_task",
    "button",
    "conversation",
    "event",
    "image",
    "input_button",
    "notify",
    "scene",
    "stt",
    "tag",
    "tts",
    "wake_word",
    "datetime"
  ].includes(a) || a === "sensor" && s.device_class === "timestamp")
    try {
      return e ? re(new Date(i), t, e) : new Date(i).toLocaleString();
    } catch {
      return i;
    }
  if (["button", "conversation", "event", "image", "input_button", "notify", "scene", "stt", "tag", "tts", "wake_word"].includes(a) || a === "sensor" && s.device_class === "timestamp")
    try {
      return e ? re(new Date(i), t, e) : new Date(i).toLocaleString();
    } catch {
      return i;
    }
  return j(i);
}, Me = /* @__PURE__ */ new Set();
function on({
  children: e,
  hassUrl: r,
  hassToken: t,
  portalRoot: n,
  windowContext: o,
  renderError: s = (a) => a,
  handleResumeOptions: i
}) {
  const a = B((m) => m.addSubscription), p = B((m) => m.setAuthenticated), {
    hash: d,
    ready: y,
    error: _,
    cannotConnect: P,
    setError: x
  } = M(
    Hr((m) => ({
      hash: m.hash,
      routes: m.routes,
      ready: m.ready,
      // ready is set internally in the store when we have entities (setEntities does this)
      error: m.error,
      cannotConnect: m.cannotConnect,
      auth: m.auth,
      setError: m.setError
    }))
  );
  Y(() => {
    const { setPortalRoot: m } = M.getState();
    n && m(n);
  }, [n]), Y(() => {
    const { setWindowContext: m } = M.getState();
    o && m(o);
  }, [o]);
  const b = be(async () => {
    const {
      setError: m,
      setUser: E,
      setCannotConnect: $,
      setAuth: v,
      setConnection: S,
      setEntities: c,
      setConfig: R,
      setConnectionStatus: L,
      setAreas: I,
      setDevices: g,
      setFloors: u,
      setEntitiesRegistryDisplay: f,
      setServices: l,
      setUsers: ie,
      setLocale: K,
      setSensorNumericDeviceClasses: se
    } = M.getState(), z = await ir(r, t);
    if (z.type === "error")
      p(!1), m(z.error);
    else if (z.type === "failed")
      p(!1), $(!0);
    else if (z.type === "success") {
      const { connection: W, auth: J } = z;
      v(J), S(W), a(
        "entities",
        Et(W, (D) => {
          c(D);
        })
      ), a(
        "entity_registry_display",
        Xr(W, (D) => {
          const O = {};
          for (const A of D.entities)
            O[A.ei] = {
              entity_id: A.ei,
              device_id: A.di,
              area_id: A.ai,
              labels: A.lb,
              translation_key: A.tk,
              platform: A.pl,
              entity_category: A.ec !== void 0 ? D.entity_categories[A.ec] : void 0,
              has_entity_name: A.hn,
              name: A.en,
              icon: A.ic,
              hidden: A.hb,
              display_precision: A.dp
            };
          f(O);
        })
      ), a(
        "areas",
        cr(W, (D) => {
          const O = {};
          for (const A of D)
            O[A.area_id] = A;
          I(O);
        })
      ), a(
        "devices",
        Vr(W, (D) => {
          const O = {};
          for (const A of D)
            O[A.id] = A;
          g(O);
        })
      ), a(
        "floors",
        ur(W, (D) => {
          const O = {};
          for (const A of D)
            O[A.floor_id] = A;
          u(O);
        })
      ), a(
        "config",
        Dt(W, (D) => {
          R(D);
        })
      ), a(
        "current_user",
        mr(W, (D) => {
          E(D);
        })
      ), a(
        "services",
        Tt(W, (D) => {
          l(D);
        })
      ), a(
        "users",
        dr(W, (D) => {
          ie(D);
        })
      ), a(
        "language",
        await fr(W, "language", (D) => {
          if (D.value) {
            const O = lr(D.value);
            K({
              ...D.value,
              language: O
            });
          } else
            K(D.value);
        })
      ), W.sendMessagePromise({
        type: "sensor/numeric_device_classes"
      }).then((D) => {
        se(D.numeric_device_classes);
      });
      const { onStatusChange: ae, ...X } = i || {}, ce = or(W, {
        suspendWhenHidden: !0,
        hiddenDelayMs: 3e5,
        // 5 minutes
        debug: !1,
        onStatusChange: (D) => {
          L(D), ae?.(D);
        },
        ...X
      });
      a("resume", ce);
    }
  }, [r, t, i, a, p]);
  Y(() => {
    const { setHassUrl: m } = M.getState();
    m(r);
  }, [r]), Y(() => {
    const { setHash: m } = M.getState();
    location.hash !== "" && location.hash.replace("#", "") !== d && m(location.hash);
  }, [d]), Y(() => (window.addEventListener("hashchange", $e), () => {
    window.removeEventListener("hashchange", $e);
  }), []), Y(() => () => B.getState().reset(), []);
  const w = be(async () => {
    if (!Me.has(r)) {
      Me.add(r);
      try {
        B.getState().authenticated && M.getState().hassUrl !== r && B.getState().reset(), p(!0), i?.onStatusChange?.("pending"), await b();
      } catch (m) {
        const E = sr(m);
        x(`Unable to connect to Home Assistant, please check the URL: "${E}"`);
      }
    }
  }, [b, x, i, r, p]);
  return Y(() => {
    w();
  }, [w]), P ? s(
    /* @__PURE__ */ ve("p", { children: [
      "Unable to connect to ",
      Rt(r)?.hassUrl,
      ", refresh the page and try again, or",
      " ",
      /* @__PURE__ */ k("a", { onClick: ne.getState().helpers.logout, children: "Logout" }),
      "."
    ] })
  ) : _ === null ? e(y) : s(_);
}
function $e() {
  const { routes: e, setRoutes: r, setHash: t } = M.getState();
  r(
    e.map((n) => n.hash === location.hash.replace("#", "") ? {
      ...n,
      active: !0
    } : {
      ...n,
      active: !1
    })
  ), t(location.hash);
}
function sn({ locale: e, children: r }) {
  const t = zr(), [n, o] = Ie(!1), s = me(!1), i = me(null), a = M((d) => d.setError), p = M((d) => d.setLocales);
  return Y(() => {
    if (!(e ?? t?.language))
      return;
    const y = de.find(({ code: _ }) => _ === (e ?? t?.language));
    if (i.current !== y?.code && (o(!1), s.current = !1, a(null)), !y)
      s.current = !1, a(
        `Locale "${e ?? t?.language}" not found, available options are "${de.map(({ code: _ }) => `${_}`).join(", ")}"`
      );
    else {
      if (s.current) return;
      s.current = !0, i.current = y.code, y.fetch().then((_) => {
        s.current = !1, o(!0), vr(_), p(_);
      }).catch((_) => {
        s.current = !1, o(!0), a(`Error retrieving translations from Home Assistant: ${_?.message ?? _}`);
      });
    }
  }, [t, n, p, a, e]), n ? r : null;
}
const te = Zt`
  0% {stroke-width:0; opacity:0;}
  50% {stroke-width:5; opacity:1;}
  100% {stroke-width:0; opacity:0;}
`;
function an({ className: e }) {
  return /* @__PURE__ */ k("div", { className: e, children: /* @__PURE__ */ ve("svg", { children: [
    /* @__PURE__ */ k("path", { d: "m 12.5,20 15,0 0,0 -15,0 z" }),
    /* @__PURE__ */ k("path", { d: "m 32.5,20 15,0 0,0 -15,0 z" }),
    /* @__PURE__ */ k("path", { d: "m 52.5,20 15,0 0,0 -15,0 z" }),
    /* @__PURE__ */ k("path", { d: "m 72.5,20 15,0 0,0 -15,0 z" })
  ] }) });
}
const cn = Be(an)`
  position: fixed;
  inset: 0;
  background-color: #1a1a1a;
  svg {
    position: absolute;
    top: 50%;
    left: 50%;
    width: 6.25em;
    height: 3.125em;
    margin: -1.562em 0 0 -3.125em;
    path {
      fill: none;
      stroke: #f0c039;
      opacity: 0;
    }
    path:nth-of-type(1) {
      animation: ${te} 1s ease-in-out 0s infinite alternate;
    }
    path:nth-of-type(2) {
      animation: ${te} 1s ease-in-out 0.1s infinite alternate;
    }
    path:nth-of-type(3) {
      animation: ${te} 1s ease-in-out 0.2s infinite alternate;
    }
    path:nth-of-type(4) {
      animation: ${te} 1s ease-in-out 0.3s infinite alternate;
    }
  }
`, Le = Be.div`
  width: 100%;
  height: 100%;
`, yo = yt(function({
  children: r,
  hassUrl: t,
  hassToken: n,
  loading: o = /* @__PURE__ */ k(cn, {}),
  onReady: s,
  options: i = {},
  wrapperProps: a
}) {
  const p = me(!1), d = ke(() => {
    try {
      return new URL(t).origin;
    } catch (y) {
      return console.log("Error:", y), null;
    }
  }, [t]);
  return !d || d === "null" || d === null ? /* @__PURE__ */ k(Ne, { children: "Provide the hassUrl prop with a valid url to your home assistant instance." }) : /* @__PURE__ */ k(on, { hassUrl: d, hassToken: n, ...i, children: (y) => /* @__PURE__ */ k(Ne, { children: y ? /* @__PURE__ */ k(Le, { ...a, children: /* @__PURE__ */ ve(sn, { locale: i.locale, children: [
    s && !p.current && (s(), p.current = !0, null),
    r
  ] }) }) : /* @__PURE__ */ k(Le, { ...a, children: o }) }) });
});
export {
  Vr as $,
  io as A,
  so as B,
  ao as C,
  Sr as D,
  nt as E,
  Xr as F,
  co as G,
  yo as H,
  uo as I,
  fo as J,
  lo as K,
  mo as L,
  po as M,
  Qr as N,
  en as O,
  tn as P,
  ot as Q,
  rn as R,
  nn as S,
  Zr as T,
  zr as U,
  Hn as V,
  ne as W,
  j as X,
  Bn as Y,
  zn as Z,
  vr as _,
  In as a,
  qr as a0,
  Gn as a1,
  Kn as a2,
  Jn as a3,
  Xn as a4,
  Zn as a5,
  Gr as a6,
  Qn as a7,
  Kr as a8,
  eo as a9,
  Hr as aa,
  k as ab,
  _r as ac,
  gr as ad,
  M as ae,
  B as af,
  Yn as ag,
  on as ah,
  sn as ai,
  Ke as b,
  kn as c,
  Fn as d,
  jn as e,
  Er as f,
  Un as g,
  Dr as h,
  G as i,
  Tr as j,
  Cr as k,
  Ge as l,
  Rr as m,
  he as n,
  Je as o,
  wr as p,
  Pr as q,
  Xe as r,
  Vn as s,
  Ze as t,
  Ar as u,
  qn as v,
  to as w,
  ro as x,
  no as y,
  oo as z
};
//# sourceMappingURL=index-1tDtVGr2.js.map
