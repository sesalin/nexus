{"version":3,"file":"index.js","sources":["../../../../src/hooks/useAreas/index.ts"],"sourcesContent":["import { AreaRegistryEntry, EntityRegistryDisplayEntry, useHass } from \"@core\";\nimport { useMemo } from \"react\";\nimport type { DeviceRegistryEntry } from \"@utils/subscribe/devices\";\nimport type { HassEntity } from \"home-assistant-js-websocket\";\nimport type { FloorRegistryEntry } from \"@utils/subscribe/floors\";\n\n/**\n * Enriched area shape returned by `useAreas`.\n * Extends the raw registry entry with resolved picture URL, linked floor,\n * concrete lists of devices & entities.\n */\nexport interface Area extends AreaRegistryEntry {\n  /** Resolved (absolute) picture URL or null */\n  picture: string | null;\n  /** Devices (non-service type) whose area_id matches this area */\n  devices: DeviceRegistryEntry[];\n  /** Entities (state objects) whose area_id matches this area */\n  entities: HassEntity[];\n  /** Associated floor (null if none assigned) */\n  floor: FloorRegistryEntry | null;\n}\n\nexport function useAreas(): Area[] {\n  const { joinHassUrl } = useHass.getState().helpers;\n  const areas = useHass((state) => state.areas);\n  const devices = useHass((state) => state.devices);\n  const floors = useHass((state) => state.floors);\n  const entitiesRegistryDisplay = useHass((state) => state.entitiesRegistryDisplay);\n  const entities = useHass((state) => state.entities);\n\n  return useMemo(() => {\n    const _areas = Object.values(areas);\n    return processAreas({\n      areas: _areas,\n      devices,\n      entitiesRegistryDisplay,\n      floors,\n      joinHassUrl,\n      hassEntities: entities,\n    });\n  }, [areas, devices, joinHassUrl, entitiesRegistryDisplay, floors, entities]);\n}\ninterface ProcessAreasParams {\n  areas: AreaRegistryEntry[];\n  devices: Record<string, DeviceRegistryEntry>;\n  entitiesRegistryDisplay: Record<string, EntityRegistryDisplayEntry>;\n  floors: Record<string, FloorRegistryEntry>;\n  joinHassUrl: (path: string) => string;\n  hassEntities: Record<string, HassEntity>;\n}\n\nfunction processAreas({ areas, devices, entitiesRegistryDisplay, floors, joinHassUrl, hassEntities }: ProcessAreasParams): Area[] {\n  const processArea = (area: AreaRegistryEntry): Area => {\n    const devicesInArea: DeviceRegistryEntry[] = [];\n    for (const device of Object.values(devices)) {\n      if (device.area_id === area.area_id) {\n        if (device.entry_type !== \"service\") {\n          devicesInArea.push(device);\n        }\n      }\n    }\n\n    // Collect entities that belong to this area either directly (entity.area_id) or\n    // indirectly via the device assignment (entity.area_id unset but device.area_id matches).\n    const entitiesInAreaSet = new Set<string>();\n    const entitiesInArea: HassEntity[] = [];\n    for (const entity of Object.values(entitiesRegistryDisplay)) {\n      const directMatch = entity.area_id === area.area_id;\n      const inheritedMatch = !entity.area_id && entity.device_id && devices[entity.device_id]?.area_id === area.area_id;\n      if (directMatch || inheritedMatch) {\n        const hassEntity = hassEntities[entity.entity_id];\n        if (hassEntity && !entitiesInAreaSet.has(entity.entity_id)) {\n          entitiesInAreaSet.add(entity.entity_id);\n          entitiesInArea.push(hassEntity);\n        } else if (!hassEntity) {\n          // Registry entry exists but we have no current state object; skip silently.\n          // (Could log if needed: console.debug(`Missing state for ${entity.entity_id}`))\n        }\n      }\n    }\n\n    return {\n      ...area,\n      picture: area.picture ? joinHassUrl(area.picture) : null,\n      devices: devicesInArea,\n      entities: entitiesInArea,\n      floor: area.floor_id ? floors[area.floor_id] || null : null,\n    };\n  };\n\n  return areas.map(processArea);\n}\n"],"names":["useAreas","joinHassUrl","useHass","areas","state","devices","floors","entitiesRegistryDisplay","entities","useMemo","_areas","processAreas","hassEntities","processArea","area","devicesInArea","device","entitiesInAreaSet","entitiesInArea","entity","directMatch","inheritedMatch","hassEntity"],"mappings":"qUAsBO,SAASA,GAAmB,CACjC,KAAM,CAAE,YAAAC,CAAA,EAAgBC,UAAQ,WAAW,QACrCC,EAAQD,EAAAA,QAASE,GAAUA,EAAM,KAAK,EACtCC,EAAUH,EAAAA,QAASE,GAAUA,EAAM,OAAO,EAC1CE,EAASJ,EAAAA,QAASE,GAAUA,EAAM,MAAM,EACxCG,EAA0BL,EAAAA,QAASE,GAAUA,EAAM,uBAAuB,EAC1EI,EAAWN,EAAAA,QAASE,GAAUA,EAAM,QAAQ,EAElD,OAAOK,EAAAA,QAAQ,IAAM,CACnB,MAAMC,EAAS,OAAO,OAAOP,CAAK,EAClC,OAAOQ,EAAa,CAClB,MAAOD,EACP,QAAAL,EACA,wBAAAE,EACA,OAAAD,EACA,YAAAL,EACA,aAAcO,CAAA,CACf,CACH,EAAG,CAACL,EAAOE,EAASJ,EAAaM,EAAyBD,EAAQE,CAAQ,CAAC,CAC7E,CAUA,SAASG,EAAa,CAAE,MAAAR,EAAO,QAAAE,EAAS,wBAAAE,EAAyB,OAAAD,EAAQ,YAAAL,EAAa,aAAAW,GAA4C,CAChI,MAAMC,EAAeC,GAAkC,CACrD,MAAMC,EAAuC,CAAA,EAC7C,UAAWC,KAAU,OAAO,OAAOX,CAAO,EACpCW,EAAO,UAAYF,EAAK,SACtBE,EAAO,aAAe,WACxBD,EAAc,KAAKC,CAAM,EAO/B,MAAMC,MAAwB,IACxBC,EAA+B,CAAA,EACrC,UAAWC,KAAU,OAAO,OAAOZ,CAAuB,EAAG,CAC3D,MAAMa,EAAcD,EAAO,UAAYL,EAAK,QACtCO,EAAiB,CAACF,EAAO,SAAWA,EAAO,WAAad,EAAQc,EAAO,SAAS,GAAG,UAAYL,EAAK,QAC1G,GAAIM,GAAeC,EAAgB,CACjC,MAAMC,EAAaV,EAAaO,EAAO,SAAS,EAC5CG,GAAc,CAACL,EAAkB,IAAIE,EAAO,SAAS,IACvDF,EAAkB,IAAIE,EAAO,SAAS,EACtCD,EAAe,KAAKI,CAAU,EAKlC,CACF,CAEA,MAAO,CACL,GAAGR,EACH,QAASA,EAAK,QAAUb,EAAYa,EAAK,OAAO,EAAI,KACpD,QAASC,EACT,SAAUG,EACV,MAAOJ,EAAK,UAAWR,EAAOQ,EAAK,QAAQ,GAAK,IAAO,CAE3D,EAEA,OAAOX,EAAM,IAAIU,CAAW,CAC9B"}