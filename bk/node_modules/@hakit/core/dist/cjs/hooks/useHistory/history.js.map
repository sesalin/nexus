{"version":3,"file":"history.js","sources":["../../../../src/hooks/useHistory/history.ts"],"sourcesContent":["import { Connection, HassEntity, HassEntityAttributeBase, MessageBase } from \"home-assistant-js-websocket\";\nimport { computeDomain, computeStateNameFromEntityAttributes, localize, useHass } from \"@core\";\nimport type { EntityName } from \"@core\";\n\nconst DOMAINS_USE_LAST_UPDATED = [\"climate\", \"humidifier\", \"water_heater\"];\nconst NEED_ATTRIBUTE_DOMAINS = [\"climate\", \"humidifier\", \"input_datetime\", \"water_heater\", \"person\", \"device_tracker\"];\nconst LINE_ATTRIBUTES_TO_KEEP = [\n  \"temperature\",\n  \"current_temperature\",\n  \"target_temp_low\",\n  \"target_temp_high\",\n  \"hvac_action\",\n  \"humidity\",\n  \"mode\",\n  \"action\",\n  \"current_humidity\",\n];\n\nexport interface LineChartState {\n  state: string;\n  last_changed: number;\n  attributes?: HassEntity[\"attributes\"];\n}\n\nexport interface LineChartEntity {\n  domain: string;\n  name: string;\n  entity_id: string;\n  states: LineChartState[];\n  statistics?: LineChartState[];\n}\n\nexport interface LineChartUnit {\n  unit: string;\n  device_class?: string;\n  identifier: string;\n  data: LineChartEntity[];\n}\n\nexport interface HistoryStreamMessage {\n  states: HistoryStates;\n  start_time?: number; // Start time of this historical chunk\n  end_time?: number; // End time of this historical chunk\n}\n\nexport interface TimelineState {\n  state_localize: string;\n  state: string;\n  last_changed: number;\n}\n\nexport interface TimelineEntity {\n  name: string;\n  entity_id: string;\n  data: TimelineState[];\n}\n\nexport interface HistoryResult {\n  line: LineChartUnit[];\n  timeline: TimelineEntity[];\n}\n\nexport interface HistoryStates {\n  [entityId: string]: EntityHistoryState[];\n}\n\nexport interface EntityHistoryState {\n  /** state */\n  s: string;\n  /** attributes */\n  a: HassEntity[\"attributes\"];\n  /** last_changed; if set, also applies to lu */\n  lc?: number;\n  /** last_updated */\n  lu: number;\n}\n\nconst entityIdHistoryNeedsAttributes = (entityId: EntityName) => NEED_ATTRIBUTE_DOMAINS.includes(computeDomain(entityId));\ninterface SubscribeOptions {\n  connection: Connection;\n  entityIds: EntityName[];\n  callbackFunction: (data: HistoryStates) => void;\n  hoursToShow?: number;\n  minimalResponse?: boolean;\n  significantChangesOnly?: boolean;\n  noAttributes?: boolean;\n}\n\nexport const subscribeHistory = ({\n  connection,\n  entityIds,\n  callbackFunction,\n  hoursToShow = 24,\n  minimalResponse = true,\n  significantChangesOnly = true,\n  noAttributes,\n}: SubscribeOptions): Promise<() => Promise<void>> => {\n  const params: MessageBase = {\n    type: \"history/stream\",\n    entity_ids: entityIds,\n    start_time: new Date(new Date().getTime() - 60 * 60 * hoursToShow * 1000).toISOString(),\n    minimal_response: minimalResponse,\n    significant_changes_only: significantChangesOnly,\n    no_attributes: noAttributes ?? !entityIds.some((entityId) => entityIdHistoryNeedsAttributes(entityId)),\n  };\n  const stream = new HistoryStream(hoursToShow);\n  return connection.subscribeMessage<HistoryStreamMessage>((message) => callbackFunction(stream.processMessage(message)), params);\n};\n\nclass HistoryStream {\n  hoursToShow?: number;\n\n  combinedHistory: HistoryStates;\n\n  constructor(hoursToShow?: number) {\n    this.hoursToShow = hoursToShow;\n    this.combinedHistory = {};\n  }\n\n  processMessage(streamMessage: HistoryStreamMessage): HistoryStates {\n    if (!this.combinedHistory || !Object.keys(this.combinedHistory).length) {\n      this.combinedHistory = streamMessage.states;\n      return this.combinedHistory;\n    }\n    if (!Object.keys(streamMessage.states).length) {\n      // Empty messages are still sent to\n      // indicate no more historical events\n      return this.combinedHistory;\n    }\n    const purgeBeforePythonTime = this.hoursToShow ? (new Date().getTime() - 60 * 60 * this.hoursToShow * 1000) / 1000 : undefined;\n    const newHistory: HistoryStates = {};\n    for (const entityId of Object.keys(this.combinedHistory)) {\n      newHistory[entityId] = [];\n    }\n    for (const entityId of Object.keys(streamMessage.states)) {\n      newHistory[entityId] = [];\n    }\n    for (const entityId of Object.keys(newHistory)) {\n      if (entityId in this.combinedHistory && entityId in streamMessage.states) {\n        const entityCombinedHistory = this.combinedHistory[entityId];\n        const lastEntityCombinedHistory = entityCombinedHistory[entityCombinedHistory.length - 1];\n        newHistory[entityId] = entityCombinedHistory.concat(streamMessage.states[entityId]);\n        if (streamMessage.states[entityId][0].lu < lastEntityCombinedHistory.lu) {\n          // If the history is out of order we have to sort it.\n          newHistory[entityId] = newHistory[entityId].sort((a, b) => a.lu - b.lu);\n        }\n      } else if (entityId in this.combinedHistory) {\n        newHistory[entityId] = this.combinedHistory[entityId];\n      } else {\n        newHistory[entityId] = streamMessage.states[entityId];\n      }\n      // Remove old history\n      if (purgeBeforePythonTime && entityId in this.combinedHistory) {\n        const expiredStates = newHistory[entityId].filter((state) => state.lu < purgeBeforePythonTime);\n        if (!expiredStates.length) {\n          continue;\n        }\n        newHistory[entityId] = newHistory[entityId].filter((state) => state.lu >= purgeBeforePythonTime);\n        if (newHistory[entityId].length && newHistory[entityId][0].lu === purgeBeforePythonTime) {\n          continue;\n        }\n        // Update the first entry to the start time state\n        // as we need to preserve the start time state and\n        // only expire the rest of the history as it ages.\n        const lastExpiredState = expiredStates[expiredStates.length - 1];\n        lastExpiredState.lu = purgeBeforePythonTime;\n        newHistory[entityId].unshift(lastExpiredState);\n      }\n    }\n    this.combinedHistory = newHistory;\n    return this.combinedHistory;\n  }\n}\n\nconst equalState = (obj1: LineChartState, obj2: LineChartState) =>\n  obj1.state === obj2.state &&\n  // Only compare attributes if both states have an attributes object.\n  // When `minimal_response` is sent, only the first and last state\n  // will have attributes except for domains in DOMAINS_USE_LAST_UPDATED.\n  (!obj1.attributes || !obj2.attributes || LINE_ATTRIBUTES_TO_KEEP.every((attr) => obj1.attributes![attr] === obj2.attributes![attr]));\n\nconst processLineChartEntities = (unit: string, device_class: string | undefined, entities: HistoryStates): LineChartUnit => {\n  const hassEntities = useHass.getState().entities;\n  const data: LineChartEntity[] = [];\n\n  Object.keys(entities).forEach((entityId) => {\n    const states = entities[entityId];\n    const first: EntityHistoryState = states[0];\n    const domain = computeDomain(entityId as EntityName);\n    const processedStates: LineChartState[] = [];\n\n    for (const state of states) {\n      let processedState: LineChartState;\n\n      if (DOMAINS_USE_LAST_UPDATED.includes(domain)) {\n        processedState = {\n          state: state.s,\n          last_changed: state.lu * 1000,\n          attributes: {},\n        };\n\n        for (const attr of LINE_ATTRIBUTES_TO_KEEP) {\n          if (attr in state.a) {\n            processedState.attributes![attr] = state.a[attr];\n          }\n        }\n      } else {\n        processedState = {\n          state: state.s,\n          // lc (last_changed) may be omitted if its the same\n          // as lu (last_updated).\n          last_changed: (state.lc ? state.lc : state.lu) * 1000,\n          attributes: {},\n        };\n      }\n\n      if (\n        processedStates.length > 1 &&\n        equalState(processedState, processedStates[processedStates.length - 1]) &&\n        equalState(processedState, processedStates[processedStates.length - 2])\n      ) {\n        continue;\n      }\n\n      processedStates.push(processedState);\n    }\n\n    const attributes = entityId in hassEntities ? hassEntities[entityId].attributes : \"friendly_name\" in first.a ? first.a : undefined;\n\n    data.push({\n      domain,\n      name: computeStateNameFromEntityAttributes(entityId, attributes || {}),\n      entity_id: entityId,\n      states: processedStates,\n    });\n  });\n\n  return {\n    unit,\n    device_class,\n    identifier: Object.keys(entities).join(\"\"),\n    data,\n  };\n};\n\nconst processTimelineEntity = (entityId: string, states: EntityHistoryState[], current_state: HassEntity | undefined): TimelineEntity => {\n  const data: TimelineState[] = [];\n  const first: EntityHistoryState = states[0];\n  const formatter = useHass.getState().formatter;\n  const entities = useHass.getState().entities;\n  for (const state of states) {\n    if (data.length > 0 && state.s === data[data.length - 1].state) {\n      continue;\n    }\n\n    const currentAttributes: HassEntityAttributeBase = {};\n    if (current_state?.attributes.device_class) {\n      currentAttributes.device_class = current_state?.attributes.device_class;\n    }\n    const entity = entities[entityId];\n\n    data.push({\n      state_localize: formatter.attributeValue(\n        {\n          ...entity,\n          attributes: {\n            ...(state.a || first.a),\n            ...currentAttributes,\n          },\n        },\n        state.s,\n      ),\n      state: state.s,\n      // lc (last_changed) may be omitted if its the same\n      // as lu (last_updated).\n      last_changed: (state.lc ? state.lc : state.lu) * 1000,\n    });\n  }\n\n  return {\n    name: computeStateNameFromEntityAttributes(entityId, current_state?.attributes || first.a),\n    entity_id: entityId,\n    data,\n  };\n};\n\nconst NUMERICAL_DOMAINS = [\"counter\", \"input_number\", \"number\"];\n\nconst isNumericFromDomain = (domain: string) => NUMERICAL_DOMAINS.includes(domain);\n\nconst isNumericFromAttributes = (attributes: Record<string, unknown>) => \"unit_of_measurement\" in attributes || \"state_class\" in attributes;\n\nconst isNumericSensorEntity = (stateObj: HassEntity, sensorNumericalDeviceClasses: string[]) =>\n  stateObj.attributes.device_class != null && sensorNumericalDeviceClasses.includes(stateObj.attributes.device_class);\n\nconst isNumericEntity = (\n  domain: string,\n  currentState: HassEntity | undefined,\n  numericStateFromHistory: EntityHistoryState | undefined,\n  sensorNumericalDeviceClasses: string[],\n  forceNumeric = false,\n): boolean =>\n  forceNumeric ||\n  isNumericFromDomain(domain) ||\n  (currentState != null && isNumericFromAttributes(currentState.attributes)) ||\n  (currentState != null && domain === \"sensor\" && isNumericSensorEntity(currentState, sensorNumericalDeviceClasses)) ||\n  numericStateFromHistory != null;\n\nconst BLANK_UNIT = \" \";\n\nconst computeGroupKey = (unit: string | undefined, device_class: string | undefined, splitDeviceClasses: boolean) =>\n  splitDeviceClasses ? `${unit}_${device_class || \"\"}` : unit;\n\nexport const computeHistory = (\n  entity: HassEntity,\n  stateHistory: HistoryStates,\n  forceNumeric = false,\n  splitDeviceClasses = false,\n): HistoryResult => {\n  const lineChartDevices: { [unit: string]: HistoryStates } = {};\n  const timelineDevices: TimelineEntity[] = [];\n  const localStateHistory: HistoryStates = {};\n  const sensorNumericalDeviceClasses = useHass.getState().sensorNumericDeviceClasses;\n  const config = useHass.getState().config;\n  const entities = useHass.getState().entities;\n\n  if (entity.entity_id in stateHistory) {\n    localStateHistory[entity.entity_id] = stateHistory[entity.entity_id];\n  } else if (entities[entity.entity_id]) {\n    localStateHistory[entity.entity_id] = [\n      {\n        s: entities[entity.entity_id].state,\n        a: entities[entity.entity_id].attributes,\n        lu: new Date(entities[entity.entity_id].last_updated).getTime() / 1000,\n      },\n    ];\n  }\n\n  if (!localStateHistory) {\n    return { line: [], timeline: [] };\n  }\n  Object.keys(stateHistory).forEach((entityId) => {\n    const stateInfo = localStateHistory[entityId];\n    if (stateInfo.length === 0) {\n      return;\n    }\n\n    const domain = computeDomain(entityId as EntityName);\n\n    const currentState = entityId in entities ? entities[entityId] : undefined;\n    const numericStateFromHistory =\n      currentState || isNumericFromDomain(domain) ? undefined : stateInfo.find((state) => state.a && isNumericFromAttributes(state.a));\n\n    const isNumeric = isNumericEntity(domain, currentState, numericStateFromHistory, sensorNumericalDeviceClasses, forceNumeric);\n\n    let unit: string | undefined;\n\n    if (isNumeric) {\n      unit = currentState?.attributes.unit_of_measurement || numericStateFromHistory?.a.unit_of_measurement || BLANK_UNIT;\n    } else {\n      if (domain === \"zone\") {\n        unit = localize(\"people_in_zone\");\n      } else if (domain === \"climate\" || domain === \"water_heater\") {\n        unit = config?.unit_system.temperature;\n      } else if (domain === \"humidifier\") {\n        unit = \"%\";\n      }\n    }\n\n    let deviceClassSpecial: string | undefined;\n\n    if (domain === \"climate\") {\n      deviceClassSpecial = \"temperature\";\n    } else if (domain === \"humidifier\") {\n      deviceClassSpecial = \"humidity\";\n    } else if (domain === \"water_heater\") {\n      deviceClassSpecial = \"temperature\";\n    }\n\n    const deviceClass: string | undefined = deviceClassSpecial || (currentState?.attributes || numericStateFromHistory?.a)?.device_class;\n\n    const key = computeGroupKey(unit, deviceClass, splitDeviceClasses);\n\n    if (!unit) {\n      timelineDevices.push(processTimelineEntity(entityId, stateInfo, currentState));\n    } else if (key && key in lineChartDevices && entityId in lineChartDevices[key]) {\n      lineChartDevices[key][entityId].push(...stateInfo);\n    } else if (key) {\n      if (!(key in lineChartDevices)) {\n        lineChartDevices[key] = {};\n      }\n      lineChartDevices[key][entityId] = stateInfo;\n    }\n  });\n\n  const unitStates = Object.keys(lineChartDevices).map((key) => {\n    const splitKey = key.split(\"_\");\n    const unit = splitKey[0];\n    const deviceClass = splitKey.slice(1).join(\"_\") || undefined;\n    return processLineChartEntities(unit, deviceClass, lineChartDevices[key]);\n  });\n\n  return { line: unitStates, timeline: timelineDevices };\n};\n"],"names":["DOMAINS_USE_LAST_UPDATED","NEED_ATTRIBUTE_DOMAINS","LINE_ATTRIBUTES_TO_KEEP","entityIdHistoryNeedsAttributes","entityId","computeDomain","subscribeHistory","connection","entityIds","callbackFunction","hoursToShow","minimalResponse","significantChangesOnly","noAttributes","params","stream","HistoryStream","message","streamMessage","purgeBeforePythonTime","newHistory","entityCombinedHistory","lastEntityCombinedHistory","a","b","expiredStates","state","lastExpiredState","equalState","obj1","obj2","attr","processLineChartEntities","unit","device_class","entities","hassEntities","useHass","data","states","first","domain","processedStates","processedState","attributes","computeStateNameFromEntityAttributes","processTimelineEntity","current_state","formatter","currentAttributes","entity","NUMERICAL_DOMAINS","isNumericFromDomain","isNumericFromAttributes","isNumericSensorEntity","stateObj","sensorNumericalDeviceClasses","isNumericEntity","currentState","numericStateFromHistory","forceNumeric","BLANK_UNIT","computeGroupKey","splitDeviceClasses","computeHistory","stateHistory","lineChartDevices","timelineDevices","localStateHistory","config","stateInfo","isNumeric","localize","deviceClassSpecial","deviceClass","key","splitKey"],"mappings":"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"}