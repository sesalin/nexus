{"version":3,"file":"index.js","sources":["../../../../src/hooks/useCamera/index.ts"],"sourcesContent":["import { useEntity, isUnavailableState, useHass, supportsFeatureFromAttributes } from \"@core\";\nimport type { HassEntityWithService, FilterByDomain, EntityName } from \"@core\";\nimport { useRef, useState, useCallback, useMemo, useEffect } from \"react\";\nimport { fetchThumbnailUrlWithCache, fetchStreamUrl, computeMJPEGStreamUrl } from \"./camera\";\nimport { ASPECT_RATIO_DEFAULT, MAX_IMAGE_WIDTH, CAMERA_SUPPORT_STREAM, STREAM_TYPE_WEB_RTC, type StreamType } from \"./constants\";\n\nexport interface UseCameraOptions {\n  /** the requested width of the poster image @default 640 */\n  imageWidth?: number;\n  /** the requested aspect ratio of the image @default 9/16 */\n  aspectRatio?: number;\n  /** enable/disable the request for the poster */\n  poster?: boolean;\n  /** enable/disable the request for the stream */\n  stream?: boolean;\n}\n\ninterface CameraCapabilities {\n  frontend_stream_types: StreamType[];\n}\n\nexport interface CameraEntityExtended extends HassEntityWithService<\"camera\">, CameraCapabilities {\n  stream: {\n    url: string | undefined;\n    loading: boolean;\n    error: Error | undefined;\n    refresh: () => Promise<void>;\n  };\n  poster: {\n    url: string | undefined;\n    loading: boolean;\n    error: Error | undefined;\n    refresh: () => Promise<void>;\n  };\n  mjpeg: {\n    url: string | undefined;\n    shouldRenderMJPEG: boolean;\n  };\n}\n/** The useCamera hook is designed to return all the custom complex logic in an easy to retrieve structure, it supports streams, motion jpeg, posters and the camera entity */\nexport function useCamera(entity: FilterByDomain<EntityName, \"camera\">, options?: UseCameraOptions): CameraEntityExtended {\n  const camera = useEntity(entity);\n  const { joinHassUrl } = useHass.getState().helpers;\n  const connection = useHass((state) => state.connection);\n  const requestedStreamUrl = useRef(false);\n  const requestedPosterUrl = useRef(false);\n  const [posterUrl, setPosterUrl] = useState<string | undefined>(undefined);\n  const [streamUrl, setStreamUrl] = useState<string | undefined>(undefined);\n  const [streamError, setStreamError] = useState<Error | undefined>(undefined);\n  const [posterError, setPosterError] = useState<Error | undefined>(undefined);\n  const [streamLoading, setStreamLoading] = useState<boolean>(options?.stream === false ? false : true);\n  const [posterLoading, setPosterLoading] = useState<boolean>(options?.poster === false ? false : true);\n  const mjpeg = useMemo(() => joinHassUrl(computeMJPEGStreamUrl(camera)), [camera, joinHassUrl]);\n  const [capabilities, setCapabilities] = useState<CameraCapabilities>({ frontend_stream_types: [] });\n\n  const _getPosterUrl = useCallback(async (): Promise<void> => {\n    if (options?.poster === false) return;\n    if (!connection) return;\n    if (isUnavailableState(camera.state)) {\n      return;\n    }\n    if (requestedPosterUrl.current) return;\n    requestedPosterUrl.current = true;\n    setPosterLoading(true);\n    try {\n      const width = Math.ceil((options?.imageWidth ?? MAX_IMAGE_WIDTH) * devicePixelRatio);\n      const height = Math.ceil(width * (options?.aspectRatio ?? ASPECT_RATIO_DEFAULT));\n      const cameraImageSrc = await fetchThumbnailUrlWithCache(connection, camera.entity_id, width, height);\n      setPosterUrl(joinHassUrl(cameraImageSrc));\n      setPosterLoading(false);\n    } catch (err) {\n      setPosterLoading(false);\n      // poster url is optional\n      if (err instanceof Error) {\n        setPosterError(err);\n      }\n    }\n  }, [camera.entity_id, joinHassUrl, camera.state, connection, options?.poster, options?.aspectRatio, options?.imageWidth]);\n\n  const fetchCapabilities = useCallback(\n    async () =>\n      connection?.sendMessagePromise<CameraCapabilities>({\n        type: \"camera/capabilities\",\n        entity_id: camera.entity_id,\n      }),\n    [connection, camera.entity_id],\n  );\n\n  useEffect(() => {\n    async function load() {\n      setCapabilities((await fetchCapabilities()) || { frontend_stream_types: [] });\n    }\n    load();\n  }, [fetchCapabilities]);\n\n  const _getStreamUrl = useCallback(async (): Promise<void> => {\n    if (options?.stream === false) return;\n    if (!connection) return;\n    if (isUnavailableState(camera.state)) {\n      return;\n    }\n    if (requestedStreamUrl.current) return;\n    requestedStreamUrl.current = true;\n    setStreamLoading(true);\n    try {\n      const url = await fetchStreamUrl(connection, camera.entity_id);\n      setStreamUrl(joinHassUrl(url));\n      setStreamLoading(false);\n    } catch (err) {\n      setStreamLoading(false);\n      // Fails if we were unable to get a stream\n      console.error(err);\n      if (err instanceof Error) {\n        setStreamError(err);\n      }\n    }\n  }, [camera.entity_id, joinHassUrl, camera.state, connection, options?.stream]);\n\n  const _shouldRenderMJPEG = useCallback(() => {\n    if (streamError) {\n      // Fallback when unable to fetch stream url\n      return true;\n    }\n    if (!supportsFeatureFromAttributes(camera.attributes, CAMERA_SUPPORT_STREAM)) {\n      // Steaming is not supported by the camera so fallback to MJPEG stream\n      return true;\n    }\n    if (capabilities.frontend_stream_types.includes(STREAM_TYPE_WEB_RTC)) {\n      // Browser support required for WebRTC\n      return typeof RTCPeerConnection === \"undefined\";\n    }\n    // Server side stream component required for HLS\n    return false;\n  }, [camera.attributes, capabilities, streamError]);\n\n  useEffect(() => {\n    _getStreamUrl();\n    _getPosterUrl();\n  }, [_getStreamUrl, _getPosterUrl]);\n\n  return useMemo(() => {\n    const stream = {\n      url: streamUrl,\n      loading: streamLoading,\n      error: streamError,\n      refresh: async () => {\n        requestedStreamUrl.current = false;\n        return _getStreamUrl();\n      },\n    };\n    const poster = {\n      url: posterUrl,\n      loading: posterLoading,\n      error: posterError,\n      refresh: async () => {\n        requestedPosterUrl.current = false;\n        return _getPosterUrl();\n      },\n    };\n    const extendedCamera = {\n      ...camera,\n      stream,\n      poster,\n      mjpeg: {\n        url: mjpeg,\n        shouldRenderMJPEG: _shouldRenderMJPEG(),\n      },\n      ...capabilities,\n    } satisfies CameraEntityExtended;\n    return extendedCamera;\n  }, [\n    camera,\n    streamUrl,\n    _shouldRenderMJPEG,\n    streamLoading,\n    streamError,\n    _getStreamUrl,\n    posterUrl,\n    posterLoading,\n    posterError,\n    mjpeg,\n    _getPosterUrl,\n    capabilities,\n  ]);\n}\n"],"names":["useCamera","entity","options","camera","useEntity","joinHassUrl","useHass","connection","state","requestedStreamUrl","useRef","requestedPosterUrl","posterUrl","setPosterUrl","useState","streamUrl","setStreamUrl","streamError","setStreamError","posterError","setPosterError","streamLoading","setStreamLoading","posterLoading","setPosterLoading","mjpeg","useMemo","computeMJPEGStreamUrl","capabilities","setCapabilities","_getPosterUrl","useCallback","isUnavailableState","width","MAX_IMAGE_WIDTH","height","ASPECT_RATIO_DEFAULT","cameraImageSrc","fetchThumbnailUrlWithCache","err","fetchCapabilities","useEffect","load","_getStreamUrl","url","fetchStreamUrl","_shouldRenderMJPEG","supportsFeatureFromAttributes","CAMERA_SUPPORT_STREAM","STREAM_TYPE_WEB_RTC"],"mappings":"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"}