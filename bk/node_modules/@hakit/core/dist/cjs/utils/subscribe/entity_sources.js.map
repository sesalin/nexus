{"version":3,"file":"entity_sources.js","sources":["../../../../src/utils/subscribe/entity_sources.ts"],"sourcesContent":["import { Connection, HassEntities } from \"home-assistant-js-websocket\";\nimport { timeCachePromiseFunc } from \"./timeCacheFunctionPromise\";\n\n/**\n * Minimal shape describing the source of an entity provided by Home Assistant.\n * Currently includes the integration domain (e.g. `\"mqtt\"`, `\"zwave_js\"`).\n */\ninterface EntitySource {\n  /** Integration domain responsible for providing this entity. */\n  domain: string;\n}\n\n/**\n * Map of entity_id -> source metadata.\n */\nexport type EntitySources = Record<string, EntitySource>;\n\n/**\n * Fetch entity source metadata from Home Assistant.\n *\n * Issues the `entity/source` websocket command which returns a structure mapping\n * each entity_id to the providing integration domain. This is useful for grouping or\n * surfacing provenance (e.g. show icon/tag for MQTT vs Zigbee).\n *\n * NOTE: The response can grow with number of entities; callers should prefer the cached\n * wrapper below when invoked frequently in UI contexts.\n *\n * @param connection Active HA websocket connection.\n * @returns Promise resolving to the entity sources mapping.\n */\nconst fetchEntitySources = (connection: Connection): Promise<EntitySources> => connection.sendMessagePromise({ type: \"entity/source\" });\n\n/**\n * Fetch entity source metadata with short-lived in-memory caching.\n *\n * Caching strategy:\n * - Keyed under the internal cache id `\"_entitySources\"`.\n * - TTL: 30 seconds; after this the data is considered stale and refetched.\n * - Invalidation heuristic: number of entity states (Object.keys(hass.states).length).\n *   If the count changes between fetches before TTL expiry we assume entity additions/removals and force refresh.\n *\n * This heuristic is intentionally coarse to avoid deep diffs of the state map: additions/removals/change in total count\n * usually correlate with potential integration changes, which might imply different source mapping.\n *\n * Edge Cases & Considerations:\n * - If an integration reload swaps domains without changing entity count, the cache will NOT invalidate early. Such\n *   scenarios are rare; manual cache busting can be added if required.\n * - For extremely large installations consider extending TTL to reduce websocket chatter further; domain provenance\n *   rarely changes often.\n * - If entity states oscillate (rapid add/remove) the cache may invalidate frequently; debouncing at a higher layer\n *   could mitigate performance concerns.\n *\n * @param hassEntities Current HassEntities map used solely for the size heuristic.\n * @param connection Active HA websocket connection.\n * @returns Promise resolving to the (possibly cached) entity sources mapping.\n */\nexport const fetchEntitySourcesWithCache = (hassEntities: HassEntities, connection: Connection): Promise<EntitySources> =>\n  timeCachePromiseFunc(\n    \"_entitySources\", // cache key\n    30000, // 30s TTL\n    fetchEntitySources, // underlying fetcher\n    (hass2) => Object.keys(hass2.states).length, // invalidation heuristic based on entity count\n    connection,\n    hassEntities,\n  );\n"],"names":["fetchEntitySources","connection","fetchEntitySourcesWithCache","hassEntities","timeCachePromiseFunc","hass2"],"mappings":"iIA8BMA,EAAsBC,GAAmDA,EAAW,mBAAmB,CAAE,KAAM,gBAAiB,EA0BzHC,EAA8B,CAACC,EAA4BF,IACtEG,EAAAA,qBACE,iBACA,IACAJ,EACCK,GAAU,OAAO,KAAKA,EAAM,MAAM,EAAE,OACrCJ,EACAE,CACF"}