{"version":3,"file":"areas.js","sources":["../../../../src/utils/subscribe/areas.ts"],"sourcesContent":["import { EntityRegistryEntry, RegistryEntry } from \"@utils/entity_registry\";\nimport { Connection, createCollection } from \"home-assistant-js-websocket\";\nimport { Store } from \"home-assistant-js-websocket/dist/store.js\";\nimport { debounce } from \"lodash\";\nimport { DeviceRegistryEntry } from \"./devices\";\nimport { stringCompare } from \"@utils/string\";\n\nexport interface AreaRegistryEntry extends RegistryEntry {\n  /** the name of the area */\n  name: string;\n  /** the picture of the area */\n  picture: string | null;\n  /** alias names */\n  aliases: string[];\n  /** the id of the area */\n  area_id: string;\n  /** the id of the floor the area is on */\n  floor_id: string | null;\n  /** the id of the humidity sensor for the area */\n  humidity_entity_id: string | null;\n  /** the icon to use for the area */\n  icon: string | null;\n  /** labels for the area */\n  labels: string[];\n  /** the id of the temperature sensor for the area */\n  temperature_entity_id: string | null;\n}\n\n/**\n * Fetch the full list of area registry entries from Home Assistant.\n * Issues the `config/area_registry/list` websocket command via `sendMessagePromise`.\n *\n * @param conn Active HA websocket connection.\n * @returns Promise resolving to an array of AreaRegistryEntry objects.\n */\nconst fetchAreaRegistry = (conn: Connection) =>\n  conn.sendMessagePromise<AreaRegistryEntry[]>({\n    type: \"config/area_registry/list\",\n  });\n/**\n * Subscribe to area registry updates and keep a local collection store in sync.\n *\n * Home Assistant emits the `area_registry_updated` event when areas are created, updated or deleted.\n * We debounce subsequent refetches (leading & trailing) to avoid flooding the websocket when many changes happen.\n *\n * @param conn Active HA websocket connection.\n * @param store Reactive collection store maintained by `createCollection`.\n * @returns Unsubscribe function for the events subscription.\n */\nconst subscribeAreaRegistryUpdates = (conn: Connection, store: Store<AreaRegistryEntry[]>) =>\n  conn.subscribeEvents(\n    debounce(() => fetchAreaRegistry(conn).then((areas: AreaRegistryEntry[]) => store.setState(areas, true)), 500, {\n      leading: true,\n      trailing: true,\n    }),\n    \"area_registry_updated\",\n  );\n\n/**\n * Create a managed collection for the area registry.\n * Automatically fetches initial data and subscribes to updates, invoking `onChange` whenever data changes.\n *\n * @param conn Active HA websocket connection.\n * @param onChange Callback invoked with the latest list of areas when data refreshes.\n * @returns Unsubscribe function for the underlying collection.\n */\nexport const subscribeAreaRegistry = (conn: Connection, onChange: (areas: AreaRegistryEntry[]) => void) =>\n  createCollection<AreaRegistryEntry[]>(\"_areaRegistry\", fetchAreaRegistry, subscribeAreaRegistryUpdates, conn, onChange);\n\nexport type AreaEntityLookup = Record<string, EntityRegistryEntry[]>;\n\nexport type AreaDeviceLookup = Record<string, DeviceRegistryEntry[]>;\n\nexport interface AreaRegistryEntryMutableParams {\n  aliases?: string[];\n  floor_id?: string | null;\n  humidity_entity_id?: string | null;\n  icon?: string | null;\n  labels?: string[];\n  name: string;\n  picture?: string | null;\n  temperature_entity_id?: string | null;\n}\n\n/**\n * Create a new area registry entry.\n *\n * Issues `config/area_registry/create` with provided mutable parameters (name required).\n *\n * @param connection HA websocket connection.\n * @param values Area creation parameters (name mandatory, others optional).\n * @returns Promise resolving to the newly created AreaRegistryEntry.\n */\nexport const createAreaRegistryEntry = (connection: Connection, values: AreaRegistryEntryMutableParams) =>\n  connection.sendMessagePromise<AreaRegistryEntry>({\n    type: \"config/area_registry/create\",\n    ...values,\n  });\n\n/**\n * Update an existing area registry entry.\n *\n * Issues `config/area_registry/update` with partial update fields.\n *\n * @param connection HA websocket connection.\n * @param areaId Target area's `area_id`.\n * @param updates Partial area fields to change.\n * @returns Promise resolving to the updated AreaRegistryEntry.\n */\nexport const updateAreaRegistryEntry = (connection: Connection, areaId: string, updates: Partial<AreaRegistryEntryMutableParams>) =>\n  connection.sendMessagePromise<AreaRegistryEntry>({\n    type: \"config/area_registry/update\",\n    area_id: areaId,\n    ...updates,\n  });\n\n/**\n * Delete an area from the registry.\n *\n * Issues `config/area_registry/delete`.\n *\n * @param connection HA websocket connection.\n * @param areaId The `area_id` of the area to remove.\n * @returns Promise resolving when the deletion is acknowledged.\n */\nexport const deleteAreaRegistryEntry = (connection: Connection, areaId: string) =>\n  connection.sendMessagePromise({\n    type: \"config/area_registry/delete\",\n    area_id: areaId,\n  });\n\n/**\n * Build a lookup mapping area_id -> list of entity registry entries directly assigned to that area.\n * Ignores entities without an explicit `area_id` (those may inherit via devices elsewhere).\n *\n * @param entities Full list of entity registry entries.\n * @returns Record area_id -> array of entity entries.\n */\nexport const getAreaEntityLookup = (entities: EntityRegistryEntry[]): AreaEntityLookup => {\n  const areaEntityLookup: AreaEntityLookup = {};\n  for (const entity of entities) {\n    if (!entity.area_id) {\n      continue;\n    }\n    if (!(entity.area_id in areaEntityLookup)) {\n      areaEntityLookup[entity.area_id] = [];\n    }\n    areaEntityLookup[entity.area_id].push(entity);\n  }\n  return areaEntityLookup;\n};\n\n/**\n * Build a lookup mapping area_id -> list of device registry entries assigned to that area.\n * Devices without an `area_id` are skipped.\n *\n * @param devices Array of device registry entries.\n * @returns Record area_id -> array of device entries.\n */\nexport const getAreaDeviceLookup = (devices: DeviceRegistryEntry[]): AreaDeviceLookup => {\n  const areaDeviceLookup: AreaDeviceLookup = {};\n  for (const device of devices) {\n    if (!device.area_id) {\n      continue;\n    }\n    if (!(device.area_id in areaDeviceLookup)) {\n      areaDeviceLookup[device.area_id] = [];\n    }\n    areaDeviceLookup[device.area_id].push(device);\n  }\n  return areaDeviceLookup;\n};\n\n/**\n * Produce a comparator function for sorting area ids.\n *\n * If an explicit `order` array is supplied, areas found in that array are sorted by their index\n * and areas not present are pushed after those that are. When both are absent from the order list\n * a locale-aware name comparison (via `stringCompare`) is used.\n *\n * @param entries Lookup of area_id -> AreaRegistryEntry used to resolve names.\n * @param order Optional explicit ordering of area_ids.\n * @returns Comparator function suitable for Array.sort.\n */\nexport const areaCompare = (entries: Record<string, AreaRegistryEntry>, order?: string[]) => (a: string, b: string) => {\n  const indexA = order ? order.indexOf(a) : -1;\n  const indexB = order ? order.indexOf(b) : -1;\n  if (indexA === -1 && indexB === -1) {\n    const nameA = entries?.[a]?.name ?? a;\n    const nameB = entries?.[b]?.name ?? b;\n    return stringCompare(nameA, nameB);\n  }\n  if (indexA === -1) {\n    return 1;\n  }\n  if (indexB === -1) {\n    return -1;\n  }\n  return indexA - indexB;\n};\n"],"names":["fetchAreaRegistry","conn","subscribeAreaRegistryUpdates","store","debounce","areas","subscribeAreaRegistry","onChange","createCollection","createAreaRegistryEntry","connection","values","updateAreaRegistryEntry","areaId","updates","deleteAreaRegistryEntry","getAreaEntityLookup","entities","areaEntityLookup","entity","getAreaDeviceLookup","devices","areaDeviceLookup","device","areaCompare","entries","order","a","b","indexA","indexB","nameA","nameB","stringCompare"],"mappings":"6KAmCMA,EAAqBC,GACzBA,EAAK,mBAAwC,CAC3C,KAAM,2BACR,CAAC,EAWGC,EAA+B,CAACD,EAAkBE,IACtDF,EAAK,gBACHG,EAAAA,SAAS,IAAMJ,EAAkBC,CAAI,EAAE,KAAMI,GAA+BF,EAAM,SAASE,EAAO,EAAI,CAAC,EAAG,IAAK,CAC7G,QAAS,GACT,SAAU,EAAA,CACX,EACD,uBACF,EAUWC,EAAwB,CAACL,EAAkBM,IACtDC,EAAAA,iBAAsC,gBAAiBR,EAAmBE,EAA8BD,EAAMM,CAAQ,EA0B3GE,EAA0B,CAACC,EAAwBC,IAC9DD,EAAW,mBAAsC,CAC/C,KAAM,8BACN,GAAGC,CACL,CAAC,EAYUC,EAA0B,CAACF,EAAwBG,EAAgBC,IAC9EJ,EAAW,mBAAsC,CAC/C,KAAM,8BACN,QAASG,EACT,GAAGC,CACL,CAAC,EAWUC,EAA0B,CAACL,EAAwBG,IAC9DH,EAAW,mBAAmB,CAC5B,KAAM,8BACN,QAASG,CACX,CAAC,EASUG,EAAuBC,GAAsD,CACxF,MAAMC,EAAqC,CAAA,EAC3C,UAAWC,KAAUF,EACdE,EAAO,UAGNA,EAAO,WAAWD,IACtBA,EAAiBC,EAAO,OAAO,EAAI,CAAA,GAErCD,EAAiBC,EAAO,OAAO,EAAE,KAAKA,CAAM,GAE9C,OAAOD,CACT,EASaE,EAAuBC,GAAqD,CACvF,MAAMC,EAAqC,CAAA,EAC3C,UAAWC,KAAUF,EACdE,EAAO,UAGNA,EAAO,WAAWD,IACtBA,EAAiBC,EAAO,OAAO,EAAI,CAAA,GAErCD,EAAiBC,EAAO,OAAO,EAAE,KAAKA,CAAM,GAE9C,OAAOD,CACT,EAaaE,EAAc,CAACC,EAA4CC,IAAqB,CAACC,EAAWC,IAAc,CACrH,MAAMC,EAASH,EAAQA,EAAM,QAAQC,CAAC,EAAI,GACpCG,EAASJ,EAAQA,EAAM,QAAQE,CAAC,EAAI,GAC1C,GAAIC,IAAW,IAAMC,IAAW,GAAI,CAClC,MAAMC,EAAQN,IAAUE,CAAC,GAAG,MAAQA,EAC9BK,EAAQP,IAAUG,CAAC,GAAG,MAAQA,EACpC,OAAOK,EAAAA,cAAcF,EAAOC,CAAK,CACnC,CACA,OAAIH,IAAW,GACN,EAELC,IAAW,GACN,GAEFD,EAASC,CAClB"}