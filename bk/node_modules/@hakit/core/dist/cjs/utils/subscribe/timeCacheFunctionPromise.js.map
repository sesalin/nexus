{"version":3,"file":"timeCacheFunctionPromise.js","sources":["../../../../src/utils/subscribe/timeCacheFunctionPromise.ts"],"sourcesContent":["import { Connection, HassEntities } from \"home-assistant-js-websocket\";\n\ninterface CacheResult<T> {\n  result: T;\n  cacheKey: unknown;\n}\n\nconst CACHE_OBJECT: Record<string, CacheResult<unknown> | Promise<CacheResult<unknown>> | undefined> = {};\n\nfunction getCacheObject<T>(cacheKey: string): CacheResult<T> | undefined {\n  return CACHE_OBJECT[cacheKey] as CacheResult<T> | undefined;\n}\n\nfunction setCacheObject<T>(cacheKey: string, value: CacheResult<T> | undefined | Promise<CacheResult<T>>): void {\n  CACHE_OBJECT[cacheKey] = value;\n}\n\n/**\n * Caches a result of a promise for X time. Allows optional extra validation\n * check to invalidate the cache.\n * @param cacheKey the key to store the cache\n * @param cacheTime the time to cache the result\n * @param func the function to fetch the data\n * @param generateCacheKey optional function to generate a cache key based on current hass + cached result. Cache is invalid if generates a different cache key.\n * @param hass Home Assistant object\n * @param args extra arguments to pass to the function to fetch the data\n * @returns\n */\nexport const timeCachePromiseFunc = async <T>(\n  cacheKey: string,\n  cacheTime: number,\n  func: (connection: Connection) => Promise<T>,\n  generateCacheKey: ((hassEntities: HassEntities, lastResult: T) => unknown) | undefined,\n  connection: Connection,\n  hassEntities: HassEntities,\n): Promise<T> => {\n  const lastResult: Promise<CacheResult<T>> | CacheResult<T> | undefined = getCacheObject(cacheKey);\n\n  const checkCachedResult = (result: CacheResult<T>): T | Promise<T> => {\n    if (!generateCacheKey || generateCacheKey(hassEntities, result.result) === result.cacheKey) {\n      return result.result;\n    }\n\n    CACHE_OBJECT[cacheKey] = undefined;\n    return timeCachePromiseFunc(cacheKey, cacheTime, func, generateCacheKey, connection, hassEntities);\n  };\n\n  // If we have a cached result, return it if it's still valid\n  if (lastResult) {\n    return lastResult instanceof Promise ? lastResult.then(checkCachedResult) : checkCachedResult(lastResult);\n  }\n\n  const resultPromise = func(connection);\n  setCacheObject<T>(cacheKey, resultPromise as Promise<CacheResult<T>>);\n\n  resultPromise.then(\n    // When successful, set timer to clear cache\n    (result) => {\n      setCacheObject(cacheKey, {\n        result,\n        cacheKey: generateCacheKey?.(hassEntities, result),\n      });\n      setTimeout(() => {\n        setCacheObject(cacheKey, undefined);\n      }, cacheTime);\n    },\n    // On failure, clear cache right away\n    () => {\n      setCacheObject(cacheKey, undefined);\n    },\n  );\n\n  return resultPromise;\n};\n"],"names":["CACHE_OBJECT","getCacheObject","cacheKey","setCacheObject","value","timeCachePromiseFunc","cacheTime","func","generateCacheKey","connection","hassEntities","lastResult","checkCachedResult","result","resultPromise"],"mappings":"gFAOA,MAAMA,EAAiG,CAAA,EAEvG,SAASC,EAAkBC,EAA8C,CACvE,OAAOF,EAAaE,CAAQ,CAC9B,CAEA,SAASC,EAAkBD,EAAkBE,EAAmE,CAC9GJ,EAAaE,CAAQ,EAAIE,CAC3B,CAaO,MAAMC,EAAuB,MAClCH,EACAI,EACAC,EACAC,EACAC,EACAC,IACe,CACf,MAAMC,EAAmEV,EAAeC,CAAQ,EAE1FU,EAAqBC,GACrB,CAACL,GAAoBA,EAAiBE,EAAcG,EAAO,MAAM,IAAMA,EAAO,SACzEA,EAAO,QAGhBb,EAAaE,CAAQ,EAAI,OAClBG,EAAqBH,EAAUI,EAAWC,EAAMC,EAAkBC,EAAYC,CAAY,GAInG,GAAIC,EACF,OAAOA,aAAsB,QAAUA,EAAW,KAAKC,CAAiB,EAAIA,EAAkBD,CAAU,EAG1G,MAAMG,EAAgBP,EAAKE,CAAU,EACrC,OAAAN,EAAkBD,EAAUY,CAAwC,EAEpEA,EAAc,KAEXD,GAAW,CACVV,EAAeD,EAAU,CACvB,OAAAW,EACA,SAAUL,IAAmBE,EAAcG,CAAM,CAAA,CAClD,EACD,WAAW,IAAM,CACfV,EAAeD,EAAU,MAAS,CACpC,EAAGI,CAAS,CACd,EAEA,IAAM,CACJH,EAAeD,EAAU,MAAS,CACpC,CAAA,EAGKY,CACT"}