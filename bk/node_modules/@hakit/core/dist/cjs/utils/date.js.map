{"version":3,"file":"date.js","sources":["../../../src/utils/date.ts"],"sourcesContent":["import { HassConfig } from \"home-assistant-js-websocket\";\nimport { FrontendLocaleData, DateFormat } from \"./subscribe/frontend_data\";\n\nconst RESOLVED_TIME_ZONE = Intl.DateTimeFormat?.().resolvedOptions?.().timeZone;\n\n// Browser time zone can be determined from Intl, with fallback to UTC for polyfill or no support.\nexport const LOCAL_TIME_ZONE = RESOLVED_TIME_ZONE ?? \"UTC\";\n\n// Pick time zone based on user profile option.  Core zone is used when local cannot be determined.\nexport const resolveTimeZone = (option: TimeZone, serverTimeZone: string) =>\n  option === TimeZone.local && RESOLVED_TIME_ZONE ? LOCAL_TIME_ZONE : serverTimeZone;\n\nexport enum TimeFormat {\n  language = \"language\",\n  system = \"system\",\n  am_pm = \"12\",\n  twenty_four = \"24\",\n}\n\nexport enum TimeZone {\n  local = \"local\",\n  server = \"server\",\n}\n\nexport const shouldUseAmPm = (locale: FrontendLocaleData): boolean => {\n  if (locale.time_format === TimeFormat.language || locale.time_format === TimeFormat.system) {\n    const testLanguage = locale.time_format === TimeFormat.language ? locale.language : undefined;\n    const test = new Date(\"January 1, 2023 22:00:00\").toLocaleString(testLanguage);\n    return test.includes(\"10\");\n  }\n  return locale.time_format === TimeFormat.am_pm;\n};\n\nconst DAY_IN_MILLISECONDS = 86400000;\nconst HOUR_IN_MILLISECONDS = 3600000;\nconst MINUTE_IN_MILLISECONDS = 60000;\nconst SECOND_IN_MILLISECONDS = 1000;\n\nexport const UNIT_TO_MILLISECOND_CONVERT = {\n  ms: 1,\n  s: SECOND_IN_MILLISECONDS,\n  min: MINUTE_IN_MILLISECONDS,\n  h: HOUR_IN_MILLISECONDS,\n  d: DAY_IN_MILLISECONDS,\n};\n\nexport const formatDuration = (duration: string, units: keyof typeof UNIT_TO_MILLISECOND_CONVERT): string =>\n  millisecondsToDuration(parseFloat(duration) * UNIT_TO_MILLISECOND_CONVERT[units]) || \"0\";\n\nconst leftPad = (num: number, digits = 2) => {\n  let paddedNum = \"\" + num;\n  for (let i = 1; i < digits; i++) {\n    paddedNum = parseInt(paddedNum) < 10 ** i ? `0${paddedNum}` : paddedNum;\n  }\n  return paddedNum;\n};\n\nexport function millisecondsToDuration(d: number) {\n  const h = Math.floor(d / 1000 / 3600);\n  const m = Math.floor(((d / 1000) % 3600) / 60);\n  const s = Math.floor(((d / 1000) % 3600) % 60);\n  const ms = Math.floor(d % 1000);\n\n  if (h > 0) {\n    return `${h}:${leftPad(m)}:${leftPad(s)}`;\n  }\n  if (m > 0) {\n    return `${m}:${leftPad(s)}`;\n  }\n  if (s > 0 || ms > 0) {\n    return `${s}${ms > 0 ? `.${leftPad(ms, 3)}` : ``}`;\n  }\n  return null;\n}\n\n// https://stackoverflow.com/a/14322189/1947205\n// Changes:\n// 1. Do not allow a plus or minus at the start.\n// 2. Enforce that we have a \"T\" or a blank after the date portion\n//    to ensure we have a timestamp and not only a date.\n// 3. Disallow dates based on week number.\n// 4. Disallow dates only consisting of a year.\n// https://regex101.com/r/kc5C14/3\nconst regexp =\n  /^\\d{4}-(0[1-9]|1[0-2])-([12]\\d|0[1-9]|3[01])[T| ](((([01]\\d|2[0-3])((:?)[0-5]\\d)?|24:?00)([.,]\\d+(?!:))?)(\\8[0-5]\\d([.,]\\d+)?)?([zZ]|([+-])([01]\\d|2[0-3]):?([0-5]\\d)?)?)$/;\n\nexport const isTimestamp = (input: string): boolean => regexp.test(input);\n\n// https://regex101.com/r/kc5C14/2\nconst regExpString = \"^\\\\d{4}-(0[1-9]|1[0-2])-([12]\\\\d|0[1-9]|3[01])\";\n\nconst regExp = new RegExp(regExpString + \"$\");\n// 2nd expression without the \"end of string\" enforced, so it can be used\n// to just verify the start of a string and then based on that result e.g.\n// check for a full timestamp string efficiently.\nconst regExpNoStringEnd = new RegExp(regExpString);\n\nexport const isDate = (input: string, allowCharsAfterDate = false): boolean =>\n  allowCharsAfterDate ? regExpNoStringEnd.test(input) : regExp.test(input);\n\nexport function checkValidDate(date?: Date): boolean {\n  if (!date) {\n    return false;\n  }\n\n  return date instanceof Date && !isNaN(date.valueOf());\n}\n\n// Single-entry memo factory: caches only the last invocation per formatter.\n// This keeps memory footprint minimal while still avoiding repeated construction\n// during render cycles with stable locale/timezone preferences.\nfunction singleEntryMemo<Args extends unknown[], R>(factory: (...a: Args) => R) {\n  let lastArgs: Args | null = null;\n  let lastResult: R | null = null;\n  return (...args: Args): R => {\n    if (lastArgs && lastArgs.length === args.length && lastArgs.every((v, i) => v === args[i])) {\n      return lastResult as R;\n    }\n    lastArgs = args;\n    lastResult = factory(...args);\n    return lastResult as R;\n  };\n}\n\nconst dateFormatterMem = singleEntryMemo(\n  (locale: FrontendLocaleData, serverTZ: string) =>\n    new Intl.DateTimeFormat(locale.language, {\n      year: \"numeric\",\n      month: \"long\",\n      day: \"numeric\",\n      timeZone: resolveTimeZone(locale.time_zone, serverTZ),\n    }),\n);\n\nconst timeFormatterMem = singleEntryMemo(\n  (locale: FrontendLocaleData, serverTZ: string) =>\n    new Intl.DateTimeFormat(locale.language, {\n      hour: shouldUseAmPm(locale) ? \"numeric\" : \"2-digit\",\n      minute: \"2-digit\",\n      hourCycle: shouldUseAmPm(locale) ? \"h12\" : \"h23\",\n      timeZone: resolveTimeZone(locale.time_zone, serverTZ),\n    }),\n);\n\n// 24h time (HH:MM) without any day period suffix, always forcing hourCycle h23 but still honoring\n// the user's chosen timezone preference (locale.time_zone vs server time zone). Language is passed\n// purely for consistency but does not materially affect numeric output.\nconst timeWithoutAmPmFormatterMem = singleEntryMemo(\n  (locale: FrontendLocaleData, serverTZ: string) =>\n    new Intl.DateTimeFormat(locale.language, {\n      hour: \"2-digit\",\n      minute: \"2-digit\",\n      hourCycle: \"h23\",\n      timeZone: resolveTimeZone(locale.time_zone, serverTZ),\n    }),\n);\n\n// Hour-only formatter respecting 12/24 preference. For 12h locales returns values like \"5 PM\",\n// for 24h preference returns zero-padded \"17\" (no suffix). Minute component intentionally omitted.\nconst hourOnlyFormatterMem = singleEntryMemo(\n  (locale: FrontendLocaleData, serverTZ: string) =>\n    new Intl.DateTimeFormat(locale.language, {\n      hour: shouldUseAmPm(locale) ? \"numeric\" : \"2-digit\",\n      hourCycle: shouldUseAmPm(locale) ? \"h12\" : \"h23\",\n      timeZone: resolveTimeZone(locale.time_zone, serverTZ),\n    }),\n);\n\n// Minute-only formatter (always 2-digit) respecting timezone\nconst minuteOnlyFormatterMem = singleEntryMemo(\n  (locale: FrontendLocaleData, serverTZ: string) =>\n    new Intl.DateTimeFormat(locale.language, {\n      minute: \"2-digit\",\n      timeZone: resolveTimeZone(locale.time_zone, serverTZ),\n    }),\n);\n\n// Second-only formatter (always 2-digit) respecting timezone\nconst secondOnlyFormatterMem = singleEntryMemo(\n  (locale: FrontendLocaleData, serverTZ: string) =>\n    new Intl.DateTimeFormat(locale.language, {\n      second: \"2-digit\",\n      timeZone: resolveTimeZone(locale.time_zone, serverTZ),\n    }),\n);\n\nconst dateTimeFormatterMem = singleEntryMemo(\n  (locale: FrontendLocaleData, serverTZ: string) =>\n    new Intl.DateTimeFormat(locale.language, {\n      year: \"numeric\",\n      month: \"long\",\n      day: \"numeric\",\n      hour: shouldUseAmPm(locale) ? \"numeric\" : \"2-digit\",\n      minute: \"2-digit\",\n      hourCycle: shouldUseAmPm(locale) ? \"h12\" : \"h23\",\n      timeZone: resolveTimeZone(locale.time_zone, serverTZ),\n    }),\n);\n\nconst dateTimeWithSecondsFormatterMem = singleEntryMemo(\n  (locale: FrontendLocaleData, serverTZ: string) =>\n    new Intl.DateTimeFormat(locale.language, {\n      year: \"numeric\",\n      month: \"long\",\n      day: \"numeric\",\n      hour: shouldUseAmPm(locale) ? \"numeric\" : \"2-digit\",\n      minute: \"2-digit\",\n      second: \"2-digit\",\n      hourCycle: shouldUseAmPm(locale) ? \"h12\" : \"h23\",\n      timeZone: resolveTimeZone(locale.time_zone, serverTZ),\n    }),\n);\n\nconst shortDateTimeWithYearMem = singleEntryMemo(\n  (locale: FrontendLocaleData, serverTZ: string) =>\n    new Intl.DateTimeFormat(locale.language, {\n      year: \"numeric\",\n      month: \"short\",\n      day: \"numeric\",\n      hour: shouldUseAmPm(locale) ? \"numeric\" : \"2-digit\",\n      minute: \"2-digit\",\n      hourCycle: shouldUseAmPm(locale) ? \"h12\" : \"h23\",\n      timeZone: resolveTimeZone(locale.time_zone, serverTZ),\n    }),\n);\n\nconst shortDateTimeMem = singleEntryMemo(\n  (locale: FrontendLocaleData, serverTZ: string) =>\n    new Intl.DateTimeFormat(locale.language, {\n      month: \"short\",\n      day: \"numeric\",\n      hour: shouldUseAmPm(locale) ? \"numeric\" : \"2-digit\",\n      minute: \"2-digit\",\n      hourCycle: shouldUseAmPm(locale) ? \"h12\" : \"h23\",\n      timeZone: resolveTimeZone(locale.time_zone, serverTZ),\n    }),\n);\n\nconst browserDefaultsFormatterMem = singleEntryMemo(\n  () =>\n    new Intl.DateTimeFormat(undefined, {\n      year: \"numeric\",\n      month: \"long\",\n      day: \"numeric\",\n      hour: \"2-digit\",\n      minute: \"2-digit\",\n    }),\n);\n\n// --- Additional granular date formatters for HA parity ---\n\nconst dateWeekdayDayMem = singleEntryMemo(\n  (locale: FrontendLocaleData, serverTZ: string) =>\n    new Intl.DateTimeFormat(locale.language, {\n      weekday: \"long\",\n      month: \"long\",\n      day: \"numeric\",\n      timeZone: resolveTimeZone(locale.time_zone, serverTZ),\n    }),\n);\n\nconst dateShortMem = singleEntryMemo(\n  (locale: FrontendLocaleData, serverTZ: string) =>\n    new Intl.DateTimeFormat(locale.language, {\n      year: \"numeric\",\n      month: \"short\",\n      day: \"numeric\",\n      timeZone: resolveTimeZone(locale.time_zone, serverTZ),\n    }),\n);\n\nconst dateVeryShortMem = singleEntryMemo(\n  (locale: FrontendLocaleData, serverTZ: string) =>\n    new Intl.DateTimeFormat(locale.language, {\n      day: \"numeric\",\n      month: \"short\",\n      timeZone: resolveTimeZone(locale.time_zone, serverTZ),\n    }),\n);\n\nconst dateMonthYearMem = singleEntryMemo(\n  (locale: FrontendLocaleData, serverTZ: string) =>\n    new Intl.DateTimeFormat(locale.language, {\n      month: \"long\",\n      year: \"numeric\",\n      timeZone: resolveTimeZone(locale.time_zone, serverTZ),\n    }),\n);\n\nconst dateMonthMem = singleEntryMemo(\n  (locale: FrontendLocaleData, serverTZ: string) =>\n    new Intl.DateTimeFormat(locale.language, {\n      month: \"long\",\n      timeZone: resolveTimeZone(locale.time_zone, serverTZ),\n    }),\n);\n\nconst dateYearMem = singleEntryMemo(\n  (locale: FrontendLocaleData, serverTZ: string) =>\n    new Intl.DateTimeFormat(locale.language, {\n      year: \"numeric\",\n      timeZone: resolveTimeZone(locale.time_zone, serverTZ),\n    }),\n);\n\nconst dateWeekdayMem = singleEntryMemo(\n  (locale: FrontendLocaleData, serverTZ: string) =>\n    new Intl.DateTimeFormat(locale.language, {\n      weekday: \"long\",\n      timeZone: resolveTimeZone(locale.time_zone, serverTZ),\n    }),\n);\n\nconst dateWeekdayShortMem = singleEntryMemo(\n  (locale: FrontendLocaleData, serverTZ: string) =>\n    new Intl.DateTimeFormat(locale.language, {\n      weekday: \"short\",\n      timeZone: resolveTimeZone(locale.time_zone, serverTZ),\n    }),\n);\n\n// Numeric date with user preference ordering (DMY/MDY/YMD) when locale.date_format overrides language/system.\nconst dateNumericBaseMem = singleEntryMemo((locale: FrontendLocaleData, serverTZ: string) => {\n  const localeString = locale.date_format === DateFormat.system ? undefined : locale.language;\n  return new Intl.DateTimeFormat(localeString, {\n    year: \"numeric\",\n    month: \"numeric\",\n    day: \"numeric\",\n    timeZone: resolveTimeZone(locale.time_zone, serverTZ),\n  });\n});\n\n/** Format a date (long month) e.g. \"August 9, 2021\" */\nexport const formatDate = (dateObj: Date, config: HassConfig, locale: FrontendLocaleData) =>\n  dateFormatterMem(locale, config.time_zone).format(dateObj);\n\n/** Format a time respecting 12/24 preference e.g. \"8:23 AM\" or \"08:23\" */\nexport const formatTime = (dateObj: Date, config: HassConfig, locale: FrontendLocaleData) =>\n  timeFormatterMem(locale, config.time_zone).format(dateObj);\n\n/** Format a time forcing 24h cycle (HH:MM) without an AM/PM suffix, ignoring user 12h preference but honoring timezone preference. */\nexport const formatTimeWithoutAmPm = (dateObj: Date, config: HassConfig, locale: FrontendLocaleData) =>\n  timeWithoutAmPmFormatterMem(locale, config.time_zone).format(dateObj);\n\n/** Hour numeric only respecting 12/24 preference (no suffix). e.g. \"5\" or \"17\" */\nexport const formatHour = (dateObj: Date, config: HassConfig, locale: FrontendLocaleData) => {\n  const parts = hourOnlyFormatterMem(locale, config.time_zone).formatToParts(dateObj);\n  return parts.find((p) => p.type === \"hour\")?.value || \"\";\n};\n\n/** Minute numeric only (zero-padded, e.g. \"07\") */\nexport const formatMinute = (dateObj: Date, config: HassConfig, locale: FrontendLocaleData) => {\n  const parts = minuteOnlyFormatterMem(locale, config.time_zone).formatToParts(dateObj);\n  return parts.find((p) => p.type === \"minute\")?.value || \"\";\n};\n\n/** Seconds numeric only (zero-padded, e.g. \"09\") */\nexport const formatSeconds = (dateObj: Date, config: HassConfig, locale: FrontendLocaleData) => {\n  const parts = secondOnlyFormatterMem(locale, config.time_zone).formatToParts(dateObj);\n  return parts.find((p) => p.type === \"second\")?.value || \"\";\n};\n\n/** Long date & time without seconds e.g. \"August 9, 2021, 8:23 AM\" */\nexport const formatDateTime = (dateObj: Date, config: HassConfig, locale: FrontendLocaleData) =>\n  dateTimeFormatterMem(locale, config.time_zone).format(dateObj);\n\n// August 9, 2021, 8:23:15 AM\n/** Long date & time with seconds e.g. \"August 9, 2021, 8:23:15 AM\" */\nexport const formatDateTimeWithSeconds = (dateObj: Date, locale: FrontendLocaleData, config: HassConfig) =>\n  dateTimeWithSecondsFormatterMem(locale, config.time_zone).format(dateObj);\n\n/** Short date/time without year if same year e.g. \"Aug 9, 8:23 AM\" */\nexport const formatShortDateTime = (dateObj: Date, locale: FrontendLocaleData, config: HassConfig) =>\n  shortDateTimeMem(locale, config.time_zone).format(dateObj);\n\n/** Short date/time with year e.g. \"Aug 9, 2021, 8:23 AM\" */\nexport const formatShortDateTimeWithYear = (dateObj: Date, locale: FrontendLocaleData, config: HassConfig) =>\n  shortDateTimeWithYearMem(locale, config.time_zone).format(dateObj);\n\n/** Conditionally include year (current year omitted) */\nexport const formatShortDateTimeWithConditionalYear = (dateObj: Date, locale: FrontendLocaleData, config: HassConfig) => {\n  const now = new Date();\n  return now.getFullYear() === dateObj.getFullYear()\n    ? formatShortDateTime(dateObj, locale, config)\n    : formatShortDateTimeWithYear(dateObj, locale, config);\n};\n\n/** Browser default locale (useful for fallback) */\nexport const formatDateTimeWithBrowserDefaults = (dateObj: Date) => browserDefaultsFormatterMem().format(dateObj);\n\n/** Numeric date/time variant (delegates to existing helpers if present) */\nexport const formatDateTimeNumeric = (dateObj: Date, locale: FrontendLocaleData, config: HassConfig) => {\n  // Provide a simple numeric format similar to HA's `formatDateTimeNumeric`.\n  // We intentionally do not memoize this combined string (two memoized parts already).\n  const datePart = new Intl.DateTimeFormat(locale.language, {\n    year: \"numeric\",\n    month: \"numeric\",\n    day: \"numeric\",\n    timeZone: resolveTimeZone(locale.time_zone, config.time_zone),\n  }).format(dateObj);\n  return `${datePart}, ${formatTime(dateObj, config, locale)}`;\n};\n\n/** Weekday + Month + Day (e.g. \"Tuesday, August 10\") */\nexport const formatDateWeekdayDay = (dateObj: Date, locale: FrontendLocaleData, config: HassConfig) =>\n  dateWeekdayDayMem(locale, config.time_zone).format(dateObj);\n\n/** Short date (e.g. \"Aug 10, 2021\") */\nexport const formatDateShort = (dateObj: Date, locale: FrontendLocaleData, config: HassConfig) =>\n  dateShortMem(locale, config.time_zone).format(dateObj);\n\n/** Very short date (e.g. \"Aug 10\") */\nexport const formatDateVeryShort = (dateObj: Date, locale: FrontendLocaleData, config: HassConfig) =>\n  dateVeryShortMem(locale, config.time_zone).format(dateObj);\n\n/** Month + Year (e.g. \"August 2021\") */\nexport const formatDateMonthYear = (dateObj: Date, locale: FrontendLocaleData, config: HassConfig) =>\n  dateMonthYearMem(locale, config.time_zone).format(dateObj);\n\n/** Month name (e.g. \"August\") */\nexport const formatDateMonth = (dateObj: Date, locale: FrontendLocaleData, config: HassConfig) =>\n  dateMonthMem(locale, config.time_zone).format(dateObj);\n\n/** Year (e.g. \"2021\") */\nexport const formatDateYear = (dateObj: Date, locale: FrontendLocaleData, config: HassConfig) =>\n  dateYearMem(locale, config.time_zone).format(dateObj);\n\n/** Weekday long (e.g. \"Monday\") */\nexport const formatDateWeekday = (dateObj: Date, locale: FrontendLocaleData, config: HassConfig) =>\n  dateWeekdayMem(locale, config.time_zone).format(dateObj);\n\n/** Weekday short (e.g. \"Mon\") */\nexport const formatDateWeekdayShort = (dateObj: Date, locale: FrontendLocaleData, config: HassConfig) =>\n  dateWeekdayShortMem(locale, config.time_zone).format(dateObj);\n\n/** Numeric date honoring user ordering preference (e.g. DMY -> 10/08/2021) */\nexport const formatDateNumeric = (dateObj: Date, locale: FrontendLocaleData, config: HassConfig) => {\n  const formatter = dateNumericBaseMem(locale, config.time_zone);\n  if (locale.date_format === DateFormat.language || locale.date_format === DateFormat.system) {\n    return formatter.format(dateObj);\n  }\n  const parts = formatter.formatToParts(dateObj);\n  const literal = parts.find((p) => p.type === \"literal\")?.value || \"/\";\n  const day = parts.find((p) => p.type === \"day\")?.value || \"\";\n  const month = parts.find((p) => p.type === \"month\")?.value || \"\";\n  const year = parts.find((p) => p.type === \"year\")?.value || \"\";\n  const lastPart = parts[parts.length - 1];\n  let lastLiteral = lastPart?.type === \"literal\" ? lastPart.value : \"\";\n  if (locale.language === \"bg\" && locale.date_format === DateFormat.YMD) {\n    lastLiteral = \"\";\n  }\n  const byFormat: Record<DateFormat, string> = {\n    [DateFormat.DMY]: `${day}${literal}${month}${literal}${year}${lastLiteral}`,\n    [DateFormat.MDY]: `${month}${literal}${day}${literal}${year}${lastLiteral}`,\n    [DateFormat.YMD]: `${year}${literal}${month}${literal}${day}${lastLiteral}`,\n    [DateFormat.language]: formatter.format(dateObj),\n    [DateFormat.system]: formatter.format(dateObj),\n  };\n  return byFormat[locale.date_format];\n};\n\n/**\n * Return a localized day period (AM/PM or locale equivalent) for the given date.\n * This intentionally ignores the user's 24h preference so callers can always access the suffix if desired.\n * Only timezone and language are considered (not time_format). Falls back to simple \"AM\"/\"PM\" on failure.\n */\nexport const formatAmPmSuffix = (dateObj: Date, locale: FrontendLocaleData, config: HassConfig): string => {\n  try {\n    const formatter = new Intl.DateTimeFormat(locale.language, {\n      hour: \"numeric\",\n      hour12: true,\n      timeZone: resolveTimeZone(locale.time_zone, config.time_zone),\n    });\n    const parts = formatter.formatToParts(dateObj);\n    const period = parts.find((p) => p.type === \"dayPeriod\")?.value;\n    return period || (dateObj.getHours() >= 12 ? \"PM\" : \"AM\");\n  } catch {\n    return dateObj.getHours() >= 12 ? \"PM\" : \"AM\";\n  }\n};\n"],"names":["RESOLVED_TIME_ZONE","LOCAL_TIME_ZONE","resolveTimeZone","option","serverTimeZone","TimeFormat","TimeZone","shouldUseAmPm","locale","testLanguage","DAY_IN_MILLISECONDS","HOUR_IN_MILLISECONDS","MINUTE_IN_MILLISECONDS","SECOND_IN_MILLISECONDS","UNIT_TO_MILLISECOND_CONVERT","formatDuration","duration","units","millisecondsToDuration","leftPad","num","digits","paddedNum","i","d","h","m","s","ms","regexp","isTimestamp","input","regExpString","regExp","regExpNoStringEnd","isDate","allowCharsAfterDate","checkValidDate","date","singleEntryMemo","factory","lastArgs","lastResult","args","v","dateFormatterMem","serverTZ","timeFormatterMem","timeWithoutAmPmFormatterMem","hourOnlyFormatterMem","minuteOnlyFormatterMem","secondOnlyFormatterMem","dateTimeFormatterMem","dateTimeWithSecondsFormatterMem","shortDateTimeWithYearMem","shortDateTimeMem","browserDefaultsFormatterMem","dateWeekdayDayMem","dateShortMem","dateVeryShortMem","dateMonthYearMem","dateMonthMem","dateYearMem","dateWeekdayMem","dateWeekdayShortMem","dateNumericBaseMem","localeString","DateFormat","formatDate","dateObj","config","formatTime","formatTimeWithoutAmPm","formatHour","p","formatMinute","formatSeconds","formatDateTime","formatDateTimeWithSeconds","formatShortDateTime","formatShortDateTimeWithYear","formatShortDateTimeWithConditionalYear","formatDateTimeWithBrowserDefaults","formatDateTimeNumeric","formatDateWeekdayDay","formatDateShort","formatDateVeryShort","formatDateMonthYear","formatDateMonth","formatDateYear","formatDateWeekday","formatDateWeekdayShort","formatDateNumeric","formatter","parts","literal","day","month","year","lastPart","lastLiteral","formatAmPmSuffix"],"mappings":"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"}