{"version":3,"file":"handleSuspendResume.js","sources":["../../../src/HassConnect/handleSuspendResume.ts"],"sourcesContent":["import { Connection } from \"home-assistant-js-websocket\";\n\nexport type ConnectionStatus = \"pending\" | \"disconnected\" | \"pending-suspension\" | \"suspended\" | \"connected\";\n\nexport interface HandleSuspendResumeOptions {\n  /** - suspendWhenHidden: if false, never tear down the connection even when the page is hidden. @default true  */\n  suspendWhenHidden?: boolean;\n  /** hiddenDelayMs: how long (in milliseconds) to wait after \"hidden\" before calling connection.suspend(), defaults to 5 minutes (300000 ms). @default 300000 */\n  hiddenDelayMs?: number;\n  /** debug: if true, logs all visibility/freeze/resume steps to the console. @default false */\n  debug?: boolean;\n  /**\n   * Optional callback that will be called whenever the connection status changes.\n   * The argument is one of:\n   *   - \"pending-suspension\": right after suspendReconnectUntil() is called\n   *   - \"suspended\": when the socket is actually suspended via connection.suspend()\n   *   - \"connected\": when the pending suspension is lifted (i.e. reconnection may resume)\n   */\n  onStatusChange?: (status: ConnectionStatus) => void;\n}\n\n/**\n * Attaches listeners to document for:\n *  - visibilitychange (desktop)\n *  - freeze / resume (mobile/Cordova/etc)\n * to “pause” (suspendReconnectUntil + suspend) when the page is hidden/frozen, and “resume” when it becomes visible/resumes.\n *\n * @param connection - connection object from home-assistant-js-websocket\n * @param options - ptional settings (delay, whether to suspend, debug, status callback)\n * @returns a cleanup function that removes all listeners and clears any pending timeouts\n */\nexport function handleSuspendResume(connection: Connection, options: HandleSuspendResumeOptions = {}): () => void {\n  const {\n    suspendWhenHidden = true,\n    hiddenDelayMs = 300_000, // default 5 minutes\n    debug = false,\n    onStatusChange,\n  } = options;\n\n  // If hiddenDelayMs is 0, suspension happens immediately; otherwise wait that many ms.\n  const DELAY_MS = hiddenDelayMs;\n\n  /**\n   * If non-null, we have a pending “resume” promise’s resolve function.\n   * Once invoked, we lift the suspension.\n   */\n  let pendingResolve: (() => void) | null = null;\n\n  /**\n   * ID of the timeout that will eventually call connection.suspend().\n   * Cleared if the user returns early.\n   */\n  let hiddenTimeoutId: number | null = null;\n\n  /**\n   * True if we’ve already called suspendReconnectUntil(...) and not yet resolved it.\n   * Prevents stacking multiple promises.\n   */\n  let isSuspended = false;\n\n  if (connection.connected) {\n    if (debug) console.log(\"[SR] Connection is already active → handleSuspendResume will manage suspension\");\n    onStatusChange?.(\"connected\");\n  } else {\n    if (debug) console.log(\"[SR] Connection is not active\");\n    onStatusChange?.(\"disconnected\");\n  }\n\n  // helper: when the page/tab goes hidden (or “freeze” fires)\n  function onHidden() {\n    if (debug) console.log(\"[SR] onHidden() triggered\");\n\n    // If the user disabled suspension or we’re already suspended, do nothing.\n    if (!suspendWhenHidden) {\n      if (debug) console.log(\"[SR] suspendWhenHidden is false → skipping suspension\");\n      return;\n    }\n    if (isSuspended) {\n      if (debug) console.log(\"[SR] Already suspended → skipping duplicate suspension\");\n      return;\n    }\n\n    isSuspended = true;\n\n    // Create a fresh “resumePromise”\n    const resumePromise = new Promise<void>((resolve) => {\n      pendingResolve = () => {\n        if (debug) console.log(\"[SR] pendingResolve() called → lifting suspension\");\n        isSuspended = false;\n        pendingResolve = null;\n        resolve();\n        onStatusChange?.(\"connected\");\n      };\n    });\n\n    if (debug) console.log(\"[SR] Calling connection.suspendReconnectUntil(...)\");\n    onStatusChange?.(\"pending-suspension\");\n    connection.suspendReconnectUntil(resumePromise);\n\n    // Wait DELAY_MS before actually closing the socket.\n    if (debug) console.log(`[SR] Starting hidden delay of ${DELAY_MS}ms before actual suspend()`);\n    hiddenTimeoutId = window.setTimeout(() => {\n      hiddenTimeoutId = null;\n      // If still hidden, suspend the connection:\n      if (document.hidden) {\n        if (debug) console.log(\"[SR] Hidden timeout elapsed → calling suspend()\");\n        suspend();\n      } else {\n        // User returned before timeout. Resolve immediately.\n        if (pendingResolve) {\n          if (debug) console.log(\"[SR] Hidden timeout elapsed but page is visible → resolving pendingResolve()\");\n          // potentially unreachable, but just in case!\n          pendingResolve();\n        }\n      }\n    }, DELAY_MS);\n\n    // If the user focuses before DELAY_MS is up, resume immediately:\n    window.addEventListener(\"focus\", onVisibleOrResume, { once: true });\n  }\n\n  // helper when page/tab becomes visible or “resume” fires after freeze\n  function onVisibleOrResume() {\n    if (debug) console.log(\"[SR] onVisibleOrResume() fired (page became visible)\");\n\n    // If we still have a pending hiddenTimeout, clear it:\n    if (hiddenTimeoutId !== null) {\n      clearTimeout(hiddenTimeoutId);\n      hiddenTimeoutId = null;\n      if (debug) console.log(\"[SR] Cleared hiddenTimeoutId (user returned before allotted time)\");\n    }\n\n    // If there’s a pending “resume” promise, resolve it:\n    if (pendingResolve) {\n      if (debug) console.log(\"[SR] Resolving pendingResolve() on actual resume\");\n      // resets isSuspended and pendingResolve itself\n      pendingResolve();\n    }\n  }\n\n  // helpers for the event listeners to attach\n  function visibilityChangeHandler() {\n    if (document.hidden) {\n      if (debug) console.log(\"[SR] visibilitychange → HIDDEN\");\n      onHidden();\n    } else {\n      if (debug) console.log(\"[SR] visibilitychange → VISIBLE\");\n      onVisibleOrResume();\n    }\n  }\n\n  function resumeHandler() {\n    if (debug) console.log(\"[SR] resume event fired\");\n    onVisibleOrResume();\n  }\n\n  function suspend() {\n    if (!connection.connected) {\n      if (debug) console.log(\"[SR] Connection already suspended → skipping suspend()\");\n      return;\n    }\n    onStatusChange?.(\"suspended\");\n    if (debug) console.log(\"[SR] suspend() called → suspending connection\");\n    window.stop();\n    connection.suspend();\n  }\n\n  // wire in event handlers\n  document.addEventListener(\"visibilitychange\", visibilityChangeHandler, false);\n  document.addEventListener(\"freeze\", suspend);\n  document.addEventListener(\"resume\", resumeHandler);\n\n  if (debug) console.log(\"[SR] handleSuspendResume() initialized; debugging is ON\");\n\n  // return the cleanup function that removes all listeners and clears timeouts\n  return () => {\n    if (debug) console.log(\"[SR] cleanup() called → removing listeners & clearing timeouts\");\n\n    document.removeEventListener(\"visibilitychange\", visibilityChangeHandler, false);\n    document.removeEventListener(\"freeze\", suspend);\n    document.removeEventListener(\"resume\", resumeHandler);\n    window.removeEventListener(\"focus\", onVisibleOrResume);\n\n    if (hiddenTimeoutId !== null) {\n      if (debug) console.log(\"[SR] cleanup: Clearing hiddenTimeoutId\");\n      clearTimeout(hiddenTimeoutId);\n      hiddenTimeoutId = null;\n    }\n    // If there’s still a pendingResolve (Promise not resolved), resolve it now so reconnection can recover:\n    if (pendingResolve) {\n      if (debug) console.log(\"[SR] cleanup: Resolving pendingResolve() to let reconnection proceed\");\n      pendingResolve();\n      pendingResolve = null;\n      isSuspended = false;\n    }\n  };\n}\n"],"names":["handleSuspendResume","connection","options","suspendWhenHidden","hiddenDelayMs","debug","onStatusChange","DELAY_MS","pendingResolve","hiddenTimeoutId","isSuspended","onHidden","resumePromise","resolve","suspend","onVisibleOrResume","visibilityChangeHandler","resumeHandler"],"mappings":"gFA+BO,SAASA,EAAoBC,EAAwBC,EAAsC,GAAgB,CAChH,KAAM,CACJ,kBAAAC,EAAoB,GACpB,cAAAC,EAAgB,IAChB,MAAAC,EAAQ,GACR,eAAAC,CAAA,EACEJ,EAGEK,EAAWH,EAMjB,IAAII,EAAsC,KAMtCC,EAAiC,KAMjCC,EAAc,GAEdT,EAAW,WACTI,GAAO,QAAQ,IAAI,gFAAgF,EACvGC,IAAiB,WAAW,IAExBD,GAAO,QAAQ,IAAI,+BAA+B,EACtDC,IAAiB,cAAc,GAIjC,SAASK,GAAW,CAIlB,GAHIN,GAAO,QAAQ,IAAI,2BAA2B,EAG9C,CAACF,EAAmB,CAClBE,GAAO,QAAQ,IAAI,uDAAuD,EAC9E,MACF,CACA,GAAIK,EAAa,CACXL,GAAO,QAAQ,IAAI,wDAAwD,EAC/E,MACF,CAEAK,EAAc,GAGd,MAAME,EAAgB,IAAI,QAAeC,GAAY,CACnDL,EAAiB,IAAM,CACjBH,GAAO,QAAQ,IAAI,mDAAmD,EAC1EK,EAAc,GACdF,EAAiB,KACjBK,EAAA,EACAP,IAAiB,WAAW,CAC9B,CACF,CAAC,EAEGD,GAAO,QAAQ,IAAI,oDAAoD,EAC3EC,IAAiB,oBAAoB,EACrCL,EAAW,sBAAsBW,CAAa,EAG1CP,GAAO,QAAQ,IAAI,iCAAiCE,CAAQ,4BAA4B,EAC5FE,EAAkB,OAAO,WAAW,IAAM,CACxCA,EAAkB,KAEd,SAAS,QACPJ,GAAO,QAAQ,IAAI,iDAAiD,EACxES,EAAA,GAGIN,IACEH,GAAO,QAAQ,IAAI,8EAA8E,EAErGG,EAAA,EAGN,EAAGD,CAAQ,EAGX,OAAO,iBAAiB,QAASQ,EAAmB,CAAE,KAAM,GAAM,CACpE,CAGA,SAASA,GAAoB,CACvBV,GAAO,QAAQ,IAAI,sDAAsD,EAGzEI,IAAoB,OACtB,aAAaA,CAAe,EAC5BA,EAAkB,KACdJ,GAAO,QAAQ,IAAI,mEAAmE,GAIxFG,IACEH,GAAO,QAAQ,IAAI,kDAAkD,EAEzEG,EAAA,EAEJ,CAGA,SAASQ,GAA0B,CAC7B,SAAS,QACPX,GAAO,QAAQ,IAAI,gCAAgC,EACvDM,EAAA,IAEIN,GAAO,QAAQ,IAAI,iCAAiC,EACxDU,EAAA,EAEJ,CAEA,SAASE,GAAgB,CACnBZ,GAAO,QAAQ,IAAI,yBAAyB,EAChDU,EAAA,CACF,CAEA,SAASD,GAAU,CACjB,GAAI,CAACb,EAAW,UAAW,CACrBI,GAAO,QAAQ,IAAI,wDAAwD,EAC/E,MACF,CACAC,IAAiB,WAAW,EACxBD,GAAO,QAAQ,IAAI,+CAA+C,EACtE,OAAO,KAAA,EACPJ,EAAW,QAAA,CACb,CAGA,gBAAS,iBAAiB,mBAAoBe,EAAyB,EAAK,EAC5E,SAAS,iBAAiB,SAAUF,CAAO,EAC3C,SAAS,iBAAiB,SAAUG,CAAa,EAE7CZ,GAAO,QAAQ,IAAI,yDAAyD,EAGzE,IAAM,CACPA,GAAO,QAAQ,IAAI,gEAAgE,EAEvF,SAAS,oBAAoB,mBAAoBW,EAAyB,EAAK,EAC/E,SAAS,oBAAoB,SAAUF,CAAO,EAC9C,SAAS,oBAAoB,SAAUG,CAAa,EACpD,OAAO,oBAAoB,QAASF,CAAiB,EAEjDN,IAAoB,OAClBJ,GAAO,QAAQ,IAAI,wCAAwC,EAC/D,aAAaI,CAAe,EAC5BA,EAAkB,MAGhBD,IACEH,GAAO,QAAQ,IAAI,sEAAsE,EAC7FG,EAAA,EACAA,EAAiB,KACjBE,EAAc,GAElB,CACF"}