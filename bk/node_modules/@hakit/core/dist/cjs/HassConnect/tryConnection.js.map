{"version":3,"file":"tryConnection.js","sources":["../../../src/HassConnect/tryConnection.ts"],"sourcesContent":["// types\nimport type { Connection, getAuthOptions as AuthOptions, Auth } from \"home-assistant-js-websocket\";\n// methods\nimport {\n  getAuth,\n  createLongLivedTokenAuth,\n  createConnection,\n  ERR_HASS_HOST_REQUIRED,\n  ERR_CONNECTION_LOST,\n  ERR_CANNOT_CONNECT,\n  ERR_INVALID_AUTH,\n  ERR_INVALID_HTTPS_TO_HTTP,\n} from \"home-assistant-js-websocket\";\nimport { saveTokens, loadTokens, clearTokens } from \"./token-storage\";\n\nexport function handleError(err: number | string | Error | unknown, hassToken?: string): string {\n  const getMessage = () => {\n    switch (err) {\n      case ERR_INVALID_AUTH:\n        return `ERR_INVALID_AUTH: Invalid authentication. ${hassToken ? 'Check your \"Long-Lived Access Token\".' : \"\"}`;\n      case ERR_CANNOT_CONNECT:\n        return \"ERR_CANNOT_CONNECT: Unable to connect\";\n      case ERR_CONNECTION_LOST:\n        return \"ERR_CONNECTION_LOST: Lost connection to home assistant.\";\n      case ERR_HASS_HOST_REQUIRED:\n        return \"ERR_HASS_HOST_REQUIRED: Please enter a Home Assistant URL.\";\n      case ERR_INVALID_HTTPS_TO_HTTP:\n        return 'ERR_INVALID_HTTPS_TO_HTTP: Cannot connect to Home Assistant instances over \"http://\".';\n      default:\n        return null;\n    }\n  };\n  const message = getMessage();\n  if (message !== null) return message;\n  return (\n    (\n      err as {\n        error: string;\n      }\n    )?.error ||\n    (err as Error)?.message ||\n    `Unknown Error (${err})`\n  );\n}\ntype ConnectionResponse =\n  | {\n      type: \"success\";\n      connection: Connection;\n      auth: Auth;\n    }\n  | {\n      type: \"error\";\n      error: string;\n    }\n  | {\n      type: \"failed\";\n      cannotConnect: true;\n    };\n\ntype ConnectionType = \"auth-callback\" | \"user-request\" | \"saved-tokens\" | \"inherited-auth\" | \"provided-token\";\n\nfunction getInheritedConnection(): typeof window.hassConnection | undefined {\n  try {\n    return window.top?.hassConnection;\n  } catch (e) {\n    console.error(\"Error getting inherited connection\", e);\n    return undefined;\n  }\n}\n\nfunction determineConnectionType(hassUrl: string, hassToken?: string): ConnectionType {\n  const isAuthCallback = location && location.search.includes(\"auth_callback=1\");\n  const hasHassConnection = !!getInheritedConnection();\n  const providedToken = !!hassToken;\n  // when we have a hass connection, we don't need to validate the tokens\n  // so removing the tokens if values are different and we have a connection are not needed.\n  const savedTokens = !!loadTokens(hassUrl, false);\n\n  switch (true) {\n    case isAuthCallback:\n      return \"auth-callback\";\n    case hasHassConnection:\n      return \"inherited-auth\";\n    case providedToken:\n      return \"provided-token\";\n    case savedTokens:\n      return \"saved-tokens\";\n    default:\n      return \"user-request\";\n  }\n}\n\nexport const tryConnection = async (hassUrl: string, hassToken?: string): Promise<ConnectionResponse> => {\n  const connectionType = determineConnectionType(hassUrl, hassToken);\n\n  if (connectionType === \"inherited-auth\") {\n    try {\n      // if we've hit this connect type, the connection will be available\n      const { auth, conn } = (await getInheritedConnection()) as { conn: Connection; auth: Auth };\n      return {\n        type: \"success\",\n        connection: conn,\n        auth: auth,\n      };\n    } catch (e) {\n      const message = handleError(e, hassToken);\n      return {\n        type: \"error\",\n        error: message,\n      };\n    }\n  }\n  if (connectionType === \"provided-token\" && hassToken) {\n    try {\n      const auth = await createLongLivedTokenAuth(hassUrl, hassToken);\n      const connection = await createConnection({ auth });\n      return {\n        type: \"success\",\n        connection,\n        auth,\n      };\n    } catch (e) {\n      const message = handleError(e, hassToken);\n      return {\n        type: \"error\",\n        error: message,\n      };\n    }\n  }\n\n  const options: AuthOptions = {\n    saveTokens,\n    loadTokens: () => Promise.resolve(loadTokens(hassUrl)),\n  };\n\n  if (hassUrl && connectionType === \"user-request\") {\n    options.hassUrl = hassUrl;\n    if (options.hassUrl === \"\") {\n      return {\n        type: \"error\",\n        error: \"Please enter a Home Assistant URL.\",\n      };\n    }\n    if (options.hassUrl.indexOf(\"://\") === -1) {\n      return {\n        type: \"error\",\n        error: \"Please enter your full URL, including the protocol part (https://).\",\n      };\n    }\n    try {\n      new URL(options.hassUrl);\n    } catch (err: unknown) {\n      console.error(\"Error:\", err);\n      return {\n        type: \"error\",\n        error: \"Invalid URL\",\n      };\n    }\n  }\n  let auth: Auth;\n\n  try {\n    auth = await getAuth(options);\n  } catch (err: unknown) {\n    if (\n      (\n        err as {\n          error: string;\n        }\n      )?.error === \"invalid_grant\"\n    ) {\n      // the refresh token is incorrect and most likely from another browser / instance\n      clearTokens();\n      return tryConnection(hassUrl, hassToken);\n    }\n    if (connectionType === \"saved-tokens\" && err === ERR_CANNOT_CONNECT) {\n      return {\n        type: \"failed\",\n        cannotConnect: true,\n      };\n    }\n    return {\n      type: \"error\",\n      error: handleError(err, hassToken),\n    };\n  } finally {\n    // Clear url if we have a auth callback in url.\n    if (location && location.search.includes(\"auth_callback=1\")) {\n      history.replaceState(null, \"\", location.pathname);\n    }\n  }\n  let connection: Connection;\n  try {\n    // create the connection to the websockets\n    connection = await createConnection({ auth });\n  } catch (err) {\n    // In case of saved tokens, silently solve problems.\n    if (connectionType === \"saved-tokens\") {\n      if (err === ERR_CANNOT_CONNECT) {\n        return {\n          type: \"failed\",\n          cannotConnect: true,\n        };\n      } else if (err === ERR_INVALID_AUTH) {\n        saveTokens(null);\n      }\n    }\n    return {\n      type: \"error\",\n      error: handleError(err, hassToken),\n    };\n  }\n  return {\n    type: \"success\",\n    connection,\n    auth,\n  };\n};\n"],"names":["handleError","err","hassToken","message","ERR_INVALID_AUTH","ERR_CANNOT_CONNECT","ERR_CONNECTION_LOST","ERR_HASS_HOST_REQUIRED","ERR_INVALID_HTTPS_TO_HTTP","getInheritedConnection","e","determineConnectionType","hassUrl","isAuthCallback","hasHassConnection","providedToken","savedTokens","loadTokens","tryConnection","connectionType","auth","conn","createLongLivedTokenAuth","createConnection","options","saveTokens","getAuth","clearTokens","connection"],"mappings":"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"}