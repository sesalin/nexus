{"version":3,"file":"store.js","sources":["../../../src/ThemeProvider/store.ts"],"sourcesContent":["import { create } from \"zustand\";\nimport { DEFAULT_THEME_OPTIONS, DEFAULT_BREAKPOINTS } from \"./constants\";\nimport { BreakPoints, BreakPointsWithXlg } from \"@components\";\n\nexport type ThemeStore = {\n  theme: {\n    /** the tint factor to apply to the shade colors @default 0.8 */\n    tint?: number;\n    /** the color hue shift value @default 220 */\n    hue?: number;\n    /** the color saturation value @default 60 */\n    saturation?: number;\n    /** the color lightness value @default 54 */\n    lightness?: number;\n    /** the contrast threshold for text @default 65 */\n    contrastThreshold?: number;\n    /** dark mode or light mode @default true */\n    darkMode?: boolean;\n  };\n  /** Will merge input theme values with the default values, undefined values passed through the setTheme function will be ignored */\n  setTheme: (partialTheme: ThemeStore[\"theme\"]) => void;\n  /** getter for breakpoints, if using @hakit/components, the breakpoints are stored here to retrieve in different locations */\n  breakpoints: BreakPointsWithXlg;\n  /** setter for breakpoints, intended for internal use only */\n  setBreakpoints: (breakpoints: BreakPoints) => void;\n};\n\nexport const useThemeStore = create<ThemeStore>((set) => ({\n  theme: {\n    hue: DEFAULT_THEME_OPTIONS.hue,\n    lightness: DEFAULT_THEME_OPTIONS.lightness,\n    tint: DEFAULT_THEME_OPTIONS.tint,\n    saturation: DEFAULT_THEME_OPTIONS.saturation,\n    darkMode: DEFAULT_THEME_OPTIONS.darkMode,\n    contrastThreshold: DEFAULT_THEME_OPTIONS.contrastThreshold,\n  },\n  setTheme: (partialTheme) => {\n    set((state) => ({\n      theme: {\n        ...state.theme,\n        // Only spread properties that are not undefined\n        ...Object.fromEntries(Object.entries(partialTheme).filter(([, value]) => value !== undefined)),\n      },\n    }));\n  },\n  breakpoints: DEFAULT_BREAKPOINTS,\n  setBreakpoints: (breakpoints) => {\n    // there should at least be ONE breakpoint defined, get the largest value from the breakpoints object\n    // if the object is empty or no values with numbers, it should throw an error\n    if (Object.keys(breakpoints).length === 0) {\n      throw new Error(\"No breakpoints provided\");\n    }\n    const largestValue = Math.max(...Object.values(breakpoints).filter((value) => typeof value === \"number\"));\n    if (largestValue === -Infinity) {\n      throw new Error(\"No valid breakpoints provided\");\n    }\n    set({\n      breakpoints: {\n        ...breakpoints,\n        xlg: largestValue + 1,\n      },\n    });\n  },\n}));\n"],"names":["useThemeStore","create","set","theme","hue","DEFAULT_THEME_OPTIONS","lightness","tint","saturation","darkMode","contrastThreshold","setTheme","partialTheme","state","Object","fromEntries","entries","filter","value","undefined","breakpoints","DEFAULT_BREAKPOINTS","setBreakpoints","keys","length","Error","largestValue","Math","max","values","xlg"],"mappings":";;AA2BO,MAAMA,IAAgBC,EAAoBC,CAAAA,OAAS;AAAA,EACxDC,OAAO;AAAA,IACLC,KAAKC,EAAsBD;AAAAA,IAC3BE,WAAWD,EAAsBC;AAAAA,IACjCC,MAAMF,EAAsBE;AAAAA,IAC5BC,YAAYH,EAAsBG;AAAAA,IAClCC,UAAUJ,EAAsBI;AAAAA,IAChCC,mBAAmBL,EAAsBK;AAAAA,EAAAA;AAAAA,EAE3CC,UAAWC,CAAAA,MAAiB;AAC1BV,IAAAA,EAAKW,CAAAA,OAAW;AAAA,MACdV,OAAO;AAAA,QACL,GAAGU,EAAMV;AAAAA;AAAAA,QAET,GAAGW,OAAOC,YAAYD,OAAOE,QAAQJ,CAAY,EAAEK,OAAO,CAAC,CAAA,EAAGC,CAAK,MAAMA,MAAUC,MAAS,CAAC;AAAA,MAAA;AAAA,IAC/F,EACA;AAAA,EACJ;AAAA,EACAC,aAAaC;AAAAA,EACbC,gBAAiBF,CAAAA,MAAgB;AAG/B,QAAIN,OAAOS,KAAKH,CAAW,EAAEI,WAAW;AACtC,YAAM,IAAIC,MAAM,yBAAyB;AAE3C,UAAMC,IAAeC,KAAKC,IAAI,GAAGd,OAAOe,OAAOT,CAAW,EAAEH,OAAQC,CAAAA,MAAU,OAAOA,KAAU,QAAQ,CAAC;AACxG,QAAIQ,MAAiB;AACnB,YAAM,IAAID,MAAM,+BAA+B;AAEjDvB,IAAAA,EAAI;AAAA,MACFkB,aAAa;AAAA,QACX,GAAGA;AAAAA,QACHU,KAAKJ,IAAe;AAAA,MAAA;AAAA,IACtB,CACD;AAAA,EACH;AACF,EAAE;"}