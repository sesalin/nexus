{"version":3,"file":"formatter.js","sources":["../../../../src/Cards/TimeCard/formatter.tsx"],"sourcesContent":["import {\n  CustomFormatters,\n  DateParts,\n  Formatters,\n  FormatterMask,\n  DatePartName,\n  FormatOptions,\n  FormatFunction,\n  Parser,\n  Token,\n} from \"./types\";\nimport { AmOrPm } from \"./shared\";\nimport { Fragment, cloneElement, isValidElement } from \"react\";\n\nconst parsers: Map<string, Parser> = new Map();\n\nconst intlFormattersOptions = [\n  {\n    weekday: \"long\",\n    year: \"numeric\",\n    month: \"2-digit\",\n    day: \"2-digit\",\n    hour: \"2-digit\",\n    minute: \"2-digit\",\n    second: \"2-digit\",\n  },\n  {\n    month: \"long\",\n    hour: \"2-digit\",\n    hour12: false,\n  },\n] satisfies Partial<Intl.DateTimeFormatOptions>[];\n\nexport function createDateFormatter(customFormatters: CustomFormatters): FormatFunction {\n  return function intlFormatDate(date: Date, format: string, options?: FormatOptions): React.ReactNode {\n    const tokens = parseDate(date, options);\n    const output = formatDate(customFormatters, format, tokens, date);\n    return output;\n  };\n}\n\nconst createIntlFormatterWith = (options: FormatOptions): Intl.DateTimeFormat[] =>\n  intlFormattersOptions.map(\n    (intlFormatterOptions) =>\n      new Intl.DateTimeFormat(options.locale, {\n        ...intlFormatterOptions,\n        timeZone: options.timezone,\n      }),\n  );\n\nconst longTokensTransformer = (token: Token): Token =>\n  (token.type !== \"literal\" ? { type: `l${token.type}`, value: token.value } : token) as Token;\n\nconst datePartsReducer = (parts: DateParts, token: Token): DateParts => {\n  parts[token.type as DatePartName] = token.value;\n  return parts;\n};\n\nconst tokenize = (intlFormatter: Intl.DateTimeFormat, date: Date): Token[] =>\n  intlFormatter.formatToParts(date).filter((token) => token.type !== \"literal\") as Token[];\n\nconst normalize = (parts: DateParts): DateParts => {\n  // Chrome <= 71 and Node >= 10 incorrectly case `dayperiod` (#4)\n  // dayPeriod will be undefined for 24 hour clocks so fall back to empty string\n  parts.dayPeriod =\n    parts.dayPeriod ||\n    // @ts-expect-error - see note above\n    parts.dayperiod ||\n    \"\";\n  // @ts-expect-error - see note above\n  delete parts.dayperiod;\n\n  // Chrome >= 80 has a bug going over 24h\n  parts.lhour = (\"0\" + (Number(parts.lhour) % 24)).slice(-2);\n\n  return parts;\n};\n\nconst createParser = (options: FormatOptions): Parser => {\n  const [intlFormatter, intlFormatterLong] = createIntlFormatterWith(options);\n\n  return function parseDateImpl(date: Date): DateParts {\n    const tokens = tokenize(intlFormatter, date);\n    const longTokens = tokenize(intlFormatterLong, date).map(longTokensTransformer);\n    const allTokens = [...tokens, ...longTokens];\n    const parts = allTokens.reduce(datePartsReducer, {} as DateParts);\n\n    return normalize(parts);\n  };\n};\n\nfunction parseDate(date: Date, options: FormatOptions = {}): DateParts {\n  const key = `${options.locale}${options.timezone}`;\n\n  let parser = parsers.get(key);\n  if (!parser) {\n    parser = createParser(options);\n    parsers.set(key, parser);\n  }\n\n  return parser(date);\n}\n\nexport function daySuffix(day: number) {\n  let suffix = \"\";\n  switch (day) {\n    case 1:\n    case 21:\n    case 31:\n      suffix = \"st\";\n      break;\n    case 2:\n    case 22:\n      suffix = \"nd\";\n      break;\n    case 3:\n    case 23:\n      suffix = \"rd\";\n      break;\n    default:\n      suffix = \"th\";\n  }\n  return suffix;\n}\n\nconst defaultPattern = \"[YMDxdAaHhms]+\";\n\nconst formatters: Formatters = {\n  YYYY: (parts) => parts.year,\n  YY: (parts) => parts.year.slice(-2),\n  MMMM: (parts) => parts.lmonth,\n  MMM: (parts) => parts.lmonth.slice(0, 3),\n  MM: (parts) => parts.month,\n  DD: (parts) => parts.day,\n  DDx: (parts) => `${parts.day}${daySuffix(parseInt(parts.day))}`,\n  dd: (parts) => `${parseInt(parts.day, 10)}`,\n  ddx: (parts) => `${parseInt(parts.day, 10)}${daySuffix(parseInt(parts.day))}`,\n  dddd: (parts) => parts.weekday,\n  ddd: (parts) => parts.weekday.slice(0, 3),\n  A: (parts) => <AmOrPm className=\"time-suffix\">{parts.dayPeriod}</AmOrPm>,\n  a: (parts) => <AmOrPm className=\"time-suffix\">{parts.dayPeriod.toLowerCase()}</AmOrPm>,\n  // XXX: fix Chrome 80+ bug going over 24h\n  HH: (parts) => (\"0\" + (Number(parts.lhour) % 24)).slice(-2),\n  hh: (parts) => parts.hour,\n  mm: (parts) => parts.minute,\n  ss: (parts) => parts.second,\n};\n\nconst createCustomPattern = (customFormatters: CustomFormatters) => Object.keys(customFormatters).reduce((_, key) => `|${key}`, \"\");\n\nfunction formatDate(customFormatters: CustomFormatters, format: string, parts: DateParts, date: Date): React.ReactNode {\n  const literalPattern = \"\\\\[([^\\\\]]+)\\\\]|\";\n  const customPattern = createCustomPattern(customFormatters);\n  const patternRegexp = new RegExp(`${literalPattern}${defaultPattern}${customPattern}`, \"g\");\n\n  const allFormatters = { ...formatters, ...customFormatters };\n  // We'll accumulate text/JSX in an array\n  const tokens: React.ReactNode[] = [];\n  let lastIndex = 0;\n  // @ts-expect-error - will fix later\n  format.replace(patternRegexp, (mask: FormatterMask, literal: string, offset: number) => {\n    // 'offset' is the index of this match within the full format string\n\n    // Push any text that occurs before this match\n    if (offset > lastIndex) {\n      const val = format.slice(lastIndex, offset);\n      if (val.length > 0 && val.trim().length === 0) {\n        // whitespace char\n        tokens.push(<span className=\"whitespace\">&nbsp;</span>);\n      } else {\n        tokens.push(val);\n      }\n    }\n    lastIndex = offset + mask.length;\n\n    if (literal) {\n      // If we matched [literal text], just push that as plain text\n      tokens.push(literal);\n    } else {\n      // Everything else just push normally\n      tokens.push(allFormatters[mask](parts, date));\n    }\n    // Return an empty string to discard the normal replace output\n    return \"\";\n  });\n  // If there's still text remaining after the last match, push it\n  if (lastIndex < format.length) {\n    tokens.push(format.slice(lastIndex));\n  }\n  // Finally, render the HTML string inside React. We must do dangerouslySetInnerHTML\n  // so that <div> ... </div> is recognized as HTML, not plain text:\n  return (\n    <>\n      {tokens.map((tok, i) => {\n        // Strings need to be wrapped so they can carry a key\n        if (typeof tok === \"string\") {\n          return <Fragment key={i}>{tok}</Fragment>;\n        }\n\n        // Valid elements: clone to add/override the key\n        if (isValidElement(tok)) {\n          return cloneElement(tok, { key: i });\n        }\n\n        // Anything else (null, boolean) can be returned as-is\n        return tok;\n      })}\n    </>\n  );\n}\n"],"names":["parsers","Map","intlFormattersOptions","weekday","year","month","day","hour","minute","second","hour12","createDateFormatter","customFormatters","date","format","options","tokens","parseDate","formatDate","createIntlFormatterWith","map","intlFormatterOptions","Intl","DateTimeFormat","locale","timeZone","timezone","longTokensTransformer","token","type","value","datePartsReducer","parts","tokenize","intlFormatter","formatToParts","filter","normalize","dayPeriod","dayperiod","lhour","Number","slice","createParser","intlFormatterLong","longTokens","reduce","key","parser","get","set","daySuffix","suffix","defaultPattern","formatters","YYYY","YY","MMMM","lmonth","MMM","MM","DD","DDx","parseInt","dd","ddx","dddd","ddd","A","jsx","AmOrPm","a","toLowerCase","HH","hh","mm","ss","createCustomPattern","Object","keys","_","literalPattern","customPattern","patternRegexp","RegExp","allFormatters","lastIndex","replace","mask","literal","offset","val","length","trim","push","Fragment","tok","i","isValidElement","cloneElement"],"mappings":"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"}