import { j as d, F as x } from "../../../emotion-react-jsx-runtime.browser.esm-BErL7L7Y.js";
import { AmOrPm as p } from "./shared.js";
import { Fragment as P, isValidElement as D, cloneElement as M } from "react";
const f = /* @__PURE__ */ new Map(), F = [{
  weekday: "long",
  year: "numeric",
  month: "2-digit",
  day: "2-digit",
  hour: "2-digit",
  minute: "2-digit",
  second: "2-digit"
}, {
  month: "long",
  hour: "2-digit",
  hour12: !1
}];
function O(e) {
  return function(n, r, o) {
    const i = b(n, o);
    return j(e, r, i, n);
  };
}
const w = (e) => F.map((t) => new Intl.DateTimeFormat(e.locale, {
  ...t,
  timeZone: e.timezone
})), k = (e) => e.type !== "literal" ? {
  type: `l${e.type}`,
  value: e.value
} : e, I = (e, t) => (e[t.type] = t.value, e), g = (e, t) => e.formatToParts(t).filter((n) => n.type !== "literal"), T = (e) => (e.dayPeriod = e.dayPeriod || // @ts-expect-error - see note above
e.dayperiod || "", delete e.dayperiod, e.lhour = ("0" + Number(e.lhour) % 24).slice(-2), e), Y = (e) => {
  const [t, n] = w(e);
  return function(o) {
    const i = g(t, o), u = g(n, o).map(k), a = [...i, ...u].reduce(I, {});
    return T(a);
  };
};
function b(e, t = {}) {
  const n = `${t.locale}${t.timezone}`;
  let r = f.get(n);
  return r || (r = Y(t), f.set(n, r)), r(e);
}
function $(e) {
  let t = "";
  switch (e) {
    case 1:
    case 21:
    case 31:
      t = "st";
      break;
    case 2:
    case 22:
      t = "nd";
      break;
    case 3:
    case 23:
      t = "rd";
      break;
    default:
      t = "th";
  }
  return t;
}
const N = "[YMDxdAaHhms]+", v = {
  YYYY: (e) => e.year,
  YY: (e) => e.year.slice(-2),
  MMMM: (e) => e.lmonth,
  MMM: (e) => e.lmonth.slice(0, 3),
  MM: (e) => e.month,
  DD: (e) => e.day,
  DDx: (e) => `${e.day}${$(parseInt(e.day))}`,
  dd: (e) => `${parseInt(e.day, 10)}`,
  ddx: (e) => `${parseInt(e.day, 10)}${$(parseInt(e.day))}`,
  dddd: (e) => e.weekday,
  ddd: (e) => e.weekday.slice(0, 3),
  A: (e) => /* @__PURE__ */ d(p, { className: "time-suffix", children: e.dayPeriod }),
  a: (e) => /* @__PURE__ */ d(p, { className: "time-suffix", children: e.dayPeriod.toLowerCase() }),
  // XXX: fix Chrome 80+ bug going over 24h
  HH: (e) => ("0" + Number(e.lhour) % 24).slice(-2),
  hh: (e) => e.hour,
  mm: (e) => e.minute,
  ss: (e) => e.second
}, z = (e) => Object.keys(e).reduce((t, n) => `|${n}`, "");
function j(e, t, n, r) {
  const o = "\\[([^\\]]+)\\]|", i = z(e), u = new RegExp(`${o}${N}${i}`, "g"), y = {
    ...v,
    ...e
  }, a = [];
  let l = 0;
  return t.replace(u, (s, c, m) => {
    if (m > l) {
      const h = t.slice(l, m);
      h.length > 0 && h.trim().length === 0 ? a.push(/* @__PURE__ */ d("span", { className: "whitespace", children: "Â " })) : a.push(h);
    }
    return l = m + s.length, c ? a.push(c) : a.push(y[s](n, r)), "";
  }), l < t.length && a.push(t.slice(l)), /* @__PURE__ */ d(x, { children: a.map((s, c) => typeof s == "string" ? /* @__PURE__ */ d(P, { children: s }, c) : D(s) ? M(s, {
    key: c
  }) : s) });
}
export {
  O as createDateFormatter,
  $ as daySuffix
};
//# sourceMappingURL=formatter.js.map
