{"version":3,"file":"Marquee.js","sources":["../../../../src/Cards/MediaPlayerCard/Marquee.tsx"],"sourcesContent":["import {\n  Fragment,\n  useEffect,\n  useState,\n  useRef,\n  useCallback,\n  useMemo,\n  ReactNode,\n  CSSProperties,\n  FC,\n  forwardRef,\n  Children,\n  RefAttributes,\n  RefObject,\n} from \"react\";\nimport styled from \"@emotion/styled\";\n\nconst StyledMarquee = styled.div`\n  overflow-x: hidden !important;\n  display: flex !important;\n  flex-direction: row !important;\n  position: relative;\n  width: var(--ha-marquee-width);\n  transform: var(--ha-marquee-transform);\n\n  &:hover div {\n    animation-play-state: var(--ha-marquee-pause-on-hover);\n  }\n\n  &:active div {\n    animation-play-state: var(--ha-marquee-pause-on-click);\n  }\n\n  .overlay {\n    position: absolute;\n    width: 100%;\n    height: 100%;\n\n    &::before,\n    &::after {\n      background: linear-gradient(to right, var(--ha-marquee-gradient-color));\n      content: \"\";\n      height: 100%;\n      position: absolute;\n      width: var(--ha-marquee-gradient-width);\n      z-index: 2;\n    }\n\n    &::after {\n      right: 0;\n      top: 0;\n      transform: rotateZ(180deg);\n    }\n\n    &::before {\n      left: 0;\n      top: 0;\n    }\n  }\n\n  .marquee {\n    flex: 0 0 auto;\n    min-width: var(--ha-marquee-min-width);\n    z-index: 1;\n    display: flex;\n    flex-direction: row;\n    align-items: center;\n    animation: scroll var(--ha-marquee-duration) linear var(--ha-marquee-delay) var(--ha-marquee-iteration-count);\n    animation-play-state: var(--ha-marquee-play);\n    animation-delay: var(--ha-marquee-delay);\n    animation-direction: var(--ha-marquee-direction);\n\n    @keyframes scroll {\n      0% {\n        transform: translateX(0%);\n      }\n      100% {\n        transform: translateX(-100%);\n      }\n    }\n  }\n\n  .initial-child-container {\n    flex: 0 0 auto;\n    display: flex;\n    min-width: auto;\n    flex-direction: row;\n  }\n\n  .child {\n    transform: var(--ha-marquee-transform);\n    &.last-child {\n      padding-right: var(--ha-marquee-padding-right);\n    }\n  }\n`;\n\nexport type MarqueeProps = {\n  /**\n   * @description Inline style for the container div\n   * @type {CSSProperties}\n   * @default {}\n   */\n  style?: CSSProperties;\n  /**\n   * @description Class name to style the container div\n   * @type {string}\n   * @default \"\"\n   */\n  className?: string;\n  /**\n   * @description Whether to automatically fill blank space in the marquee with copies of the children or not\n   * @type {boolean}\n   * @default false\n   */\n  autoFill?: boolean;\n  /**\n   * @description Whether to play or pause the marquee\n   * @type {boolean}\n   * @default true\n   */\n  play?: boolean;\n  /**\n   * @description Whether to pause the marquee when hovered\n   * @type {boolean}\n   * @default false\n   */\n  pauseOnHover?: boolean;\n  /**\n   * @description Whether to pause the marquee when clicked\n   * @type {boolean}\n   * @default false\n   */\n  pauseOnClick?: boolean;\n  /**\n   * @description The direction the marquee is sliding\n   * @type {\"left\" | \"right\" | \"up\" | \"down\"}\n   * @default \"left\"\n   */\n  direction?: \"left\" | \"right\" | \"up\" | \"down\";\n  /**\n   * @description Speed calculated as pixels/second\n   * @type {number}\n   * @default 50\n   */\n  speed?: number;\n  /**\n   * @description Duration to delay the animation after render, in seconds\n   * @type {number}\n   * @default 0\n   */\n  delay?: number;\n  /**\n   * @description The number of times the marquee should loop, 0 is equivalent to infinite\n   * @type {number}\n   * @default 0\n   */\n  loop?: number;\n  /**\n   * @description Whether to show the gradient or not\n   * @type {boolean}\n   * @default false\n   */\n  gradient?: boolean;\n  /**\n   * @description The rgb color of the gradient as an array of length 3\n   * @type {Array<number>} of length 3\n   * @default [255, 255, 255]\n   */\n  gradientColor?: [number, number, number];\n  /**\n   * @description The width of the gradient on either side\n   * @type {number | string}\n   * @default 200\n   */\n  gradientWidth?: number | string;\n  /**\n   * @description A callback for when the marquee finishes scrolling and stops. Only calls if loop is non-zero.\n   * @type {() => void}\n   * @default null\n   */\n  onFinish?: () => void;\n  /**\n   * @description A callback for when the marquee finishes a loop. Does not call if maximum loops are reached (use onFinish instead).\n   * @type {() => void}\n   * @default null\n   */\n  onCycleComplete?: () => void;\n  /**\n   * @description: A callback function that is invoked once the marquee has finished mounting. It can be utilized to recalculate the page size, if necessary.\n   * @type {() => void}\n   * @default null\n   */\n  onMount?: () => void;\n  /**\n   * @description The children rendered inside the marquee\n   * @type {ReactNode}\n   * @default null\n   */\n  children?: ReactNode;\n} & RefAttributes<HTMLDivElement>;\n\nexport const Marquee: FC<MarqueeProps> = forwardRef(function Marquee(\n  {\n    style = {},\n    className = \"\",\n    autoFill = false,\n    play = true,\n    pauseOnHover = false,\n    pauseOnClick = false,\n    direction = \"left\",\n    speed = 50,\n    delay = 0,\n    loop = 0,\n    gradient = false,\n    gradientColor = [255, 255, 255],\n    gradientWidth = 200,\n    onFinish,\n    onCycleComplete,\n    onMount,\n    children,\n  },\n  ref,\n) {\n  // React Hooks\n  const [containerWidth, setContainerWidth] = useState(0);\n  const [marqueeWidth, setMarqueeWidth] = useState(0);\n  const [multiplier, setMultiplier] = useState(1);\n  const [isMounted, setIsMounted] = useState(false);\n  const rootRef = useRef<HTMLDivElement>(null);\n  const containerRef = (ref as RefObject<HTMLDivElement>) || rootRef;\n  const marqueeRef = useRef<HTMLDivElement>(null);\n  const resizeObserverRef = useRef<ResizeObserver | null>(null);\n  const calculateWidthRef = useRef<() => void>(() => {});\n\n  // Calculate width of container and marquee and set multiplier\n  const calculateWidth = useCallback(() => {\n    if (marqueeRef.current && containerRef.current) {\n      const containerRect = containerRef.current.getBoundingClientRect();\n      const marqueeRect = marqueeRef.current.getBoundingClientRect();\n      let containerWidth = containerRect.width;\n      let marqueeWidth = marqueeRect.width;\n\n      // Swap width and height if direction is up or down\n      if (direction === \"up\" || direction === \"down\") {\n        containerWidth = containerRect.height;\n        marqueeWidth = marqueeRect.height;\n      }\n\n      if (autoFill && containerWidth && marqueeWidth) {\n        setMultiplier(marqueeWidth < containerWidth ? Math.ceil(containerWidth / marqueeWidth) : 1);\n      } else {\n        setMultiplier(1);\n      }\n\n      setContainerWidth(containerWidth);\n      setMarqueeWidth(marqueeWidth);\n    }\n  }, [autoFill, containerRef, direction]);\n\n  useEffect(() => {\n    calculateWidthRef.current = calculateWidth;\n  }, [calculateWidth]);\n\n  // Calculate width and multiplier on mount and on window resize\n  useEffect(() => {\n    if (!isMounted) return;\n\n    // Create the observer exactly once\n    if (!resizeObserverRef.current) {\n      resizeObserverRef.current = new ResizeObserver(() => {\n        calculateWidthRef.current();\n      });\n    }\n    // If refs are available, observe them\n    if (marqueeRef.current && containerRef.current) {\n      resizeObserverRef.current.observe(containerRef.current);\n      resizeObserverRef.current.observe(marqueeRef.current);\n    }\n    return () => {\n      // Cleanup observer on unmount\n      resizeObserverRef.current?.disconnect();\n    };\n  }, [isMounted, containerRef]);\n\n  useEffect(() => {\n    setIsMounted(true);\n    return () => {\n      if (!resizeObserverRef.current) return;\n      resizeObserverRef.current.disconnect();\n    };\n  }, []);\n\n  // Runs the onMount callback, if it is a function, when Marquee is mounted.\n  useEffect(() => {\n    if (typeof onMount === \"function\") {\n      onMount();\n    }\n  }, [onMount]);\n\n  // Animation duration\n  const duration = useMemo(() => {\n    if (autoFill) {\n      return (marqueeWidth * multiplier) / speed;\n    } else {\n      return marqueeWidth < containerWidth ? containerWidth / speed : marqueeWidth / speed;\n    }\n  }, [autoFill, containerWidth, marqueeWidth, multiplier, speed]);\n\n  // Gradient color in an unfinished rgba format\n  const rgbaGradientColor = `rgba(${gradientColor[0]}, ${gradientColor[1]}, ${gradientColor[2]}`;\n\n  const containerStyle = useMemo(\n    () => ({\n      ...style,\n      [\"--ha-marquee-pause-on-hover\" as string]: !play || pauseOnHover ? \"paused\" : \"running\",\n      [\"--ha-marquee-pause-on-click\" as string]: !play || (pauseOnHover && !pauseOnClick) || pauseOnClick ? \"paused\" : \"running\",\n      [\"--ha-marquee-width\" as string]: direction === \"up\" || direction === \"down\" ? `100vh` : \"100%\",\n      [\"--ha-marquee-transform\" as string]: direction === \"up\" ? \"rotate(-90deg)\" : direction === \"down\" ? \"rotate(90deg)\" : \"none\",\n    }),\n    [style, play, pauseOnHover, pauseOnClick, direction],\n  );\n\n  const gradientStyle = useMemo(\n    () => ({\n      [\"--ha-marquee-gradient-color\" as string]: `${rgbaGradientColor}, 1), ${rgbaGradientColor}, 0)`,\n      [\"--ha-marquee-gradient-width\" as string]: typeof gradientWidth === \"number\" ? `${gradientWidth}px` : gradientWidth,\n    }),\n    [rgbaGradientColor, gradientWidth],\n  );\n\n  const marqueeStyle = useMemo(\n    () => ({\n      [\"--ha-marquee-play\" as string]: play ? \"running\" : \"paused\",\n      [\"--ha-marquee-direction\" as string]: direction === \"left\" ? \"normal\" : \"reverse\",\n      [\"--ha-marquee-duration\" as string]: `${duration}s`,\n      [\"--ha-marquee-delay\" as string]: `${delay}s`,\n      [\"--ha-marquee-iteration-count\" as string]: loop > 0 ? `${loop}` : \"infinite\",\n      [\"--ha-marquee-min-width\" as string]: autoFill ? `auto` : \"100%\",\n      [\"--ha-marquee-padding-right\" as string]: autoFill ? `4rem` : \"0\",\n    }),\n    [play, direction, duration, delay, loop, autoFill],\n  );\n\n  const childStyle = useMemo(\n    () => ({\n      [\"--ha-marquee-transform\" as string]: direction === \"up\" ? \"rotate(90deg)\" : direction === \"down\" ? \"rotate(-90deg)\" : \"none\",\n    }),\n    [direction],\n  );\n\n  // Render {multiplier} number of children\n  const multiplyChildren = useCallback(\n    (multiplier: number) => {\n      return [...Array(Number.isFinite(multiplier) && multiplier >= 0 ? multiplier : 0)].map((_, i) => (\n        <Fragment key={i}>\n          {Children.map(children, (child, index) => {\n            return (\n              <div style={childStyle} className={`child ${index === Children.toArray(children).length - 1 ? \"last-child\" : \"\"}`}>\n                {child}\n              </div>\n            );\n          })}\n        </Fragment>\n      ));\n    },\n    [childStyle, children],\n  );\n\n  return !isMounted ? null : (\n    <StyledMarquee ref={containerRef} style={containerStyle} className={\"marquee-container \" + className}>\n      {gradient && <div style={gradientStyle} className=\"overlay\" />}\n      <div className=\"marquee\" style={marqueeStyle} onAnimationIteration={onCycleComplete} onAnimationEnd={onFinish}>\n        <div className=\"initial-child-container\" ref={marqueeRef}>\n          {Children.map(children, (child, index) => {\n            return (\n              <div style={childStyle} className={`child ${index === Children.toArray(children).length - 1 ? \"last-child\" : \"\"}`}>\n                {child}\n              </div>\n            );\n          })}\n        </div>\n        {multiplyChildren(multiplier - 1)}\n      </div>\n      <div className=\"marquee\" style={marqueeStyle}>\n        {multiplyChildren(multiplier)}\n      </div>\n    </StyledMarquee>\n  );\n});\n"],"names":["StyledMarquee","_styled","process","env","NODE_ENV","target","label","name","styles","toString","_EMOTION_STRINGIFIED_CSS_ERROR__","Marquee","forwardRef","style","className","autoFill","play","pauseOnHover","pauseOnClick","direction","speed","delay","loop","gradient","gradientColor","gradientWidth","onFinish","onCycleComplete","onMount","children","ref","containerWidth","setContainerWidth","useState","marqueeWidth","setMarqueeWidth","multiplier","setMultiplier","isMounted","setIsMounted","rootRef","useRef","containerRef","marqueeRef","resizeObserverRef","calculateWidthRef","calculateWidth","useCallback","current","containerRect","getBoundingClientRect","marqueeRect","width","height","Math","ceil","useEffect","ResizeObserver","observe","disconnect","duration","useMemo","rgbaGradientColor","containerStyle","gradientStyle","marqueeStyle","childStyle","multiplyChildren","Array","Number","isFinite","map","_","i","jsx","Fragment","Children","child","index","toArray","length","jsxs"],"mappings":"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"}