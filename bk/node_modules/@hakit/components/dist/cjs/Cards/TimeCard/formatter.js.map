{"version":3,"file":"formatter.js","sources":["../../../../src/Cards/TimeCard/formatter.tsx"],"sourcesContent":["import {\n  CustomFormatters,\n  DateParts,\n  Formatters,\n  FormatterMask,\n  DatePartName,\n  FormatOptions,\n  FormatFunction,\n  Parser,\n  Token,\n} from \"./types\";\nimport { AmOrPm } from \"./shared\";\nimport { Fragment, cloneElement, isValidElement } from \"react\";\n\nconst parsers: Map<string, Parser> = new Map();\n\nconst intlFormattersOptions = [\n  {\n    weekday: \"long\",\n    year: \"numeric\",\n    month: \"2-digit\",\n    day: \"2-digit\",\n    hour: \"2-digit\",\n    minute: \"2-digit\",\n    second: \"2-digit\",\n  },\n  {\n    month: \"long\",\n    hour: \"2-digit\",\n    hour12: false,\n  },\n] satisfies Partial<Intl.DateTimeFormatOptions>[];\n\nexport function createDateFormatter(customFormatters: CustomFormatters): FormatFunction {\n  return function intlFormatDate(date: Date, format: string, options?: FormatOptions): React.ReactNode {\n    const tokens = parseDate(date, options);\n    const output = formatDate(customFormatters, format, tokens, date);\n    return output;\n  };\n}\n\nconst createIntlFormatterWith = (options: FormatOptions): Intl.DateTimeFormat[] =>\n  intlFormattersOptions.map(\n    (intlFormatterOptions) =>\n      new Intl.DateTimeFormat(options.locale, {\n        ...intlFormatterOptions,\n        timeZone: options.timezone,\n      }),\n  );\n\nconst longTokensTransformer = (token: Token): Token =>\n  (token.type !== \"literal\" ? { type: `l${token.type}`, value: token.value } : token) as Token;\n\nconst datePartsReducer = (parts: DateParts, token: Token): DateParts => {\n  parts[token.type as DatePartName] = token.value;\n  return parts;\n};\n\nconst tokenize = (intlFormatter: Intl.DateTimeFormat, date: Date): Token[] =>\n  intlFormatter.formatToParts(date).filter((token) => token.type !== \"literal\") as Token[];\n\nconst normalize = (parts: DateParts): DateParts => {\n  // Chrome <= 71 and Node >= 10 incorrectly case `dayperiod` (#4)\n  // dayPeriod will be undefined for 24 hour clocks so fall back to empty string\n  parts.dayPeriod =\n    parts.dayPeriod ||\n    // @ts-expect-error - see note above\n    parts.dayperiod ||\n    \"\";\n  // @ts-expect-error - see note above\n  delete parts.dayperiod;\n\n  // Chrome >= 80 has a bug going over 24h\n  parts.lhour = (\"0\" + (Number(parts.lhour) % 24)).slice(-2);\n\n  return parts;\n};\n\nconst createParser = (options: FormatOptions): Parser => {\n  const [intlFormatter, intlFormatterLong] = createIntlFormatterWith(options);\n\n  return function parseDateImpl(date: Date): DateParts {\n    const tokens = tokenize(intlFormatter, date);\n    const longTokens = tokenize(intlFormatterLong, date).map(longTokensTransformer);\n    const allTokens = [...tokens, ...longTokens];\n    const parts = allTokens.reduce(datePartsReducer, {} as DateParts);\n\n    return normalize(parts);\n  };\n};\n\nfunction parseDate(date: Date, options: FormatOptions = {}): DateParts {\n  const key = `${options.locale}${options.timezone}`;\n\n  let parser = parsers.get(key);\n  if (!parser) {\n    parser = createParser(options);\n    parsers.set(key, parser);\n  }\n\n  return parser(date);\n}\n\nexport function daySuffix(day: number) {\n  let suffix = \"\";\n  switch (day) {\n    case 1:\n    case 21:\n    case 31:\n      suffix = \"st\";\n      break;\n    case 2:\n    case 22:\n      suffix = \"nd\";\n      break;\n    case 3:\n    case 23:\n      suffix = \"rd\";\n      break;\n    default:\n      suffix = \"th\";\n  }\n  return suffix;\n}\n\nconst defaultPattern = \"[YMDxdAaHhms]+\";\n\nconst formatters: Formatters = {\n  YYYY: (parts) => parts.year,\n  YY: (parts) => parts.year.slice(-2),\n  MMMM: (parts) => parts.lmonth,\n  MMM: (parts) => parts.lmonth.slice(0, 3),\n  MM: (parts) => parts.month,\n  DD: (parts) => parts.day,\n  DDx: (parts) => `${parts.day}${daySuffix(parseInt(parts.day))}`,\n  dd: (parts) => `${parseInt(parts.day, 10)}`,\n  ddx: (parts) => `${parseInt(parts.day, 10)}${daySuffix(parseInt(parts.day))}`,\n  dddd: (parts) => parts.weekday,\n  ddd: (parts) => parts.weekday.slice(0, 3),\n  A: (parts) => <AmOrPm className=\"time-suffix\">{parts.dayPeriod}</AmOrPm>,\n  a: (parts) => <AmOrPm className=\"time-suffix\">{parts.dayPeriod.toLowerCase()}</AmOrPm>,\n  // XXX: fix Chrome 80+ bug going over 24h\n  HH: (parts) => (\"0\" + (Number(parts.lhour) % 24)).slice(-2),\n  hh: (parts) => parts.hour,\n  mm: (parts) => parts.minute,\n  ss: (parts) => parts.second,\n};\n\nconst createCustomPattern = (customFormatters: CustomFormatters) => Object.keys(customFormatters).reduce((_, key) => `|${key}`, \"\");\n\nfunction formatDate(customFormatters: CustomFormatters, format: string, parts: DateParts, date: Date): React.ReactNode {\n  const literalPattern = \"\\\\[([^\\\\]]+)\\\\]|\";\n  const customPattern = createCustomPattern(customFormatters);\n  const patternRegexp = new RegExp(`${literalPattern}${defaultPattern}${customPattern}`, \"g\");\n\n  const allFormatters = { ...formatters, ...customFormatters };\n  // We'll accumulate text/JSX in an array\n  const tokens: React.ReactNode[] = [];\n  let lastIndex = 0;\n  // @ts-expect-error - will fix later\n  format.replace(patternRegexp, (mask: FormatterMask, literal: string, offset: number) => {\n    // 'offset' is the index of this match within the full format string\n\n    // Push any text that occurs before this match\n    if (offset > lastIndex) {\n      const val = format.slice(lastIndex, offset);\n      if (val.length > 0 && val.trim().length === 0) {\n        // whitespace char\n        tokens.push(<span className=\"whitespace\">&nbsp;</span>);\n      } else {\n        tokens.push(val);\n      }\n    }\n    lastIndex = offset + mask.length;\n\n    if (literal) {\n      // If we matched [literal text], just push that as plain text\n      tokens.push(literal);\n    } else {\n      // Everything else just push normally\n      tokens.push(allFormatters[mask](parts, date));\n    }\n    // Return an empty string to discard the normal replace output\n    return \"\";\n  });\n  // If there's still text remaining after the last match, push it\n  if (lastIndex < format.length) {\n    tokens.push(format.slice(lastIndex));\n  }\n  // Finally, render the HTML string inside React. We must do dangerouslySetInnerHTML\n  // so that <div> ... </div> is recognized as HTML, not plain text:\n  return (\n    <>\n      {tokens.map((tok, i) => {\n        // Strings need to be wrapped so they can carry a key\n        if (typeof tok === \"string\") {\n          return <Fragment key={i}>{tok}</Fragment>;\n        }\n\n        // Valid elements: clone to add/override the key\n        if (isValidElement(tok)) {\n          return cloneElement(tok, { key: i });\n        }\n\n        // Anything else (null, boolean) can be returned as-is\n        return tok;\n      })}\n    </>\n  );\n}\n"],"names":["parsers","Map","intlFormattersOptions","weekday","year","month","day","hour","minute","second","hour12","createDateFormatter","customFormatters","date","format","options","tokens","parseDate","formatDate","createIntlFormatterWith","map","Intl","DateTimeFormat","locale","intlFormatterOptions","timeZone","timezone","longTokensTransformer","token","type","value","datePartsReducer","parts","tokenize","intlFormatter","formatToParts","filter","normalize","dayPeriod","dayperiod","lhour","Number","slice","createParser","intlFormatterLong","longTokens","reduce","key","parser","get","set","daySuffix","suffix","defaultPattern","formatters","YYYY","YY","MMMM","lmonth","MMM","MM","DD","DDx","parseInt","dd","ddx","dddd","ddd","A","jsx","AmOrPm","a","toLowerCase","HH","hh","mm","ss","createCustomPattern","Object","keys","_","literalPattern","customPattern","patternRegexp","RegExp","allFormatters","lastIndex","replace","mask","literal","offset","val","length","trim","push","Fragment","tok","i","isValidElement","cloneElement"],"mappings":"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"}